{"meta":{"title":"Givingcode","subtitle":"如果第一次失败了，那这是1.0版本，请继续努力","description":"如果第一次失败了，那这是1.0版本，请继续努力","author":"Givingcode","url":""},"pages":[{"title":"分类","date":"2018-01-04T16:00:00.000Z","updated":"2020-02-15T11:58:37.599Z","comments":false,"path":"categories/index.html","permalink":"/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-01-04T16:00:00.000Z","updated":"2020-02-15T11:58:37.600Z","comments":false,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"那些年我们听过的歌","date":"2020-02-15T08:27:52.000Z","updated":"2020-02-15T12:05:40.437Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"var options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":3,\"mode\":\"random\",\"mutex\":true,\"theme\":\"#e6d0b2\",\"preload\":\"metadata\",\"listmaxheight\":\"513px\",\"music\":[{\"title\":\"Faded\",\"author\":\"Alan Walke\",\"url\":\"https://raw.githubusercontent.com/wiki/Givingcode/images/music/Faded.flac\",\"pic\":\"https://raw.githubusercontent.com/wiki/Givingcode/images/music/Alan Walke.png\",\"lrc\":\"https://raw.githubusercontent.com/wiki/Givingcode/images/music/Faded.lrc\"},{\"title\":\"真的爱你\",\"author\":\"Beyond\",\"url\":\"https://raw.githubusercontent.com/wiki/Givingcode/images/music/真的爱你.wav\",\"pic\":\"https://raw.githubusercontent.com/wiki/Givingcode/images/music/beyond.png\",\"lrc\":\"https://raw.githubusercontent.com/wiki/Givingcode/images/music/真的爱你.lrc\"},{\"title\":\"凉凉\",\"author\":\"冯提莫、杨宗纬\",\"url\":\"https://raw.githubusercontent.com/wiki/Givingcode/images/music/冯提莫、杨宗纬+-+凉凉.flac\",\"pic\":\"https://raw.githubusercontent.com/wiki/Givingcode/images/music/冯提莫.png\",\"lrc\":\"https://raw.githubusercontent.com/wiki/Givingcode/images/music/凉凉.lrc\"},{\"title\":\"阿刁\",\"author\":\"张韶涵\",\"url\":\"https://raw.githubusercontent.com/wiki/Givingcode/images/music/张韶涵 - 阿刁.flac\",\"pic\":\"https://raw.githubusercontent.com/wiki/Givingcode/images/music/张韶涵.png\",\"lrc\":\"https://raw.githubusercontent.com/wiki/Givingcode/images/music/阿刁.lrc\"},{\"title\":\"Sing Me to Sleep\",\"author\":\"Alan Walke\",\"url\":\"https://raw.githubusercontent.com/wiki/Givingcode/images/music/Sing Me to Sleep.flac\",\"pic\":\"https://raw.githubusercontent.com/wiki/Givingcode/images/music/Alan Walke.png\"},{\"title\":\"The Spectre\",\"author\":\"Alan Walke\",\"url\":\"https://raw.githubusercontent.com/wiki/Givingcode/images/music/The Spectre.flac\",\"pic\":\"https://raw.githubusercontent.com/wiki/Givingcode/images/music/Alan Walke.png\"},{\"title\":\"Tired\",\"author\":\"Alan Walke\",\"url\":\"https://raw.githubusercontent.com/wiki/Givingcode/images/music/Tired.flac\",\"pic\":\"https://raw.githubusercontent.com/wiki/Givingcode/images/music/Alan Walke.png\"}]}; options.element = document.getElementById(\"aplayer-aIgIPlEA\"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);"},{"title":"那些年我到过的地方","date":"2018-09-30T09:25:30.000Z","updated":"2020-02-15T11:58:37.599Z","comments":false,"path":"gallery/index.html","permalink":"/gallery/index.html","excerpt":"","text":"Chengdu Cambodia Philippines"}],"posts":[{"title":"python自动化打包部署","slug":"python自动化打包部署","date":"2020-04-12T09:51:13.000Z","updated":"2020-04-27T06:05:39.559Z","comments":true,"path":"2020/04/12/python自动化打包部署/","link":"","permalink":"/2020/04/12/python自动化打包部署/","excerpt":"","text":"基于python实现前端项目打包部署，使用方法： 本地安装python环境，并且配置好环境变量，不会的点我 在本地新建auto.py然后粘贴进以下脚本，然后修改顶部注释部分的相关参数 打开命令行工具，cd到auto.py所在目录，然后python auto.py回车执行脚本 按照提示输入服务器登录密码，回车 python123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169import paramikoimport os# —————————————————————此处配置打包相关参数———————————————————————# 本地项目目录project_path = r'E:\\projects\\cloud-music'# 项目打包后的目录，一般为dist或者buildbuild_path = 'build'# 服务器目录remote_path = r'/www/cloud-music'# 服务器地址hostname = '192.168.1.225'# 登陆服务器的用户名username = 'fuck'# ————————————————————————配置结束—————————————————————————————class SSHConnect: # 定义一个私有变量，用来保存ssh连接通道，初始化为None __transport = None # 初始化构造函数（主机，用户名，密码，端口，默认22） def __init__(self, hostname, username, password, port=22): self.hostname = hostname self.port = port self.username = username self.password = password # 创建 ssh 连接通道 self.connect() # 建立ssh 连接通道，并绑定在 __transport 上 def connect(self): try: # 设置SSH 连接的远程主机地址和端口 self.__transport = paramiko.Transport((self.hostname, self.port)) # 通过用户名和密码连接SSH服务端 self.__transport.connect(username=self.username, password=self.password) except Exception as e: # 连接出错 print(e) # 执行linux命令 def exec(self, command): # 创建 ssh 客户端 ssh = paramiko.SSHClient() # 指定连接的通道 ssh._transport = self.__transport # 打开一个Channel并执行命令, 调用 exec_command 方法执行命令 stdin, stdout, stderr = ssh.exec_command(command) # 获取命令结果，返回是二进制，需要编码一下 res = stdout.read().decode('utf-8') # 获取错误信息 error = stderr.read().decode('utf-8') # 如果没出错 if error.strip(): # 返回错误信息 return error else: # 返回结果 return res # 前端打包（入参work_path为项目目录） def build(self, work_path): # 开始打包 print('_______________________________________________') print('正在打包...') # 打包命令 cmd = 'npm run build' # 切换到需要项目目录 os.chdir(work_path) # 当前项目目录下执行打包命令 if os.system(cmd) == 0: # 打包完成 print('打包完成！') print('开始上传文件...') # 文件上传 def upload(self, local_path, target_path): # 判断路径问题 if not os.path.exists(local_path): return print('local path is not exist') # 实例化一个 sftp 对象,指定连接的通道 sftp = paramiko.SFTPClient.from_transport(self.__transport) # 打包后的文件路径 local_path = os.path.join(local_path, build_path) # 本地路径转换，将windows下的 \\ 转成 / local_path = '/'.join(local_path.split('\\\\')) # 递归上传文件 self.upload_file(sftp, local_path, target_path) print('Everything is ok,Have a nice day!') # 关闭连接 self.close() # 递归上传文件 def upload_file(self, sftp, local_path, target_path): # 判断当前路径是否是文件夹 if not os.path.isdir(local_path): # 如果是文件，获取文件名 file_name = os.path.basename(local_path) # 检查服务器文件夹是否存在 self.check_remote_dir(sftp, target_path) # 服务器创建文件 target_file_path = os.path.join(target_path, file_name).replace('\\\\', '/') # 上传到服务器 sftp.put(local_path, target_file_path) else: # 查看当前文件夹下的子文件 file_list = os.listdir(local_path) # 遍历子文件 for p in file_list: # 拼接当前文件路径 current_local_path = os.path.join(local_path, p).replace('\\\\', '/') # 拼接服务器文件路径 current_target_path = os.path.join(target_path, p).replace('\\\\', '/') # 如果已经是文件，服务器就不需要创建文件夹了 if os.path.isfile(current_local_path): # 提取当前文件所在的文件夹 current_target_path = os.path.split(current_target_path)[0] # 递归判断 self.upload_file(sftp, current_local_path, current_target_path) # 创建服务器文件夹 def check_remote_dir(self, sftp, target_path): try: # 判断文件夹是否存在 sftp.stat(target_path) except IOError: # 创建文件夹 self.exec(r'mkdir -p %s ' % target_path) # 自动化打包部署 def auto_deploy(self, local_path, target_path): # 打包构建 self.build(local_path) # 清空文件 self.clear_remote_dir(target_path) # 文件上传 self.upload(local_path, target_path) # 清空文件夹 def clear_remote_dir(self, target_path): if target_path[-1] == '/': cmd = f'rm -rf &#123;target_path&#125;*' else: cmd = f'rm -rf &#123;target_path&#125;/*' self.exec(cmd) # 关闭连接 def close(self): self.__transport.close() # 销毁实例 def __del__(self): self.__transport.close()if __name__ == '__main__': # 实例化 password = input(\"请输入服务器连接密码：\") ssh = SSHConnect(hostname=hostname, username=username, password=password) # 自动打包部署 ssh.auto_deploy(project_path, remote_path)","categories":[{"name":"Python","slug":"Python","permalink":"/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"},{"name":"部署","slug":"部署","permalink":"/tags/部署/"},{"name":"自动化","slug":"自动化","permalink":"/tags/自动化/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"/categories/Python/"}]},{"title":"pm2实现自动化部署","slug":"pm2实现自动化部署","date":"2020-03-01T07:21:45.000Z","updated":"2020-03-29T08:24:35.415Z","comments":true,"path":"2020/03/01/pm2实现自动化部署/","link":"","permalink":"/2020/03/01/pm2实现自动化部署/","excerpt":"","text":"基于git，使用node的pm2实现项目的自动化部署，服务器环境以centos为例 环境配置因为是基于git和node，所以本机和部署项目的服务器都需要安装node和git，然后安装pm2本地环境比较简单，不赘述，centos下可以借助yum来安装bash123456yum install -y nodejs# 装完以后继续安装pm2，本地环境同理npm install pm2 -g# 接下来安装gityum install -y git# 安装完以后可以git -v查看版本 配置ssh key这一步是为了让本地计算机、github、服务器之间建立连接，因此本机和部署项目的服务器都需要添加ssh，这个比较简单，不会的可以参考Github 简明教程 添加pm2配置文件在本地项目根目录添加ecosystem.json！！！注意：因为是json格式，实际使用请删除注释javascript1234567891011121314151617181920212223242526272829303132333435&#123; \"apps\":[ &#123; \"name\": \"app\", // 项目名称 \"script\": \"app.js\", // 入口文件 \"env\": &#123; \"COMMON_VARIABLE\": \"true\" &#125;, \"env_production\": &#123; \"NODE_ENV\": \"production\" // 环境变量 &#125; &#125; ], // 环境部署的配置 \"deploy\": &#123; \"production\": &#123; // 登录服务器的用户名 \"user\":\"slevin\", // 服务器ip \"host\": [\"12.34.56.78\"], // 服务器ssh登录端口，未修改的话一般默认为22 \"port\": \"22\", // 指定拉取的分支 \"ref\": \"origin/master\", // 远程仓库地址 \"repo\": \"git@github.com:yourName/xxx.git\", // 指定代码拉取到服务器的目录 \"path\": \"/home/projects/xxx\", \"ssh_options\": \"StrictHostKeyChecking=no\", \"env\": &#123; \"NODE_ENV\": \"production\" &#125; &#125; &#125;&#125; 本地push与服务器端pull github上创建仓库，比如xxx 在本地项目根目录执行以下命令 bash1234git init # 初始化仓库git commit -m \"init project\" # 添加提交信息git remote add origin git@github.com:yourName/xxx.git # 指定remote地址git push -u origin master # 推送 在服务器端 bash1234cd /home/projects/git clone git@github.com:yourName/xxx.git # 克隆github项目，(非node项目略过下面2步)cd xxxnpm install # 安装依赖 ps：以上步骤首次操作可能会提示你输入github登陆密码 自动化部署bash12pm2 deploy ecosystem.json production setup # 首次部署执行一次即可pm2 deploy ecosystem.json production 后续开发中，提交本地代码到remote后，只需要执行pm2 deploy ecosystem.json production即可 问题处理 提示bash: pm2: command not found post-deploy hook failed Deploy failed 1即是：找不到pm2命令，解决办法，添加pm2的软链接，在服务器端执行：bash123456# 查找pm2的路径whereis pm2# pm2: /usr/bin/pm2 /root/node/bin/pm2，添加软连接#sudo ln -s [查找到的链接] /usr/bin/pm2# 即是： sudo ln -s /usr/bin/pm2 /root/node/bin/pm2 /usr/bin/pm2","categories":[{"name":"node","slug":"node","permalink":"/categories/node/"}],"tags":[{"name":"pm2","slug":"pm2","permalink":"/tags/pm2/"},{"name":"部署","slug":"部署","permalink":"/tags/部署/"}],"keywords":[{"name":"node","slug":"node","permalink":"/categories/node/"}]},{"title":"React状态逻辑复用","slug":"React状态逻辑复用","date":"2020-02-15T06:22:33.000Z","updated":"2020-02-15T11:58:37.598Z","comments":true,"path":"2020/02/15/React状态逻辑复用/","link":"","permalink":"/2020/02/15/React状态逻辑复用/","excerpt":"","text":"Mixin关于MixinMixin（混入）是一种通过扩展收集功能的方式，它本质上是将一个对象的属性拷贝到另一个对象上面去，不过你可以拷贝任意多个对象的任意方法到一个新对象上去，这是继承所不能实现的。它的出现主要就是为了解决代码复用问题。 写一个简单的Mixin方法：javascript12345678910111213141516function setMixin(target, mixin) &#123; if (arguments[2]) &#123; for (var i = 2, len = arguments.length; i &lt; len; i++) &#123; target.prototype[arguments[i]] = mixin.prototype[arguments[i]]; &#125; &#125; else &#123; for (var methodName in mixin.prototype) &#123; if (!Object.hasOwnProperty(target.prototype, methodName)) &#123; target.prototype[methodName] = mixin.prototype[methodName]; &#125; &#125; &#125;&#125;setMixin(User,LogMixin,'actionLog');setMixin(Goods,LogMixin,'requestLog'); Mixin应用React也提供了Mixin的实现，如果完全不同的组件有相似的功能，我们可以引入来实现代码复用，当然只有在使用createClass来创建React组件时才可以使用，因为在React组件的es6写法中它已经被废弃掉了。例如下面的例子，很多组件或页面都需要记录用户行为，性能指标等。如果我们在每个组件都引入写日志的逻辑，会产生大量重复代码，通过Mixin我们可以解决这一问题：javascript12345678910111213141516171819202122232425const LogMixin = &#123; log: function() &#123; console.log('log'); &#125;, componentDidMount: function() &#123; console.log('in'); &#125;, componentWillUnmount: function() &#123; console.log('out'); &#125;&#125;;const User = React.createClass(&#123; mixins: [LogMixin], render: function() &#123; return (&lt;div&gt;...&lt;/div&gt;) &#125;&#125;);const Goods = React.createClass(&#123; mixins: [LogMixin], render: function() &#123; return (&lt;div&gt;...&lt;/div&gt;) &#125;&#125;); 缺点 Mixin 可能会相互依赖，相互耦合，不利于代码维护 不同的Mixin中的方法可能会相互冲突 Mixin非常多时，组件是可以感知到的，甚至还要为其做相关处理，这样会给代码造成滚雪球式的复杂性 HOC关于HOC 高阶组件可以看作React对装饰模式的一种实现，高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。 HOC是React中的高级技术，用来重用组件逻辑。但高阶组件本身并不是React API。它只是一种模式，这种模式是由React自身的组合性质必然产生的javascript12345678910function visible(WrappedComponent) &#123; return class extends Component &#123; render() &#123; const &#123; visible, ...props &#125; = this.props; if (visible === false) return null; return &lt;WrappedComponent &#123;...props&#125; /&gt;; &#125; &#125;&#125; 上面的代码就是一个HOC的简单应用，函数接收一个组件作为参数，并返回一个新组件，新组建可以接收一个visible props，根据visible的值来判断是否渲染Visible。 实现方式属性代理函数返回一个我们自己定义的组件，然后在render中返回要包裹的组件，这样我们就可以代理所有传入的props，并且决定如何渲染，实际上 ，这种方式生成的高阶组件就是原组件的父组件，上面的函数visible就是一个HOC属性代理的实现方式 javascript1234567function proxyHOC(WrappedComponent) &#123; return class extends Component &#123; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; /&gt;; &#125; &#125;&#125; 对比原生组件增强的项： 可操作所有传入的props 可操作组件的生命周期 可操作组件的static方法 获取refs 反向继承返回一个组件，继承原组件，在render中调用原组件的render。由于继承了原组件，能通过this访问到原组件的生命周期、props、state、render等，相比属性代理它能操作更多的属性。 javascript1234567function inheritHOC(WrappedComponent) &#123; return class extends WrappedComponent &#123; render() &#123; return super.render(); &#125; &#125;&#125; 对比原生组件增强的项： 可操作所有传入的props 可操作组件的生命周期 可操作组件的static方法 获取refs 可操作state 可以渲染劫持 实际应用组合渲染可使用任何其他组件和原组件进行组合渲染，达到样式、布局复用等效果。 通过属性代理实现 javascript12345678910function stylHOC(WrappedComponent) &#123; return class extends Component &#123; render() &#123; return (&lt;div&gt; &lt;div className=\"title\"&gt;&#123;this.props.title&#125;&lt;/div&gt; &lt;WrappedComponent &#123;...this.props&#125; /&gt; &lt;/div&gt;); &#125; &#125;&#125; 通过反向继承实现 javascript12345678910function styleHOC(WrappedComponent) &#123; return class extends WrappedComponent &#123; render() &#123; return &lt;div&gt; &lt;div className=\"title\"&gt;&#123;this.props.title&#125;&lt;/div&gt; &#123;super.render()&#125; &lt;/div&gt; &#125; &#125;&#125; 条件渲染 通过属性代理实现 javascript12345678function visibleHOC(WrappedComponent) &#123; return class extends Component &#123; render() &#123; if (this.props.visible === false) return null; return &lt;WrappedComponent &#123;...props&#125; /&gt;; &#125; &#125;&#125; 通过反向继承实现 javascript1234567891011function visibleHOC(WrappedComponent) &#123; return class extends WrappedComponent &#123; render() &#123; if (this.props.visible === false) &#123; return null &#125; else &#123; return super.render() &#125; &#125; &#125;&#125; 操作props可以对传入组件的props进行增加、修改、删除或者根据特定的props进行特殊的操作。 通过属性代理实现javascript1234567891011function proxyHOC(WrappedComponent) &#123; return class extends Component &#123; render() &#123; const newProps = &#123; ...this.props, user: 'ConardLi' &#125; return &lt;WrappedComponent &#123;...newProps&#125; /&gt;; &#125; &#125;&#125; 获取refs高阶组件中可获取原组件的ref，通过ref获取组件实力，如下面的代码，当程序初始化完成后调用原组件的log方法 通过属性代理实现javascript12345678910function refHOC(WrappedComponent) &#123; return class extends Component &#123; componentDidMount() &#123; this.wapperRef.log() &#125; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; ref=&#123;ref =&gt; &#123; this.wapperRef = ref &#125;&#125; /&gt;; &#125; &#125;&#125; 状态管理将原组件的状态提取到HOC中进行管理，如下面的代码，我们将Input的value提取到HOC中进行管理，使它变成受控组件，同时不影响它使用onChange方法进行一些其他操作。基于这种方式，我们可以实现一个简单的双向绑定，具体请看双向绑定。 通过属性代理实现javascript1234567891011121314151617181920212223242526272829303132333435function proxyHoc(WrappedComponent) &#123; return class extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; value: '' &#125;; &#125; onChange = (event) =&gt; &#123; const &#123; onChange &#125; = this.props; this.setState(&#123; value: event.target.value, &#125;, () =&gt; &#123; if(typeof onChange ==='function')&#123; onChange(event); &#125; &#125;) &#125; render() &#123; const newProps = &#123; value: this.state.value, onChange: this.onChange, &#125; return &lt;WrappedComponent &#123;...this.props&#125; &#123;...newProps&#125; /&gt;; &#125; &#125;&#125;class HOC extends Component &#123; render() &#123; return &lt;input &#123;...this.props&#125;&gt;&lt;/input&gt; &#125;&#125;export default proxyHoc(HOC); 操作state上面的例子通过属性代理利用HOC的state对原组件进行了一定的增强，但并不能直接控制原组件的state，而通过反向继承，我们可以直接操作原组件的state。但是并不推荐直接修改或添加原组件的state，因为这样有可能和组件内部的操作构成冲突。 通过反向继承实现javascript12345678910111213function debugHOC(WrappedComponent) &#123; return class extends WrappedComponent &#123; render() &#123; console.log('props', this.props); console.log('state', this.state); return ( &lt;div className=\"debuging\"&gt; &#123;super.render()&#125; &lt;/div&gt; ) &#125; &#125;&#125; 上面的HOC在render中将props和state打印出来，可以用作调试阶段，当然你可以在里面写更多的调试代码。想象一下，只需要在我们想要调试的组件上加上@debug就可以对该组件进行调试，而不需要在每次调试的时候写很多冗余代码。(如果你还不知道怎么使用HOC，请👇如何使用HOC) 渲染劫持高阶组件可以在render函数中做非常多的操作，从而控制原组件的渲染输出。只要改变了原组件的渲染，我们都将它称之为一种渲染劫持。实际上，上面的组合渲染和条件渲染都是渲染劫持的一种，通过反向继承，不仅可以实现以上两点，还可直接增强由原组件render函数产生的React元素。 通过反向继承实现javascript1234567891011121314function hijackHOC(WrappedComponent) &#123; return class extends WrappedComponent &#123; render() &#123; const tree = super.render(); let newProps = &#123;&#125;; if (tree &amp;&amp; tree.type === 'input') &#123; newProps = &#123; value: '渲染被劫持了' &#125;; &#125; const props = Object.assign(&#123;&#125;, tree.props, newProps); const newTree = React.cloneElement(tree, props, tree.props.children); return newTree; &#125; &#125;&#125; 如何使用？上面的示例代码都写的是如何声明一个HOC，HOC实际上是一个函数，所以我们将要增强的组件作为参数调用HOC函数，得到增强后的组件。javascript123456class myComponent extends Component &#123; render() &#123; return (&lt;span&gt;原组件&lt;/span&gt;) &#125;&#125;export default inheritHOC(myComponent); Compose在实际应用中，一个组件可能被多个HOC增强，我们使用的是被所有的HOC增强后的组件假设现在我们有logger，visible，style等多个HOC，现在要同时增强一个Input组件：logger(visible(style(Input)))这种代码非常的难以阅读，我们可以手动封装一个简单的函数组合工具，将写法改写如下：javascript12const compose = (...fns) =&gt; fns.reduce((f, g) =&gt; (...args) =&gt; g(f(...args)));compose(logger,visible,style)(Input); compose函数返回一个所有函数组合后的函数，compose(f, g, h) 和 (…args) =&gt; f(g(h(…args)))是一样的。很多第三方库都提供了类似compose的函数，例如lodash.flowRight，Redux提供的combineReducers函数等。 Decorators我们还可以借助ES7为我们提供的Decorators来让我们的写法变的更加优雅：javascript123456@logger@visible@styleclass Input extends Component &#123; // ...&#125; Decorators是ES7的一个提案，还没有被标准化，但目前Babel转码器已经支持，我们需要提前配置babel-plugin-transform-decorators-legacy：“plugins”: [“transform-decorators-legacy”]还可以结合上面的compose函数使用：javascript12345const hoc = compose(logger, visible, style);@hocclass Input extends Component &#123; // ...&#125; HOC的实际应用下面是一些我在生产环境中实际对HOC的实际应用场景，由于文章篇幅原因，代码经过很多简化，如有问题欢迎在评论区指出： 日志打点实际上这属于一类最常见的应用，多个组件拥有类似的逻辑，我们要对重复的逻辑进行复用， 官方文档中CommentList的示例也是解决了代码复用问题，写的很详细某些页面需要记录用户行为，性能指标等等，通过高阶组件做这些事情可以省去很多重复代码。javascript123456789101112131415161718function logHoc(WrappedComponent) &#123; return class extends Component &#123; componentWillMount() &#123; this.start = Date.now(); &#125; componentDidMount() &#123; this.end = Date.now(); console.log(`$&#123;WrappedComponent.dispalyName&#125; 渲染时间：$&#123;this.end - this.start&#125; ms`); console.log(`$&#123;user&#125;进入$&#123;WrappedComponent.dispalyName&#125;`); &#125; componentWillUnmount() &#123; console.log(`$&#123;user&#125;退出$&#123;WrappedComponent.dispalyName&#125;`); &#125; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; /&gt; &#125; &#125;&#125; 可用、权限控制javascript1234567891011function auth(WrappedComponent) &#123; return class extends Component &#123; render() &#123; const &#123; visible, auth, display = null, ...props &#125; = this.props; if (visible === false || (auth &amp;&amp; authList.indexOf(auth) === -1)) &#123; return display &#125; return &lt;WrappedComponent &#123;...props&#125; /&gt;; &#125; &#125;&#125; authList是我们在进入程序时向后端请求的所有权限列表，当组件所需要的权限不列表中，或者设置的 visible是false，我们将其显示为传入的组件样式，或者null。我们可以将任何需要进行权限校验的组件应用HOC：javascript1234567@authclass Input extends Component &#123; ... &#125;@authclass Button extends Component &#123; ... &#125;&lt;Button auth=\"user/addUser\"&gt;添加用户&lt;/Button&gt;&lt;Input auth=\"user/search\" visible=&#123;false&#125; &gt;添加用户&lt;/Input&gt; 双向绑定在vue中，绑定一个变量后可实现双向数据绑定，即表单中的值改变后绑定的变量也会自动改变。而React中没有做这样的处理，在默认情况下，表单元素都是非受控组件。给表单元素绑定一个状态后，往往需要手动书写onChange方法来将其改写为受控组件，在表单元素非常多的情况下这些重复操作是非常痛苦的。我们可以借助高阶组件来实现一个简单的双向绑定，代码略长，可以结合下面的思维导图进行理解。 首先我们自定义一个Form组件，该组件用于包裹所有需要包裹的表单组件，通过contex向子组件暴露两个属性：model：当前Form管控的所有数据，由表单name和value组成，如{name:’ConardLi’,pwd:’123’}。model可由外部传入，也可自行管控。changeModel：改变model中某个name的值。 javascript123456789101112131415161718192021222324252627282930313233343536373839class Form extends Component &#123; static childContextTypes = &#123; model: PropTypes.object, changeModel: PropTypes.func &#125; constructor(props, context) &#123; super(props, context); this.state = &#123; model: props.model || &#123;&#125; &#125;; &#125; componentWillReceiveProps(nextProps) &#123; if (nextProps.model) &#123; this.setState(&#123; model: nextProps.model &#125;) &#125; &#125; changeModel = (name, value) =&gt; &#123; this.setState(&#123; model: &#123; ...this.state.model, [name]: value &#125; &#125;) &#125; getChildContext() &#123; return &#123; changeModel: this.changeModel, model: this.props.model || this.state.model &#125;; &#125; onSubmit = () =&gt; &#123; console.log(this.state.model); &#125; render() &#123; return &lt;div&gt; &#123;this.props.children&#125; &lt;button onClick=&#123;this.onSubmit&#125;&gt;提交&lt;/button&gt; &lt;/div&gt; &#125;&#125; 下面定义用于双向绑定的HOC，其代理了表单的onChange属性和value属性：发生onChange事件时调用上层Form的changeModel方法来改变context中的model。在渲染时将value改为从context中取出的值。 javascript1234567891011121314151617181920212223242526272829303132function proxyHoc(WrappedComponent) &#123; return class extends Component &#123; static contextTypes = &#123; model: PropTypes.object, changeModel: PropTypes.func &#125; onChange = (event) =&gt; &#123; const &#123; changeModel &#125; = this.context; const &#123; onChange &#125; = this.props; const &#123; v_model &#125; = this.props; changeModel(v_model, event.target.value); if(typeof onChange === 'function')&#123;onChange(event);&#125; &#125; render() &#123; const &#123; model &#125; = this.context; const &#123; v_model &#125; = this.props; return &lt;WrappedComponent &#123;...this.props&#125; value=&#123;model[v_model]&#125; onChange=&#123;this.onChange&#125; /&gt;; &#125; &#125;&#125;@proxyHocclass Input extends Component &#123; render() &#123; return &lt;input &#123;...this.props&#125;&gt;&lt;/input&gt; &#125;&#125; 上面的代码只是简略的一部分，除了input，我们还可以将HOC应用在select等其他表单组件，甚至还可以将上面的HOC兼容到span、table等展示组件，这样做可以大大简化代码，让我们省去了很多状态管理的工作，使用如下： javascript12345678910export default class extends Component &#123; render() &#123; return ( &lt;Form &gt; &lt;Input v_model=\"name\"&gt;&lt;/Input&gt; &lt;Input v_model=\"pwd\"&gt;&lt;/Input&gt; &lt;/Form&gt; ) &#125;&#125; 表单校验基于上面的双向绑定的例子，我们再来一个表单验证器，表单验证器可以包含验证函数以及提示信息，当验证不通过时，展示错误信息：javascript12345678910111213141516171819202122232425262728293031323334function validateHoc(WrappedComponent) &#123; return class extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; error: '' &#125; &#125; onChange = (event) =&gt; &#123; const &#123; validator &#125; = this.props; if (validator &amp;&amp; typeof validator.func === 'function') &#123; if (!validator.func(event.target.value)) &#123; this.setState(&#123; error: validator.msg &#125;) &#125; else &#123; this.setState(&#123; error: '' &#125;) &#125; &#125; &#125; render() &#123; return &lt;div&gt; &lt;WrappedComponent onChange=&#123;this.onChange&#125; &#123;...this.props&#125; /&gt; &lt;div&gt;&#123;this.state.error || ''&#125;&lt;/div&gt; &lt;/div&gt; &#125; &#125;&#125;const validatorName = &#123; func: (val) =&gt; val &amp;&amp; !isNaN(val), msg: '请输入数字'&#125;const validatorPwd = &#123; func: (val) =&gt; val &amp;&amp; val.length &gt; 6, msg: '密码必须大于6位'&#125;&lt;HOCInput validator=&#123;validatorName&#125; v_model=\"name\"&gt;&lt;/HOCInput&gt;&lt;HOCInput validator=&#123;validatorPwd&#125; v_model=\"pwd\"&gt;&lt;/HOCInput&gt; 当然，还可以在Form提交的时候判断所有验证器是否通过，验证器也可以设置为数组等等，由于文章篇幅原因，代码被简化了很多，有兴趣的同学可以自己实现。Redux的connect redux中的connect，其实就是一个HOC，下面就是一个简化版的connect实现：javascript1234567891011121314151617181920212223242526272829303132333435export const connect = (mapStateToProps, mapDispatchToProps) =&gt; (WrappedComponent) =&gt; &#123; class Connect extends Component &#123; static contextTypes = &#123; store: PropTypes.object &#125; constructor () &#123; super() this.state = &#123; allProps: &#123;&#125; &#125; &#125; componentWillMount () &#123; const &#123; store &#125; = this.context this._updateProps() store.subscribe(() =&gt; this._updateProps()) &#125; _updateProps () &#123; const &#123; store &#125; = this.context let stateProps = mapStateToProps ? mapStateToProps(store.getState(), this.props): &#123;&#125; let dispatchProps = mapDispatchToProps? mapDispatchToProps(store.dispatch, this.props) : &#123;&#125; this.setState(&#123; allProps: &#123; ...stateProps, ...dispatchProps, ...this.props &#125; &#125;) &#125; render () &#123; return &lt;WrappedComponent &#123;...this.state.allProps&#125; /&gt; &#125; &#125; return Connect&#125; 代码非常清晰，connect函数其实就做了一件事，将mapStateToProps和mapDispatchToProps分别解构后传给原组件，这样我们在原组件内就可以直接用props获取state以及dispatch函数了。 使用HOC的注意事项告诫—静态属性拷贝当我们应用HOC去增强另一个组件时，我们实际使用的组件已经不是原组件了，所以我们拿不到原组件的任何静态属性，我们可以在HOC的结尾手动拷贝他们：javascript12345678910function proxyHOC(WrappedComponent) &#123; class HOCComponent extends Component &#123; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; /&gt;; &#125; &#125; HOCComponent.staticMethod = WrappedComponent.staticMethod; // ... return HOCComponent;&#125; 如果原组件有非常多的静态属性，这个过程是非常痛苦的，而且你需要去了解需要增强的所有组件的静态属性是什么，我们可以使用hoist-non-react-statics来帮助我们解决这个问题，它可以自动帮我们拷贝所有非React的静态方法，使用方式如下：javascript12345678910import hoistNonReactStatic from 'hoist-non-react-statics';function proxyHOC(WrappedComponent) &#123; class HOCComponent extends Component &#123; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; /&gt;; &#125; &#125; hoistNonReactStatic(HOCComponent,WrappedComponent); return HOCComponent;&#125; 告诫—传递refs使用高阶组件后，获取到的ref实际上是最外层的容器组件，而非原组件，但是很多情况下我们需要用到原组件的ref。高阶组件并不能像透传props那样将refs透传，我们可以用一个回调函数来完成ref的传递：javascript12345678910111213141516171819function hoc(WrappedComponent) &#123; return class extends Component &#123; getWrappedRef = () =&gt; this.wrappedRef; render() &#123; return &lt;WrappedComponent ref=&#123;ref =&gt; &#123; this.wrappedRef = ref &#125;&#125; &#123;...this.props&#125; /&gt;; &#125; &#125;&#125;@hocclass Input extends Component &#123; render() &#123; return &lt;input&gt;&lt;/input&gt; &#125;&#125;class App extends Component &#123; render() &#123; return ( &lt;Input ref=&#123;ref =&gt; &#123; this.inpitRef = ref.getWrappedRef() &#125;&#125; &gt;&lt;/Input&gt; ); &#125;&#125; React 16.3版本提供了一个forwardRef API来帮助我们进行refs传递，这样我们在高阶组件上获取的ref就是原组件的ref了，而不需要再手动传递，如果你的React版本大于16.3，可以使用下面的方式:javascript1234567891011function hoc(WrappedComponent) &#123; class HOC extends Component &#123; render() &#123; const &#123; forwardedRef, ...props &#125; = this.props; return &lt;WrappedComponent ref=&#123;forwardedRef&#125; &#123;...props&#125; /&gt;; &#125; &#125; return React.forwardRef((props, ref) =&gt; &#123; return &lt;HOC forwardedRef=&#123;ref&#125; &#123;...props&#125; /&gt;; &#125;);&#125; 告诫—不要在render方法内创建高阶组件React Diff算法的原则是： 使用组件标识确定是卸载还是更新组件 如果组件的和前一次渲染时标识是相同的，递归更新子组件 如果标识不同卸载组件重新挂载新组件 每次调用高阶组件生成的都是是一个全新的组件，组件的唯一标识响应的也会改变，如果在render方法调用了高阶组件，这会导致组件每次都会被卸载后重新挂载。 约定-不要改变原始组件 官方文档对高阶组件的说明： 高阶组件就是一个没有副作用的纯函数。 我们再来看看纯函数的定义： 如果函数的调用参数相同，则永远返回相同的结果。它不依赖于程序执行期间函数外部任何状态或数据的变化，必须只依赖于其输入参数。 该函数不会产生任何可观察的副作用，例如网络请求，输入和输出设备或数据突变。 如果我们在高阶组件对原组件进行了修改，例如下面的代码： javascript1InputComponent.prototype.componentWillReceiveProps = function(nextProps) &#123; ... &#125; 这样就破坏了我们对高阶组件的约定，同时也改变了使用高阶组件的初衷：我们使用高阶组件是为了增强而非改变原组件。 约定-透传不相关的props使用高阶组件，我们可以代理所有的props，但往往特定的HOC只会用到其中的一个或几个props。我们需要把其他不相关的props透传给原组件，如下面的代码： javascript123456789function visible(WrappedComponent) &#123; return class extends Component &#123; render() &#123; const &#123; visible, ...props &#125; = this.props; if (visible === false) return null; return &lt;WrappedComponent &#123;...props&#125; /&gt;; &#125; &#125;&#125; 我们只使用visible属性来控制组件的显示可隐藏，把其他props透传下去。约定-displayName在使用React Developer Tools进行调试时，如果我们使用了HOC，调试界面可能变得非常难以阅读，如下面的代码： javascript123456789101112@visibleclass Show extends Component &#123; render() &#123; return &lt;h1&gt;我是一个标签&lt;/h1&gt; &#125;&#125;@visibleclass Title extends Component &#123; render() &#123; return &lt;h1&gt;我是一个标题&lt;/h1&gt; &#125;&#125; 为了方便调试，我们可以手动为HOC指定一个displayName，官方推荐使用HOCName(WrappedComponentName)： javascript1static displayName = `Visible($&#123;WrappedComponent.displayName&#125;)` 这个约定帮助确保高阶组件最大程度的灵活性和可重用性。 使用HOC的动机回顾下上文提到的 Mixin 带来的风险： Mixin 可能会相互依赖，相互耦合，不利于代码维护 不同的Mixin中的方法可能会相互冲突 Mixin非常多时，组件是可以感知到的，甚至还要为其做相关处理，这样会给代码造成滚雪球式的复杂性 而HOC的出现可以解决这些问题： 高阶组件就是一个没有副作用的纯函数，各个高阶组件不会互相依赖耦合 高阶组件也有可能造成冲突，但我们可以在遵守约定的情况下避免这些行为 高阶组件并不关心数据使用的方式和原因，而被包裹的组件也不关心数据来自何处。高阶组件的增加不会为原组件增加负担 HOC的缺陷 HOC需要在原组件上进行包裹或者嵌套，如果大量使用HOC，将会产生非常多的嵌套，这让调试变得非常困难。 HOC可以劫持props，在不遵守约定的情况下也可能造成冲突。 HooksHooks是React v16.7.0-alpha中加入的新特性。它可以让你在class以外使用state和其他React特性。使用Hooks，你可以在将含有state的逻辑从组件中抽象出来，这将可以让这些逻辑容易被测试。同时，Hooks可以帮助你在不重写组件结构的情况下复用这些逻辑。所以，它也可以作为一种实现状态逻辑复用的方案。阅读下面的章节使用Hook的动机你可以发现，它可以同时解决Mixin和HOC带来的问题。 官方提供的HooksState Hook我们要使用class组件实现一个计数器功能，我们可能会这样写：javascript12345678910111213141516export default class Count extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125; &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; &#123; this.setState(&#123; count: this.state.count + 1 &#125;) &#125;&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 通过useState，我们使用函数式组件也能实现这样的功能：javascript1234567891011export default function HookTest() &#123; const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; &#123; setCount(count + 1); setNumber(number + 1); &#125;&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; useState是一个钩子，他可以为函数式组件增加一些状态，并且提供改变这些状态的函数，同时它接收一个参数，这个参数作为状态的默认值。 Effect HookEffect Hook 可以让你在函数组件中执行一些具有 side effect（副作用）的操作 参数useEffect方法接收传入两个参数： 回调函数：在第组件一次render和之后的每次update后运行，React保证在DOM已经更新完成之后才会运行回调。 状态依赖(数组)：当配置了状态依赖项后，只有检测到配置的状态变化时，才会调用回调函数。 javascript123456useEffect(() =&gt; &#123; // 只要组件render后就会执行&#125;);useEffect(() =&gt; &#123; // 只有count改变时才会执行&#125;,[count]); 回调返回值useEffect的第一个参数可以返回一个函数，当页面渲染了下一次更新的结果后，执行下一次useEffect之前，会调用这个函数。这个函数常常用来对上一次调用useEffect进行清理。javascript1234567891011121314151617export default function HookTest() &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; console.log('执行...', count); return () =&gt; &#123; console.log('清理...', count); &#125; &#125;, [count]); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; &#123; setCount(count + 1); setNumber(number + 1); &#125;&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; 执行上面的代码，并点击几次按钮，如果加上浏览器渲染的情况，结果应该是这样的： 页面渲染…1 执行… 1 页面渲染…2 清理… 1 执行… 2 页面渲染…3 清理… 2 执行… 3 页面渲染…4 清理… 3 执行… 4 那么为什么在浏览器渲染完后，再执行清理的方法还能找到上次的state呢？原因很简单，我们在useEffect中返回的是一个函数，这形成了一个闭包，这能保证我们上一次执行函数存储的变量不被销毁和污染。你可以尝试下面的代码可能更好理解javascript12345678910111213141516171819202122var flag = 1;var clean;function effect(flag) &#123; return function () &#123; console.log(flag); &#125;&#125;clean = effect(flag);flag = 2;clean();clean = effect(flag);flag = 3;clean();clean = effect(flag);// 执行结果effect... 1clean... 1effect... 2clean... 2effect... 3 模拟componentDidMountcomponentDidMount等价于useEffect的回调仅在页面初始化完成后执行一次，当useEffect的第二个参数传入一个空数组时可以实现这个效果。function useDidMount(callback) { useEffect(callback, []);}官方不推荐上面这种写法，因为这有可能导致一些错误。 模拟componentWillUnmountjavascript123function useUnMount(callback) &#123; useEffect(() =&gt; callback, []);&#125; 不像 componentDidMount 或者 componentDidUpdate，useEffect 中使用的 effect 并不会阻滞浏览器渲染页面。这让你的 app 看起来更加流畅。 ref Hook使用useRef Hook，你可以轻松的获取到dom的ref。javascript123456789101112export default function Input() &#123; const inputEl = useRef(null); const onButtonClick = () =&gt; &#123; inputEl.current.focus(); &#125;; return ( &lt;div&gt; &lt;input ref=&#123;inputEl&#125; type=\"text\" /&gt; &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;/button&gt; &lt;/div&gt; );&#125; 注意useRef()并不仅仅可以用来当作获取ref使用，使用useRef产生的ref的current属性是可变的，这意味着你可以用它来保存一个任意值。 模拟componentDidUpdatecomponentDidUpdate就相当于除去第一次调用的useEffect，我们可以借助useRef生成一个标识，来记录是否为第一次执行：javascript12345678910function useDidUpdate(callback, prop) &#123; const init = useRef(true); useEffect(() =&gt; &#123; if (init.current) &#123; init.current = false; &#125; else &#123; return callback(); &#125; &#125;, prop);&#125; 使用Hook的注意事项使用范围只能在React函数式组件或自定义Hook中使用Hook。Hook的提出主要就是为了解决class组件的一系列问题，所以我们能在class组件中使用它。 声明约束不要在循环，条件或嵌套函数中调用Hook。Hook通过数组实现的，每次useState 都会改变下标，React需要利用调用顺序来正确更新相应的状态，如果useState 被包裹循环或条件语句中，那每就可能会引起调用顺序的错乱，从而造成意想不到的错误。我们可以安装一个eslint插件来帮助我们避免这些问题。javascript12345678910111213// 安装npm install eslint-plugin-react-hooks --save-dev// 配置&#123; \"plugins\": [ // ... \"react-hooks\" ], \"rules\": &#123; // ... \"react-hooks/rules-of-hooks\": \"error\" &#125;&#125; 自定义Hook像上面介绍的HOC和mixin一样，我们同样可以通过自定义的Hook将组件中类似的状态逻辑抽取出来。自定义Hook非常简单，我们只需要定义一个函数，并且把相应需要的状态和effect封装进去，同时，Hook之间也是可以相互引用的。使用use开头命名自定义Hook，这样可以方便eslint进行检查。下面我们看几个具体的Hook封装： 日志打点我们可以使用上面封装的生命周期Hook。javascript12345678910111213141516const useLogger = (componentName, ...params) =&gt; &#123; useDidMount(() =&gt; &#123; console.log(`$&#123;componentName&#125;初始化`, ...params); &#125;); useUnMount(() =&gt; &#123; console.log(`$&#123;componentName&#125;卸载`, ...params); &#125;) useDidUpdate(() =&gt; &#123; console.log(`$&#123;componentName&#125;更新`, ...params); &#125;);&#125;;function Page1(props)&#123; useLogger('Page1',props); return (&lt;div&gt;...&lt;/div&gt;)&#125; 修改title根据不同的页面名称修改页面title:javascript12345678910111213function useTitle(title) &#123; useEffect( () =&gt; &#123; document.title = title; return () =&gt; (document.title = \"主页\"); &#125;, [title] );&#125;function Page1(props)&#123; useTitle('Page1'); return (&lt;div&gt;...&lt;/div&gt;)&#125; 双向绑定我们将表单onChange的逻辑抽取出来封装成一个Hook，这样所有需要进行双向绑定的表单组件都可以进行复用：javascript1234567891011121314function useBind(init) &#123; let [value, setValue] = useState(init); let onChange = useCallback(function(event) &#123; setValue(event.currentTarget.value); &#125;, []); return &#123; value, onChange &#125;;&#125;function Page1(props)&#123; let value = useBind(''); return &lt;input &#123;...value&#125; /&gt;;&#125; 当然，你可以向上面的HOC那样，结合context和form来封装一个更通用的双向绑定，有兴趣可以手动实现一下。 使用Hook的动机减少状态逻辑复用的风险Hook和Mixin在用法上有一定的相似之处，但是Mixin引入的逻辑和状态是可以相互覆盖的，而多个Hook之间互不影响，这让我们不需要在把一部分精力放在防止避免逻辑复用的冲突上。在不遵守约定的情况下使用HOC也有可能带来一定冲突，比如props覆盖等等，使用Hook则可以避免这些问题。 避免地狱式嵌套大量使用HOC的情况下让我们的代码变得嵌套层级非常深，使用Hook，我们可以实现扁平式的状态逻辑复用，而避免了大量的组件嵌套。 让组件更容易理解在使用class组件构建我们的程序时，他们各自拥有自己的状态，业务逻辑的复杂使这些组件变得越来越庞大，各个生命周期中会调用越来越多的逻辑，越来越难以维护。使用Hook，可以让你更大限度的将公用逻辑抽离，将一个组件分割成更小的函数，而不是强制基于生命周期方法进行分割。 使用函数代替class相比函数，编写一个class可能需要掌握更多的知识，需要注意的点也越多，比如this指向、绑定事件等等。另外，计算机理解一个函数比理解一个class更快。Hooks让你可以在classes之外使用更多React的新特性。","categories":[{"name":"React","slug":"React","permalink":"/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"/tags/React/"},{"name":"Hooks","slug":"Hooks","permalink":"/tags/Hooks/"},{"name":"HOC","slug":"HOC","permalink":"/tags/HOC/"},{"name":"Mixin","slug":"Mixin","permalink":"/tags/Mixin/"}],"keywords":[{"name":"React","slug":"React","permalink":"/categories/React/"}]},{"title":"破解各音乐App的vip限制","slug":"破解各音乐App需要vip限制","date":"2020-02-15T05:13:03.000Z","updated":"2020-02-16T04:12:01.353Z","comments":true,"path":"2020/02/15/破解各音乐App需要vip限制/","link":"","permalink":"/2020/02/15/破解各音乐App需要vip限制/","excerpt":"","text":"众所周知，目前各大音乐App都存在版权，因此经常遇到一种尴尬的情况，平时习惯用QQ音乐，但是部分歌曲QQ音乐没有或者是需要开会员，对于重度强迫症(还不是因为穷)的我是没法接受的，因此今天带来一种跨平台的免vip听所有歌曲的办法 原理网易云音乐提供了音乐云盘的功能，可以上传本地的音乐，同时可以在pc、移动端同步，那么解决办法就有了 操作步骤寻找喜欢的音乐在这里推荐一个名为 超高无损音乐 的网站，该网站收录了很多无损音质的歌曲，是以百度网盘链接的形式分享，在搜索框搜索自己喜欢的音乐，如图所示： 选择需要的格式，去网盘下载到本地备用 歌曲上传 首先下载网易云音乐pc客户端，安装，注册账号并登陆(为了能够多端同步音乐)，这里不赘述，操作很简单 找到左侧 “我的音乐云盘”，然后点击右侧的 “+ 上传音乐” 按钮选择本地下载好的音乐，上传 上传成功以后手机端就可以同步了，至此，喜欢什么歌下载下来上传就好，免vip，跨平台使用 安卓端进入客户端后屏幕右滑，可以看到云盘 ios端进入客户端后选择底部的 “我的”，找到左上角的云朵图标可以进入云盘","categories":[{"name":"破解","slug":"破解","permalink":"/categories/破解/"}],"tags":[{"name":"网易云音乐","slug":"网易云音乐","permalink":"/tags/网易云音乐/"},{"name":"vip破解","slug":"vip破解","permalink":"/tags/vip破解/"}],"keywords":[{"name":"破解","slug":"破解","permalink":"/categories/破解/"}]},{"title":"flutter打包--Android","slug":"flutter打包--Android","date":"2020-01-14T08:22:51.000Z","updated":"2020-02-15T12:29:48.510Z","comments":true,"path":"2020/01/14/flutter打包--Android/","link":"","permalink":"/2020/01/14/flutter打包--Android/","excerpt":"","text":"项目图片/android/app/src/main/res/ 目录下根据mipmap-为前缀文件夹存入相应dpi的png图片 配置APP名称、图标和系统权限在 /android/app/src/main/AndroidManifest.xml目录下 java12android:label=\"App名字\"android:icon=\"@mipmap/ic_launcher\" //此属性为APP图标用到的图片名称 APP注册将keytool所在路径添加到系统环境变量,默认是在 C:\\Program Files\\Android\\Android Studio\\jre\\bin 下面，然后将生成的key存储到e盘根目录 java1keytool -genkey -v -keystore e:/key.jks -keyalg RSA -keysize 2048 -validity 100000 -alias key 回车以后会让你输入对应的信息，其中密匙一定要记住，接下来到项目目录的android文件夹下创建一个名为key.properties的文件，并打开贴入以下代码： java1234storePassword=创建KEY时输入的密钥库密码keyPassword=创建KEY时输入的密钥密码 keyAlias=keystoreFile=e:/key.jks 配置key注册打开/android/app/build.gradle文件，在 android { 这一行前面，加入代码： java123defkeystorePropertiesFile=rootProject.file(\"key.properties\")defkeystoreProperties=newProperties()keystoreProperties.load(newFileInputStream(keystorePropertiesFile)) 把如下代码： java12345buildTypes &#123; release &#123; signingConfig signingConfigs.debug &#125;&#125; 替换成： java1234567891011121314signingConfigs &#123; release &#123; keyAlias keystoreProperties['keyAlias'] keyPassword keystoreProperties['keyPassword'] storeFile file(keystoreProperties['storeFile']) storePassword keystoreProperties['storePassword'] &#125;&#125;buildTypes &#123; release &#123; signingConfig signingConfigs.release &#125;&#125; 到defaultConfig中，录入APPID和版本号： java123456789101112131415defaultConfig &#123; // APPID applicationId \"com.example.myflutter\" // 可运行应用的最低版本的 Android 平台，由该平台的 API 级别标识符指定 minSdkVersion 16 // 指定运行应用的目标 API 级别。 // 在某些情况下，这允许应用使用在目标 API 级别中定义的清单元素或行为， // 而不是仅限于使用那些针对最低 API 级别定义的元素或行为。 targetSdkVersion 27 //内部版本号 versionCode 1 //对外公布的版本号 versionName \"1.0\" testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\" &#125; 编译生成apk文件在项目根目录终端中输入命令： bash1flutter build apk 安装到手机cmake1flutter install .","categories":[{"name":"Flutter","slug":"Flutter","permalink":"/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"/tags/Flutter/"},{"name":"Android","slug":"Android","permalink":"/tags/Android/"}],"keywords":[{"name":"Flutter","slug":"Flutter","permalink":"/categories/Flutter/"}]},{"title":"flutter状态管理之flutter_redux","slug":"flutter状态管理之flutter_redux","date":"2019-12-31T04:13:03.000Z","updated":"2020-02-15T11:58:37.598Z","comments":true,"path":"2019/12/31/flutter状态管理之flutter_redux/","link":"","permalink":"/2019/12/31/flutter状态管理之flutter_redux/","excerpt":"","text":"一、创建全局statedart12345678910111213141516171819202122// state.dartimport 'package:nicolas/redux/user/login_redux.dart';import 'package:nicolas/redux/user/user_redux.dart';import 'package:nicolas/redux/middleware/epic_middleware.dart'; // 在项目中引入epic_middleware中间件import 'package:redux/redux.dart';class GlobalState &#123; // 全局Redux对象，保存State数据 bool login; // 登陆状态 GlobalState(&#123;this.login&#125;);&#125;// 定义appReducer创建 store，通过 appReducer 将 GlobalState 内的login 和 对应的action 关联在一起GlobalState appReducer(GlobalState state, action) &#123; return GlobalState( login: loginReducer(state.login, action), );&#125;final List&lt;Middleware&lt;GlobalState&gt;&gt; middleware = [ EpicMiddleware&lt;GlobalState&gt;(LoginEpic()), LoginMiddleware(),]; 二、创建login的state管理dart123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import 'package:flutter/material.dart';import 'package:nicolas/redux/state.dart';import 'package:nicolas/redux/middleware/epic.dart';import 'package:nicolas/redux/middleware/epic_store.dart';import 'package:redux/redux.dart';final loginReducer = combineReducers&lt;bool&gt;([ TypedReducer&lt;bool, LoginSuccessAction&gt;(_loginResult), TypedReducer&lt;bool, LogoutAction&gt;(_logoutResult),]);bool _loginResult(bool result, LoginSuccessAction action) &#123; if (action.success == true) &#123; // 登陆成功以后.... &#125; return action.success;&#125;// LoginSuccessAction触发，就会调用到 _loginResult，它接受一个新的state，并返回class LoginSuccessAction &#123; final BuildContext context; final bool success; LoginSuccessAction(this.context, this.success);&#125;class LoginAction &#123; final BuildContext context; final String user; final String password; LoginAction(this.context, this.user, this.password);&#125;class LoginMiddleware implements MiddlewareClass&lt;GlobalState&gt; &#123; @override void call(Store&lt;GlobalState&gt; store, dynamic action, NextDispatcher next) &#123; if (action is LogoutAction) &#123; print('logout'); &#125; // Make sure to forward actions to the next middleware in the chain! next(action); &#125;&#125;class LoginEpic implements EpicClass&lt;GlobalState&gt; &#123; @override Stream&lt;dynamic&gt; call(Stream&lt;dynamic&gt; actions, EpicStore&lt;GlobalState&gt; store) &#123; return Observable(actions) .whereType&lt;LoginAction&gt;() .switchMap((action) =&gt; _loginIn(action, store)); &#125; Stream&lt;dynamic&gt; _loginIn( LoginAction action, EpicStore&lt;GlobalState&gt; store) async* &#123; var res = await UserDio.login( // 登陆请求 action.user.trim(), action.password.trim(), store); yield LoginSuccessAction(action.context, (res != null &amp;&amp; res.result)); // 登陆请求结果处理 &#125;&#125; 三、注册全局statedart123456789101112131415161718192021222324252627282930313233343536373839import 'dart:async';import 'package:flutter/material.dart';import 'package:nicolas/redux/state.dart';import 'package:nicolas/app.dart';import 'package:nicolas/page/user/login.dart';import 'package:flutter_redux/flutter_redux.dart';import 'package:nicolas/common/utils/navigator.dart';import 'package:fluttertoast/fluttertoast.dart';import 'package:redux/redux.dart';import 'common/event/index.dart';import 'package:nicolas/common/event/http_error_event.dart';import 'package:nicolas/common/http/code.dart';void main() =&gt; runApp(FlutterReduxApp());class FlutterReduxApp extends StatefulWidget &#123; @override _FlutterReduxAppState createState() =&gt; _FlutterReduxAppState();&#125;class _FlutterReduxAppState extends State&lt;FlutterReduxApp&gt; with HttpErrorListener &#123; final store = new Store&lt;GlobalState&gt;(appReducer, middleware: middleware, initialState: new GlobalState( // 初始化state数据 login: false, )); @override Widget build(BuildContext context) &#123; return new StoreProvider( store: store, // 挂载store child: new StoreBuilder&lt;GlobalState&gt;(builder: (context, store) &#123; return Text('xxxx); &#125;), ); &#125;&#125; 四、使用statedart12345678Container( child: new StoreConnector&lt;GlobalState, bool&gt;( converter: (store) =&gt; store.state.login, builder: (context, login) &#123; return Text(login.toString()); &#125;, ));","categories":[{"name":"Flutter","slug":"Flutter","permalink":"/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"/tags/Flutter/"},{"name":"跨平台","slug":"跨平台","permalink":"/tags/跨平台/"}],"keywords":[{"name":"Flutter","slug":"Flutter","permalink":"/categories/Flutter/"}]},{"title":"linux安装nginx","slug":"linux安装nginx","date":"2019-06-14T01:14:05.000Z","updated":"2020-04-14T12:19:18.231Z","comments":true,"path":"2019/06/14/linux安装nginx/","link":"","permalink":"/2019/06/14/linux安装nginx/","excerpt":"","text":"nginx安装常规安装vala123456789101112131415161718192021222324252627# 安装wgetyum install -y weget# 安装编译工具和相关的库文件 yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel# 下载PCRE（让nginx支持RUL地址的重定向功能）wget https://sourceforge.net/projects/pcre/files/pcre/8.41/pcre-8.41.tar.gz# 解压tar -xvzf pcre-8.41.tar.gz# 进入安装包目录cd pcre-8.41# 编译安装./configuremake &amp;&amp; make install# 下载安装 nginxwget http://nginx.org/download/nginx-1.14.0.tar.gz# 解压tar -xvzf nginx-1.14.0.tar.gz# 进入安装包目录：cd nginx-1.14.0# 编译安装：./configure --prefix=/usr/local/share/applications/nginx-1.14.0/ --with-http_ssl_modulemake &amp;&amp; make install# 查找nginx安装路径find / -name nginx# 制作nginx软链接,格式为：ln -s 目标路径 /usr/sbin/nginx# 找到带sbin的nginx路径，如：/usr/local/share/applications/nginx-1.14.0/sbin/nginxln -s /usr/local/share/applications/nginx-1.14.0/sbin/nginx /usr/sbin/nginx yum安装添加yum源root权限下添加nginx的yum源，此处以RHEL/CentOS为例，其他版本的linux参考这里properties1234# 安装yum-utilsyum install yum-utils# 添加nginx.repovi /etc/yum.repos.d/nginx.repo 内容如下：ini123456789101112131415[nginx-stable]name=nginx stable repobaseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=1enabled=1gpgkey=https://nginx.org/keys/nginx_signing.keymodule_hotfixes=true[nginx-mainline]name=nginx mainline repobaseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/gpgcheck=1enabled=0gpgkey=https://nginx.org/keys/nginx_signing.keymodule_hotfixes=true 安装nginxbash1yum -y install nginx 启动nginxangelscript123456789nginx# 如果没任何提示，则代表nginx启动成功了，查看nginx端口占用lsof -i:80# nginx 1410 root 6u IPv4 22898 0t0 TCP *:http (LISTEN)# nginx 2206 nginx 6u IPv4 22898 0t0 TCP *:http (LISTEN)# 开放80端口firewall-cmd --permanent --zone=public --add-port=80/tcp# 重载防火墙firewall-cmd --reload 修改nginx配置vim1234# 查找配置文件路径find / -name nginx.conf# 得到路径如：/etc/nginx/nginx.conf，接下来编辑vi /etc/nginx/nginx.conf 找到server部分nginx123456789101112131415server &#123; listen 80; #监听的端口 server_name baidu.com; # 需要绑定的域名 location / &#123; root /www/test; # 项目路径 index index.html index.htm; # 默认首页 &#125; # 反向代理 location /api/ &#123; # 将所有带api的请求代理到127.0.0.1:3000 proxy_set_header Host $host:$proxy_port; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:3000; # host:port的格式 &#125;&#125; 配置完毕以后esc然后:wq回车，reload一下confbash1nginx -s reload nginx常规操作vala1234567891011121314151617181920# 启动nginxnginx# 重新载入配置文件nginx -s reload # 重启 nginxnginx -s reopen # 停止 nginxnginx -s stop# 添加开机启动systemctl enable nginx.service# 查看nginx错误日志(最近100条)tail -100f /var/log/nginx/error.log# 查看nginx请求日志(最近100条)tail -100f /var/log/nginx/access.log","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"/tags/nginx/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}]},{"title":"ios背景音乐autoplay","slug":"ios背景音乐autoplay","date":"2019-06-01T04:26:29.000Z","updated":"2020-02-15T12:54:59.859Z","comments":true,"path":"2019/06/01/ios背景音乐autoplay/","link":"","permalink":"/2019/06/01/ios背景音乐autoplay/","excerpt":"","text":"前端页面audio无法自动播放这个在 IOS/Android 上面目前已经是个惯例，如果调用audio.play必须在事件里面响应，换句话说，用户还没有交互，不让调play。网上也有一种解决方案是引导用户触发事件，能解决autoplay的问题，但是局限性很大，如果要播放多个音乐也就凉凉，同时也有AudioContext解决方案，经过尝试还是没达到预期，个人在公司项目中有个需求是进页面播放背景音乐，同时，基于不同阶段，会播放各种音效，因为ios策略限制，找到如下解决方案，ps：项目是基于vue的 soundjs的引入soundjs是专门处理音频的一个js库，这里不做过多介绍，传送门 因为项目是基于vue的，但遗憾的是soundjs没有npm包，所以可以通过官网提供的cdn在项目入口index.html通过script引入javascript1&lt;script type=\"text/javascript\" src=\"https://code.createjs.com/1.0.0/createjs.min.js\"&gt;&lt;/script&gt; 打开soundjs源码javascript12this.createjs=this.createjs||&#123;&#125;...... 可以看到里面创建了一个叫createjs的对象，绑定在this上面，当然了，根据上下文来讲此时的this指代的是window而不是vue实例,因为我们是在入口index.html引入的，算是全局引用，因此我们要使用createjs只需要window.createjs即可。 绑定音乐列表首先我这里有一个音乐列表javascript123456789101112131415list: [ &#123; name: 'a', // 音频名字 src: '../../static/a.mp3' // 音频路径 &#125;, &#123; name: 'b', src: '../../static/b.mp3' &#125;, &#123; name: 'c', src: '../../static/c.mp3' &#125; ] 接下来需要将音乐列表绑定到createjs对象上 javascript12345for (let i = 0; i &lt; this.list.length; i++) &#123; window.createjs.source || (window.createjs.source = &#123;&#125;) // 添加source属性存储音乐信息 window.createjs.Sound.registerSound(this.list[i].src, this.list[i].name) // 绑定音乐信息到createjs实例 window.createjs.source[this.list[i].name] = window.createjs.Sound.createInstance(this.list[i].name) // 创建播实例，添加映射&#125; 音乐操作接下来创建三个操作音乐的方法 播放音乐javascript123456789playSound (e, t, f) &#123; let i = window.createjs.source[e] i.playState &amp;&amp; i.stop() i.play(t) f &amp;&amp; f())&#125;// e: 需要播放的音乐名字，这里和音乐list里面的nane字段对应// t: 播放模式，传入一个对象&#123;loop: -1&#125; ,-1代表无限循环，1代表仅播放一次// f: callback 暂停音乐javascript123pausedSound (e, f) &#123; window.createjs.source[e].paused = !window.createjs.source[e].paused, f &amp;&amp; f()&#125;, 停止播放javascript123stopSound (e, f) &#123; return e ? window.createjs.source[e].stop() : window.createjs.Sound.stop(), f &amp;&amp; f()&#125; 静音javascript123mutedSound () &#123; window.createjs.Sound.muted = !window.createjs.Sound.muted&#125;","categories":[{"name":"vue","slug":"vue","permalink":"/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"/tags/vue/"},{"name":"audio","slug":"audio","permalink":"/tags/audio/"}],"keywords":[{"name":"vue","slug":"vue","permalink":"/categories/vue/"}]},{"title":"vue-cli配置多入口","slug":"vue-cli配置多入口","date":"2019-04-23T03:21:55.000Z","updated":"2020-02-15T12:54:59.864Z","comments":true,"path":"2019/04/23/vue-cli配置多入口/","link":"","permalink":"/2019/04/23/vue-cli配置多入口/","excerpt":"","text":"因实际需要，在公司移动端项目上线后机组做pc版，此时，如果重新构建一个pc项目的话一来维护不便，二来很多公共资源可以重复利用，因此在原来移动端的基础上构建多入口，实现一个项目两个版本，甚至多个 一、目录结构分析 配置多入口其实就是将pc版和手机版共用一个cli，在src目录下创建一个entries目录，里面分别创建pc、mobile目录存放分别的入口文件，接下来，将index.html、main.js、App.vue移动到pc目录并改名，手机端复制pc改名 原目录结构css1234567891011121314151617181920212223242526272829├── README.md 项目介绍├── index.html 入口页面├── build 构建脚本目录│ ├── build-server.js 运行本地构建服务器，可以访问构建后的页面│ ├── build.js 生产环境构建脚本│ ├── dev-client.js 开发服务器热重载脚本，主要用来实现开发阶段的页面自动刷新│ ├── dev-server.js 运行本地开发服务器│ ├── utils.js 构建相关工具方法│ ├── webpack.base.conf.js wabpack基础配置│ ├── webpack.dev.conf.js wabpack开发环境配置│ └── webpack.prod.conf.js wabpack生产环境配置├── config 项目配置│ ├── dev.env.js 开发环境变量│ ├── index.js 项目配置文件│ ├── prod.env.js 生产环境变量│ └── test.env.js 测试环境变量├── package.json npm包配置文件，里面定义了项目的npm脚本，依赖包等信息├── src 源码目录 │ ├── main.js 入口js文件│ ├── app.vue 根组件│ ├── components 公共组件目录│ ├── assets 资源目录，这里的资源会被wabpack构建│ │ └── images│ │ └── logo.png│ ├── routes 前端路由│ │ └── index.js├── static 纯静态资源，不会被wabpack构建。└── test 测试文件目录（unit&amp;e2e） └── unit 单元测试 配置多入口目录css12345678910111213├── src│ ├── entries 新的入口目录│ │ │── pc pc版入口文目录│ │ │ ├──pc.js pc版入口js(以前的main.js)│ │ │ ├──pc.vue pc版入口vue(以前的App.vue)│ │ │ └──pc.html pc版入口html(以前的index.html) │ │ └── mobile 手机版入口文目录│ │ ├──mobile.js 手机版入口js(以前的main.js)│ │ ├──mobile.vue 手机版入口vue(以前的App.vue)│ │ └──mobile.html 手机版入口vue(以前的App.vue)│ └─── router │ ├──mobile.js 手机版路由│ └──pc.js pc版路由 二、入口文件修改以pc.vue为例，mobile同理pgsql123456789import Vue from 'vue'import Pc from './pc.vue'import router from '../.././router/pc.js'new Vue(&#123; el: '#app', router, components: &#123; Pc &#125;, template: '&lt;Pc/&gt;'&#125;) 三、修改utils配置文件打开/build/utils.js加入如下内容javascript1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var glob = require('glob')// 页面模板var HtmlWebpackPlugin = require('html-webpack-plugin')// 取得相应的页面路径，因为之前的配置，所以是src文件夹下的entries文件夹var PAGE_PATH = path.resolve(__dirname, '../src/entries') // 用于做相应的merge处理var merge = require('webpack-merge')//多入口配置// 通过glob模块读取page文件夹下的所有对应文件夹下的js后缀文件，如果该文件存在// 那么就作为入口处理exports.entries = function() &#123; var entryFiles = glob.sync(PAGE_PATH + '/*/*.js') // 寻找入口js（原main.js） var map = &#123;&#125; entryFiles.forEach((filePath) =&gt; &#123; var filename = filePath.substring(filePath.lastIndexOf('\\/') + 1, filePath.lastIndexOf('.')) map[filename] = filePath &#125;) return map&#125;//多页面输出配置// 与上面的多页面入口配置相同，读取page文件夹下的对应的html后缀文件，然后放入数组中exports.htmlPlugin = function() &#123; let entryHtml = glob.sync(PAGE_PATH + '/*/*.html') let arr = [] entryHtml.forEach((filePath) =&gt; &#123; let filename = filePath.substring(filePath.lastIndexOf('\\/') + 1, filePath.lastIndexOf('.')) let conf = &#123; // 模板来源 template: filePath, // 文件名称 filename: filename + '.html', // 页面模板需要加对应的js脚本，如果不加这行则每个页面都会引入所有的js脚本 chunks: ['manifest', 'vendor', filename], inject: true &#125; if (process.env.NODE_ENV === 'production') &#123; conf = merge(conf, &#123; minify: &#123; removeComments: true, collapseWhitespace: true, removeAttributeQuotes: true &#125;, chunksSortMode: 'dependency' &#125;) &#125; arr.push(new HtmlWebpackPlugin(conf)) &#125;) return arr&#125; 四、修改webpack.dev.conf打开/build/webpack.dev.conf.js做如下修改： 找到 plugins:数组，将如下内容注释或删除 css12345new HtmlWebpackPlugin(&#123; filename: 'index.html', template: 'index.html', inject: true&#125;), 在plugins数组上拼接上在utils.js内获取到的入口内容修改完成以后的plugins如下： haxe123456789101112131415161718192021222324plugins: [ new webpack.DefinePlugin(&#123; 'process.env': require('../config/dev.env') &#125;), new webpack.HotModuleReplacementPlugin(), new webpack.NamedModulesPlugin(), // HMR shows correct file names in console on update. new webpack.NoEmitOnErrorsPlugin(), // https://github.com/ampedandwired/html-webpack-plugin // 注释开始 // new HtmlWebpackPlugin(&#123; // filename: 'index.html', // template: 'index.html', // inject: true // &#125;), // 注释结束 // copy custom static assets new CopyWebpackPlugin([ &#123; from: path.resolve(__dirname, '../static'), to: config.dev.assetsSubDirectory, ignore: ['.*'] &#125; ]) ].concat(utils.htmlPlugin()) // 这里是添加的部分 修改webpack.prod.conf打开/build/webpack.prod.conf做如下修改： 找到 plugins:数组，将如下内容注释或删除 yaml12345678910111213141516new HtmlWebpackPlugin(&#123; filename: process.env.NODE_ENV === 'testing' ? 'index.html' : config.build.index, template: 'index.html', inject: true, minify: &#123; removeComments: true, collapseWhitespace: true, removeAttributeQuotes: false // more options: // https://github.com/kangax/html-minifier#options-quick-reference &#125;, // necessary to consistently work with multiple chunks via CommonsChunkPlugin chunksSortMode: 'dependency'&#125;), 在plugins数组上拼接上在utils.js内获取到的入口内容 (操作同上一步) 五、添加客户端判断客户端访问项目时，通过js判断展示哪个版本在pc版本入口pc.html文件内添加如下jssmalltalk123if (/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) &#123; window.location.href = '/mobile.html#/'&#125; 同理，在mobile.html添加如下jssmalltalk123if (!/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) &#123; window.location.href = '/pc.html#/'&#125; 六、后续说明以上步骤操作完成以后便成功的添加了多入口，但是有几点需要注意： 本地运行调试的时候，以前我们是localhost:8080就可以访问了，但是现在我们需要 localhost:8080/pc.html或者localhost:8080/mobile.html 项目通过webpack打包以后会在根目录生成mobile.html和pc.html,在项目部署的时候需要配置默首页，也就是指定是mobile.html或者pc.html","categories":[{"name":"vue","slug":"vue","permalink":"/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"/tags/vue/"}],"keywords":[{"name":"vue","slug":"vue","permalink":"/categories/vue/"}]},{"title":"Hexo+Github搭建个人博客","slug":"Hexo+Github搭建个人博客","date":"2018-12-07T04:13:03.000Z","updated":"2020-02-15T12:54:59.856Z","comments":true,"path":"2018/12/07/Hexo+Github搭建个人博客/","link":"","permalink":"/2018/12/07/Hexo+Github搭建个人博客/","excerpt":"","text":"欢迎来到我的博客驿站，本站是使用Hexo+Github基于基于Node.js的静态博客框架, 官方文档请参考Hexo 安装Node及环境配置Node官网你可以根据不同平台系统选择你需要的Node.js安装包，安装过程很简单，下一步下一步就ok注意：Linux上安装Node.js需要安装Python，建议安装Python 3.6以上版本。 安装Hexo脚手架在安装了node之后，我们就可以使用node的包管理器npm安装hexo了，操作如下bash1npm install hexo-cli -g git相关配置本地搭建好博客项目之后需要提交到github上去.首先去GitHub申请个人账号，以便后期用来做博客的远程创库、域名、服务器之类的，github账号不再啰嗦了,跟一般的注册账号差不多 安装git打开git官网下载git，安装过程全程默认配置，下一步下一步安装 本地创建ssh key桌面右键git bash here，然后：excel1ssh-keygen -t rsa -C \"邮箱地址\" 之后会要求确认路径和输入密码，记住这个路径，我们这使用默认的一路回车就行。成功的话会在.ssh文件夹生成id_rsa.pub文件，用记事本打开，复制里面的内容，也就是我们需要的key github添加ssh key回到github页面上，点击头像右侧倒三角，选择Settings（账户配置），左边选择SSH Keys，点击右上角Add SSH Key,title随便填，下方文本框粘贴上一步上生成的key确定 ssh key本地验证回到刚才生成key的命令行，执行如下命令验证github用户名和邮箱bash12git config --global user.name \"你的用户名\"git config --global user.email \"你的邮箱\" 注意：执行这两条命令成功后没有任何提示 项目搭建接下来初始化Hexo项目，首先在需要保存项目的目录鼠标右键选择”git bash here”,然后： bash1hexo init blog blog为你博客的项目名称，接下来切换到博客路径bash1cd blog 安装项目依赖包cmake1npm install 至此，博客初始化完成，可以启动hexo服务了ebnf1hexo s 命令行提示：java12INFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 接下来可以在浏览器地址栏输入 http://localhost:4000 访问博客 主题更换 在主题网站查找自己喜欢的主题，找到以后点击进去预览，在博客预览页面找到博主的github链接 进入博主github首页，找到主题对应的仓库，点击右侧绿色”clone or download”按钮获取主题仓库地址 下载首先在命令行使用cd命令切换到themes目录，然后crmsh1git clone 主题地址 等待下载完毕以后会在themes文件夹内生成一个主题文件夹，接下来修改根目录_config.yml的theme选项为你刚才下载的主题名，接下来清除一下缓存ebnf1hexo clean 然后编译ebnf1hexo g 然后重启服务(在之前启动服务的命令行使用ctrl+c停止服务)，然后ebnf1hexo s 接下来在浏览器预览就可以看到新主题的效果了 托管到gitHub创建博客托管仓库创建一个与自己用户名同名的repository，在自己Github页面，点击头像左侧+按钮，选择new repository，比如我的Github账号是Givingcode，那么我应该创建的repository名字应该是Givingcode.github.io 添加deploy配置首先在根目录_config.yml文件内配置gitbash1234deploy: type: git repository: git@github.com:用户名/用户名.github.io.git branch: master repository：就是你的gitHub同名仓库的地址 代码托管安装 hexo-deployer-git依赖包sql1npm install hexo-deployer-git --save 然后使用如下命令 bash1hexo d 此时，你就可以在浏览器地址栏输入 “用户名.github.io”来访问你的个人博客(用户名：你gitHub的用户名) 域名绑定域名解析域名申请的途径非常多，建议使用阿里云的，方便后期备案，在阿里云购买了域名之后，到域名管理中心进行域名解析，添加以下几条记录值： 记录类型 主机记录 解析线路(isp) 记录值 CNAME www 默认 用户名.github.io A @ 默认 192.30.252.153 A @ 默认 192.30.252.154 创建域名关联文件在项目根目录source目录新建名为CNAME的文件，（注意：该文件没有后缀名）然后在CNAME文件里面填写你的域名，如：xxx.com 注意：不带www也不带http，只需要域名就好 接下来重新编译推送一下bash12hexo g # 编译hexo d # 推送 提示：INFO Deploy done: git 之后就可以使用域名访问你的个人博客了","categories":[{"name":"Hexo","slug":"Hexo","permalink":"/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"/tags/Hexo/"}],"keywords":[{"name":"Hexo","slug":"Hexo","permalink":"/categories/Hexo/"}]},{"title":"Adobe PhotoShop CC激活破解","slug":"Adobe PhotoShop CC激活破解","date":"2018-10-29T05:13:03.000Z","updated":"2020-02-15T13:26:27.270Z","comments":true,"path":"2018/10/29/Adobe PhotoShop CC激活破解/","link":"","permalink":"/2018/10/29/Adobe PhotoShop CC激活破解/","excerpt":"","text":"工具下载在我的百度网盘提取码：ajif下载压缩包,解压,展开Adobe Photoshop CC 2017-18.0(64 bit)，得到如下文件： 安装ps 首先断开计算机网络(禁用电脑网络或者拔网线或者断wifi) 双击Set-up.exe,得到如下界面，等待进度条跑完，预计3分钟左右 安装结束后会在开始菜单生成如下2个快捷方式 点击蓝色ps按钮运行，选择以后登录 选择开始使用 接受 接下来会打开ps界面，等待10s左右等它加载完所有组件，关闭ps软件 破解激活 双击打开激活工具 在下拉列表选择Adobe Photoshop cc2015.5 点击install选择amtlib.dll文件默认在C:\\Program Files\\Adobe\\Adobe Photoshop CC 2017文件夹下 点击Advaced按钮，然后关闭5、激活破解完成，重新连接电脑网络，就可以正常使用ps了","categories":[{"name":"破解","slug":"破解","permalink":"/categories/破解/"}],"tags":[{"name":"PhotoShop","slug":"PhotoShop","permalink":"/tags/PhotoShop/"},{"name":"激活破解","slug":"激活破解","permalink":"/tags/激活破解/"}],"keywords":[{"name":"破解","slug":"破解","permalink":"/categories/破解/"}]},{"title":"vue实现拖拽","slug":"vue实现拖拽","date":"2018-10-21T09:21:43.000Z","updated":"2020-02-15T12:54:59.858Z","comments":true,"path":"2018/10/21/vue实现拖拽/","link":"","permalink":"/2018/10/21/vue实现拖拽/","excerpt":"","text":"html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;template&gt; &lt;div class=\"sidebar\"&gt; &lt;div class=\"slideContent\" :style=\"&#123;left: left + 'px', top: top + 'px'&#125;\"&gt; &lt;div class=\"move\" @mousedown=\"move($event)\"&gt; &lt;i class=\"el-icon-rank\"/&gt; &lt;/div&gt; &lt;div class=\"content\"&gt;....&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: \"index\", data() &#123; return &#123; left: window.innerWidth - 445, top: window.innerHeight - 640, &#125; &#125;, methods: &#123; move(e) &#123; const t = window.innerWidth - 375, a = window.innerHeight - 605 const i = document.getElementsByClassName(\"slideContent\")[0] const n = e.clientX - i.offsetLeft const s = e.clientY - i.offsetTop; return document.onmousemove = e =&gt; &#123; let r = e.clientX - n let o = e.clientY - s return r &lt;= 0 ? r = 0 : r &gt;= t &amp;&amp; (r = t), o &lt;= 20 ? o = 20 : o &gt;= a &amp;&amp; (o = a), i.style.left = r + \"px\", i.style.top = o + \"px\", !1 &#125;, document.onmouseup = () =&gt; &#123; document.onmousemove = null, document.onmouseup = null &#125;, document.onmouseleave = () =&gt; &#123; document.onmousemove = null, document.onmouseup = null &#125;, !1 &#125;, &#125; &#125;&lt;/script&gt;&lt;style lang=\"scss\" scoped&gt; .sidebar &#123; .slideContent &#123; position: fixed; background: rgb(239, 238, 244); width: 375px; height: 600px; right: 70px; top: 0px; z-index: 90; color: #fff; box-shadow: 0 5px 10px rgba(6, 6, 6, .3); .move &#123; cursor: move; user-select: none; position: relative; border-radius: 3px 3px 0 0; height: 20px; color: #333; background: linear-gradient(0deg, #bbb, #eee); width: 100%; line-height: 10px; display: block; padding: 5px 10px; i &#123; float: right; &#125; &#125; &#125; &#125;&lt;/style&gt;","categories":[{"name":"vue","slug":"vue","permalink":"/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"/tags/vue/"}],"keywords":[{"name":"vue","slug":"vue","permalink":"/categories/vue/"}]},{"title":"AWS创建EC2","slug":"AWS搭建EC2","date":"2018-10-11T08:13:03.000Z","updated":"2020-04-15T05:57:44.847Z","comments":true,"path":"2018/10/11/AWS搭建EC2/","link":"","permalink":"/2018/10/11/AWS搭建EC2/","excerpt":"","text":"切换pem为账号登陆 下载xxx.pem文件到本地 命令行cd到xxx.pem所在路径，使用pem登陆bash123456789101112131415161718192021ssh -i \"xxx.pem\" ec2-user@ec2-18-224-140-75.us-east-2.compute.amazonaws.com# 创建root密码sudo passwd root # 输入两次密码，期间没有任何提示# 切换到root身份su root# 编辑亚马逊主机的ssh登录方式 vi /etc/ssh/sshd_config # 把 PasswordAuthentication no 改为 PasswordAuthentication yes # ps: 如果没有则新插进去 # 重启sshd使修改生效service sshd restart# 修改root用户名(修改root登录用户名减少主机被暴力破解的风险)vi /etc/passwd# 修改第1行第1个root为新的用户名，esc然后:wq保存退出vi /etc/shadow# 修改第1行第1个root为新的用户名，esc然后:wq! 强制保存退出# 重启服务器reboot# 使用git bash或者xshell之类的ssh客户端通过用户名密码远程连接ssh 用户名@ip地址 搭建ftp服务器ps：这是单独搭建ftp服务器用于上传下载文件，但是一般不建议这么操作，容易被攻击，如果常用ssh客户端为xShell，那么可以使用xFtprouteros12345678910111213141516171819202122232425262728# 使用 yum 安装 vsftpdyum install -y vsftpd# 启动 VSFTPDservice vsftpd start# 查看端口netstat -nltp | grep 21# 配置 FTP 权限# 编辑 /etc/vsftpd/vsftpd.conf，找到下面两处配置并修改：# 禁用匿名用户 12 YES 改为NOanonymous_enable=NO# 禁止切换根目录 101 行 删除#chroot_local_user=YES# 重新启动 FTP 服务service vsftpd restart# 创建 FTP 用户（useradd 用户名）useradd web# 为用户 ftpuser 设置密码echo \"123456\" | passwd web --stdin# 限制用户 ftpuser只能通过 FTP 访问服务器，而不能直接登录服务器：usermod -s /sbin/nologin web# 为用户 ftpuser创建主目录并约定：# /data/ftp 为主目录, 该目录不可上传文件 # /data/ftp/pub 文件只能上传到该目录下mkdir -p /data/ftp/pub# 设置访问权限chmod a-w /data/ftp &amp;&amp; chmod 777 -R /data/ftp/pub# 设置为用户的主目录：usermod -d /data/ftp web 注意：记得关闭防火墙或者开放FTP默认端口(21) 关闭SELinux服务 angelscript1setenforce 0 关闭防火墙 ebnf1iptables -F 安装nodebash123456789101112131415161718192021# 下载node压缩包wget https://npm.taobao.org/mirrors/node/v10.6.0/node-v10.6.0-linux-x64.tar.xz# 解压tar -xvf node-v10.6.0-linux-x64.tar.xz# 更改node安装目录mv node-v10.6.0-linux-x64 /root/node# 配置全局环境变量 ln -s /root/node/bin/node /usr/sbin/nodeln -s /root/node/bin/npm /usr/sbin/npm# 安装守护程序forevernpm install forever -g# 查找forever的安装路径find / -name forerver# 我这里查到是在：/node/bin/，添加forever到PATHvi /etc/profile# 在结尾的地方添加记录export PATH=$PATH:/node/bin# 重建缓存source /etc/profile# forever启用node服务forever start xxx.js 安装ngnixbash123456789101112131415161718192021222324# 安装wgetyum install -y weget# 安装编译工具和相关的库文件 yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel# 下载PCRE（让Nginx支持RUL地址的重定向功能）wget https://sourceforge.net/projects/pcre/files/pcre/8.41/pcre-8.41.tar.gz# 解压tar -xvzf pcre-8.41.tar.gz# 进入安装包目录cd pcre-8.41# 编译安装./configuremake &amp;&amp; make install# 下载安装 Nginxwget http://nginx.org/download/nginx-1.14.0.tar.gz# 解压tar -xvzf nginx-1.14.0.tar.gz# 进入安装包目录：cd nginx-1.14.0# 编译安装：./configure --prefix=/usr/local/share/applications/nginx-1.14.0/ --with-http_ssl_modulemake &amp;&amp; make install# 启动Ngnix/usr/local/share/applications/nginx-1.14.0/sbin/nginx 接下来配置项目路径和域名 Code12345678910111213141516171819202122server &#123; listen 80; server_name aaa.com; location / &#123; root 项目路径1; index index.html index.htm; # 端口代理 proxy_pass http://127.0.0.1:3000; &#125;&#125;server &#123; listen 80; server_name bbb.com; location / &#123; root 项目路径2; index index.html index.htm; # 端口代理 proxy_pass http://127.0.0.1:4000; &#125;&#125; 配置完毕以后reload一下confbash1/usr/local/share/applications/nginx-1.14.0/sbin/nginx -s reload Ngnix常规操作dts1234567891011# 启动nginx/usr/local/share/applications/nginx-1.14.0/sbin/nginx # 重新载入配置文件/usr/local/share/applications/nginx-1.14.0/sbin/nginx -s reload # 重启 Nginx/usr/local/share/applications/nginx-1.14.0/sbin/nginx -s reopen # 停止 Nginx/usr/local/share/applications/nginx-1.14.0/sbin/nginx -s stop Ngnix常规选项 配置文件路径/usr/local/share/applications/nginx-1.14.0/conf默认项目目录/nginx-1.14.0/html 安装mysqlbash12345678910111213141516171819202122232425262728293031# 查看是否有自带的MySql库，如果先有卸载rpm -qa | grep mysql# 删除mysql-lib(系统自带的版本过低)yum remove mysql-libs# 下载mysqlwget https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.12-1.el6.x86_64.rpm-bundle.tar # 解压tar -xvf mysql-5.7.12-1.el6.x86_64.rpm-bundle.tar # 依次安装mysql包（common、libs、client、server）rpm -ivh mysql-community-common-5.7.12-1.el6.x86_64.rpmrpm -ivh mysql-community-libs-5.7.12-1.el6.x86_64.rpmrpm -ivh mysql-community-client-5.7.12-1.el6.x86_64.rpm rpm -ivh mysql-community-server-5.7.12-1.el6.x86_64.rpm # 启动mysql服务service mysqld start# 查看默认密码grep 'password' /var/log/mysqld.log# [Note] A temporary password is generated for root@localhost: x2sX3Gb6+Dtm# root@localhost: 这里后面就是默认密码# 登陆mysql -uroot -p# 修改默认密码SET PASSWORD = PASSWORD('Abcd1234.');# ps：这里需要大小写数组字符相结合，不然会通不过# 刷新系统权限flush privileges;# 开启远程登录权限GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'Abcd1234.' WITH GRANT OPTION;# 刷新系统权限flush privileges;# 接下来就可以远程登陆了 安装阿帕奇bash1234# 安装阿帕奇yum install httpd -y# 开启服务systemctl start httpd 添加阿帕奇工作空间修改/etc/httpd/conf/httpd.conf配置文件指定阿帕奇workspace为/var/www/html修改前apache1234&lt;Directory&gt; AllowOverride none Require all denied&lt;/Directory&gt; 修改后lasso1234&lt;Directory \"/var/www/html\"&gt; AllowOverride none Require all denied&lt;/Directory&gt; 启动服务 crmsh1systemctl start httpd 域名绑定在/etc/httpd/conf目录下创建default.conf添加如下内容 apache1234&lt;VirtualHost *:80&gt; DocumentRoot \"/var/www/html\" ServerName www.lidg.vip&lt;VirtualHost&gt; DocumentRoot:工作空间ServerName：域名 搭建vpn 安装wget bash1yum -y install wget 安装setuptools vim123456789wget --no-check-certificate https://pypi.python.org/packages/source/s/setuptools/setuptools-19.6.tar.gz#md5=c607dd118eae682c44ed146367a17e26 tar -zxvf setuptools-19.6.tar.gz cd setuptools-19.6 python setup.py build python setup.py install 下载pip安装包，解压到某个位置，我这里下载的是18.1版本，然后就可以安装了 bash123456789wget --no-check-certificate https://pypi.python.org/packages/source/p/pip/pip-8.0.2.tar.gz#md5=3a73c4188f8dbad6a1e6f6d44d117eeb tar -zxvf pip-8.0.2.tar.gz cd pip-8.0.2 python setup.py build python setup.py install 安装shadowsocks cmake1pip install shadowsocks 添加shadowsocks配置文件 jboss-cli123mkdir /etc/shadowsocks/cd /etc/shadowsocks/vi config.json 粘贴如下内容：json123456789&#123; \"server\":\"0.0.0.0\", \"server_port\":8388, \"local_port\":1080, \"password\":\"把这段汉字替换为你的vpn连接密码\", \"timeout\":600, \"method\":\"aes-256-cfb\", \"fast_open\":false&#125; 启动服务pgsql1ssserver -c /etc/shadowsocks/config.json -d start","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"/tags/Linux/"},{"name":"EC2","slug":"EC2","permalink":"/tags/EC2/"},{"name":"vpn","slug":"vpn","permalink":"/tags/vpn/"},{"name":"Nginx","slug":"Nginx","permalink":"/tags/Nginx/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}]},{"title":"RedHat常规操作","slug":"RedHat常规操作","date":"2018-09-29T08:13:03.000Z","updated":"2020-02-15T11:58:37.598Z","comments":true,"path":"2018/09/29/RedHat常规操作/","link":"","permalink":"/2018/09/29/RedHat常规操作/","excerpt":"","text":"RedHat设置网络开机自动连接 切换到root账户 安装网络工具 cmake1yum install -y net-tools\\* 使用vim修改 /etc/sysconfig/network-scripts/ifcfg-enpxxxxxx文件ifcfg-enpxxxxxx文件为你的网卡名配置文件将文件最后一行的ONBOOT= no改为yes，保存即可。个别情况下，为了后期远程连接方便，我们可以做如下更改修改上边文件 ：BOOTPROTO=static同时文件的最后添加以下内容：IPADDR=176.202.123.234 #静态IPGATEWAY=176.202.123.1 #默认网关NETMASK=255.255.255.0 #子网掩码DNS1=176.202.0.227 #DNS 配置 ps：以上参数根据自己网段设置即可 设置完毕以后，重启网卡routeros1service network restart","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"/tags/Linux/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}]},{"title":"vue移动端屏幕适配解决方案new","slug":"vue移动端屏幕适配解决方案new","date":"2018-09-08T06:57:41.000Z","updated":"2020-02-15T12:54:59.857Z","comments":true,"path":"2018/09/08/vue移动端屏幕适配解决方案new/","link":"","permalink":"/2018/09/08/vue移动端屏幕适配解决方案new/","excerpt":"","text":"项目原地址参考这里 插件安装bash12345# 安装适配插件lib-flexiblenpm i lib-flexible -S# 安装px转rem插件npm i px2rem-loader -S 文件引入在vue的入口文件main.js内引入lib-flexiblebash1import 'lib-flexible/flexible.js' 添加meta标签在入口index.html内添加视口修饰metahtml1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; 配置utils在build/utils.js文件内：在cssLoaders里面添加px2remLoader方法用于将px转换为remjavascript123456const px2remLoader = &#123; loader: 'px2rem-loader', options: &#123; 'remUnit':75,'baseDpr':2 // 设计稿width为750，因此这里是75 &#125; &#125; 接下来将px2remLoader方法添加到generateLoaders的loaders数组内javascript1const loaders = [cssLoader, px2remLoader] 使用方法以上几个步骤配置完毕以后，重启服务，然后组件中写尺寸单位就可以直接写px，具体值直接按照设计稿来做就ok","categories":[{"name":"vue","slug":"vue","permalink":"/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"/tags/vue/"},{"name":"移动端","slug":"移动端","permalink":"/tags/移动端/"}],"keywords":[{"name":"vue","slug":"vue","permalink":"/categories/vue/"}]},{"title":"vue移动端屏幕适配","slug":"vue移动端屏幕适配","date":"2018-08-30T03:21:55.000Z","updated":"2020-02-15T12:54:59.855Z","comments":true,"path":"2018/08/30/vue移动端屏幕适配/","link":"","permalink":"/2018/08/30/vue移动端屏幕适配/","excerpt":"","text":"vue移动端屏幕适配,查看项目地址 效果预览bash1234567891011# 项目clonegit clone git@github.com:NicolasGui/flexible.git# 进入项目目录cd flexible# 安装依赖npm install# 启动服务 localhost:8080npm run dev 原理概述插件安装bash12345# 插件一：amfe-flexiblenpm install amfe-flexible --save# 插件二： node-sassnpm install amfe-flexible --save # 同时，在main.js文件内引入npm install sass-loader --save 编写js处理方法在utils目录下创建flex.js文件，内容如下：javascript123456789101112import Vue from 'vue'Vue.prototype.$setTitle = function (text) &#123; document.title = text&#125;Vue.prototype.$getPX = function (design, designWidth = 750) &#123; // 750为设计稿宽度 // 获取窗口尺寸 let width = document.documentElement.getBoundingClientRect().width // 计算缩放比例 let scale = width / designWidth // 获取实时尺寸 return design * scale&#125; 同时，在main.js文件内引入该js文件javascript12345678910111213import Vue from 'vue'import App from './App'import router from './router'import 'amfe-flexible'import './utils/flex'Vue.config.productionTip = falsenew Vue(&#123; el: '#app', router, components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;) 编写css处理方法在src目录创建styles目录，同时在该目录新增common.scss文件，内容如下：scss123456789101112131415161718192021222324252627282930313233343536body,div,ul,ol,dl,li,dt,dd,h1,h2,h3,h4,p,form,iframe,input,textarea,a,span,em,strong,img,html,nav,header,article,button,footer,var &#123; padding:0; margin:0;&#125;body &#123; font:12px/1.2rem \"Microsoft YaHei\",tahoma,arial,sans-serif;min-width:320px;position:relative; &#125;form,input &#123;background:none;border:none;&#125;ul,dl,ol &#123;list-style-type:none;&#125;h1, h2, h3, h4, h5 &#123; font:12px/1.2rem \"Microsoft YaHei\",arial,tahoma; &#125;a &#123; text-decoration:none; &#125;a:hover,a:focus &#123; outline:none; &#125;table &#123; border-collapse:collapse;border-spacing:0; &#125;img &#123; border:none; &#125;strong,b &#123; font-weight:normal; &#125;em,i,var &#123; font-style:normal; &#125;p &#123; text-indent:0; &#125;.clear &#123; clear:both;height:0;line-height:0;overflow:hidden;width:0; &#125;.clearfix:after &#123; clear:both;content:\".\";display:block;font-size:0;height:0;visibility:hidden; &#125; // 尺寸转换 @function px2rem($px, $base-font-size: 75px) &#123; /*设计稿宽度为750，因此此处为75*/ @if (unitless($px)) &#123; @return px2rem($px + 0px); &#125; @else if (unit($px) == rem) &#123; @return $px; &#125; @return ($px / $base-font-size) * 1rem; &#125; // 字体转换 @mixin font-dpr($font-size) &#123; font-size: $font-size; [data-dpr=\"2\"] &amp; &#123; font-size: $font-size * 2; &#125; [data-dpr=\"3\"] &amp; &#123; font-size: $font-size * 3; &#125; &#125; css内使用scss123456&lt;style scoped lang='scss'&gt; @import '../styles/common.scss'; .content&#123; width:px2rem(750); /*750为设计稿实际尺寸*/ font-size:px2rem(20) /*20为设计稿实际尺寸*/&lt;/style&gt; js内使用javascript12345678910111213141516171819export default &#123; name:'test', data() &#123; return &#123; w:0; &#125; &#125;, watch:&#123; getWidth() &#123; this.w=this.$getPX(500); &#125; &#125; &#125;, computed: &#123; fun() &#123; return (this.w/this.$getPX(500)*100).toFixed(2) + ''; &#125; &#125; &#125;","categories":[{"name":"vue","slug":"vue","permalink":"/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"/tags/vue/"},{"name":"移动端","slug":"移动端","permalink":"/tags/移动端/"}],"keywords":[{"name":"vue","slug":"vue","permalink":"/categories/vue/"}]},{"title":"MAC升级Python3.x","slug":"MAC升级Python3.x","date":"2018-02-05T07:02:29.000Z","updated":"2020-02-15T11:58:37.597Z","comments":true,"path":"2018/02/05/MAC升级Python3.x/","link":"","permalink":"/2018/02/05/MAC升级Python3.x/","excerpt":"","text":"简介mac自带Python为2.7，如何升级自带版本，其实这个问题网上争议比较大，有大神删除自带python重新安装的，但是个人建议保留自带Python，通过brew安装，开发测试两不误，操作如下： 查看Python版本首先python -V得到当前系统版本是2.7.10，然后通过brew安装，不知道brew的自行度娘 brew命令bash1brew install python3 之后的话呢可能报错subunit1234Error: An unexpected error occurred during the `brew link` stepThe formula built, but is not symlinked into /usr/localPermission denied - /usr/local/FrameworksError: Permission denied - /usr/local/Frameworks 解决办法查看了日志发现/usr/local/下没有路径/usr/local/Frameworks ，所以先创建一个目录，执行maxima1sudo mkdir /usr/local/Frameworks 然后修改一下权限elixir1sudo chown $(whoami):admin /usr/local/Frameworks 接下来再link一下armasm1brew link python3 提示angelscript1Linking /usr/local/Cellar/python3/3.6.3... 1 symlinks created 代表成功了，此时我们python -V发现结果还是2.7.10,啥原因呢？系统默认选择了自带的python，解决很简单，把常规python命令换成python3，比如：python3 -V","categories":[{"name":"mac","slug":"mac","permalink":"/categories/mac/"}],"tags":[{"name":"mac","slug":"mac","permalink":"/tags/mac/"},{"name":"Python","slug":"Python","permalink":"/tags/Python/"}],"keywords":[{"name":"mac","slug":"mac","permalink":"/categories/mac/"}]},{"title":"使用mac自带阿帕奇","slug":"使用mac自带阿帕奇","date":"2017-02-24T07:02:29.000Z","updated":"2020-02-15T12:54:59.861Z","comments":true,"path":"2017/02/24/使用mac自带阿帕奇/","link":"","permalink":"/2017/02/24/使用mac自带阿帕奇/","excerpt":"","text":"简介Apache对于前端程序员来说是必不可少的一款web服务器，Mac系统自身带了apache，可以直接用来搭建本地web服务器，配置过程相对比较简单，本文将做简要描述，开始吧 启动Apachemac是默认自动启动Apache的，判断mac是否启动了Apache很简单，浏览器地址栏输入http://127.0.0.1 回车即可，如果页面显示It works！证明ok，介绍几个常用命令： bash12345sudo apachectl start //开启apachesudo apachectl restart //重启apachesudo apachectl stop //关闭apache: php版本检查在新的Mac High Sierra中对php版本进行了升级，所以先确定你mac的php版本ebnf1php -v 如果提示PHP 7.1.7 (cli) (built: Jul 15 2017 18:08:09) ( NTS )，则代表php是7.x版本的 基本配置ps：在进行一下操作时候，先在终端执行sudo apachectl stop停止apache服务 更改work spaceApache在Windows下默认work space为htdocs，在mac下有所区别，路径为：/Library/WebServer/Documents因此我们需要把前端代码拷贝到该目录进行测试，但是该目录藏这么深在实际使用过程中显然是比较麻烦的，因此接下来我们通过修改阿帕奇主配置文件httpd.conf来指定work space，步骤如下：mac配置文件目录为：/etc ，默认是隐藏的，因此咱们在终端里面执行：open /etc/apache2/ 就可以打开Apache主目录，找到httpd.conf文件，使用文本编辑器打开该文件， 如果不想那么麻烦的话可以使用vi编辑，命令如下： bash1sudo vi /etc/apache2/httpd.conf 接下来按一下键盘上的i键，底部提示insert……便可以移动光标进行编辑了编辑以下内容，原本为：bash12DocumentRoot \"/Library/WebServer/Documents\"&lt;Directory \"/Library/WebServer/Documents\"&gt; 修改为自定义目录，比如我改成根目录的sites文件夹，那就是：bash12DocumentRoot \"/Users/用户名/Sites\"&lt;Directory \"/Users/用户名/Sites\"&gt; ps:用户名即你mac的用户名，比如我的用户名是nicolas，那改制后应该是：bash12DocumentRoot \"/Users/nicolas/Sites\"&lt;Directory \"/Users/nicolas/Sites\"&gt; 这样子的话我们就可以把Apache的work space更改到根路径下的sites了 更改默认端口跟更改默认工作空间一样的方式打开httpd.conf，找到Listen 80这一行，将80改为你需要的端口就好 显示文件目录Apache在没有index的情况下默认不会显示文件目录，可以通过修改httpd.conf实现文件列表的展示，方便调试操作如下：将httpd.conf里面Options FollowSymLinks Multiviews之后加上Indexes，修改之后为bash1Options FollowSymLinks Multiviews Indexes 添加php7的支持在里面找到apache1#LoadModule php7_module libexec/apache2/libphp7.so 删除前面的#，修改之后是smali1LoadModule php7_module libexec/apache2/libphp7.so 接下来修改修改servername（必要操作，否则会报错）apache12#ServerAdmin you@example.comServerName localhost 以上操作都完成以后，按下 esc ，输入 :wq 然后回车紧接着在终端sudo apachectl start即可","categories":[{"name":"mac","slug":"mac","permalink":"/categories/mac/"}],"tags":[{"name":"mac","slug":"mac","permalink":"/tags/mac/"},{"name":"Apache","slug":"Apache","permalink":"/tags/Apache/"}],"keywords":[{"name":"mac","slug":"mac","permalink":"/categories/mac/"}]}]}