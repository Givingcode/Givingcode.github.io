{"meta":{"title":"SpectreAlan's blog","subtitle":"划船不用桨，全靠浪","description":"如果第一次失败了，那这是1.0版本，请继续努力","author":"SpectreAlan","url":"http://www.htmler.cn"},"pages":[{"title":"分类","date":"2018-01-04T16:00:00.000Z","updated":"2020-02-15T11:58:37.599Z","comments":false,"path":"categories/index.html","permalink":"http://www.htmler.cn/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-01-04T16:00:00.000Z","updated":"2020-02-15T11:58:37.600Z","comments":false,"path":"tags/index.html","permalink":"http://www.htmler.cn/tags/index.html","excerpt":"","text":""},{"title":"那些年我到过的地方","date":"2018-09-30T09:25:30.000Z","updated":"2020-02-15T11:58:37.599Z","comments":false,"path":"gallery/index.html","permalink":"http://www.htmler.cn/gallery/index.html","excerpt":"","text":"Chengdu Cambodia Philippines"},{"title":"那些年我们听过的歌","date":"2020-02-15T08:27:52.000Z","updated":"2020-02-15T12:05:40.437Z","comments":false,"path":"music/index.html","permalink":"http://www.htmler.cn/music/index.html","excerpt":"","text":"var options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":3,\"mode\":\"random\",\"mutex\":true,\"theme\":\"#e6d0b2\",\"preload\":\"metadata\",\"listmaxheight\":\"513px\",\"music\":[{\"title\":\"Faded\",\"author\":\"Alan Walke\",\"url\":\"https://raw.githubusercontent.com/wiki/Givingcode/images/music/Faded.flac\",\"pic\":\"https://raw.githubusercontent.com/wiki/Givingcode/images/music/Alan Walke.png\",\"lrc\":\"https://raw.githubusercontent.com/wiki/Givingcode/images/music/Faded.lrc\"},{\"title\":\"真的爱你\",\"author\":\"Beyond\",\"url\":\"https://raw.githubusercontent.com/wiki/Givingcode/images/music/真的爱你.wav\",\"pic\":\"https://raw.githubusercontent.com/wiki/Givingcode/images/music/beyond.png\",\"lrc\":\"https://raw.githubusercontent.com/wiki/Givingcode/images/music/真的爱你.lrc\"},{\"title\":\"凉凉\",\"author\":\"冯提莫、杨宗纬\",\"url\":\"https://raw.githubusercontent.com/wiki/Givingcode/images/music/冯提莫、杨宗纬+-+凉凉.flac\",\"pic\":\"https://raw.githubusercontent.com/wiki/Givingcode/images/music/冯提莫.png\",\"lrc\":\"https://raw.githubusercontent.com/wiki/Givingcode/images/music/凉凉.lrc\"},{\"title\":\"阿刁\",\"author\":\"张韶涵\",\"url\":\"https://raw.githubusercontent.com/wiki/Givingcode/images/music/张韶涵 - 阿刁.flac\",\"pic\":\"https://raw.githubusercontent.com/wiki/Givingcode/images/music/张韶涵.png\",\"lrc\":\"https://raw.githubusercontent.com/wiki/Givingcode/images/music/阿刁.lrc\"},{\"title\":\"Sing Me to Sleep\",\"author\":\"Alan Walke\",\"url\":\"https://raw.githubusercontent.com/wiki/Givingcode/images/music/Sing Me to Sleep.flac\",\"pic\":\"https://raw.githubusercontent.com/wiki/Givingcode/images/music/Alan Walke.png\"},{\"title\":\"The Spectre\",\"author\":\"Alan Walke\",\"url\":\"https://raw.githubusercontent.com/wiki/Givingcode/images/music/The Spectre.flac\",\"pic\":\"https://raw.githubusercontent.com/wiki/Givingcode/images/music/Alan Walke.png\"},{\"title\":\"Tired\",\"author\":\"Alan Walke\",\"url\":\"https://raw.githubusercontent.com/wiki/Givingcode/images/music/Tired.flac\",\"pic\":\"https://raw.githubusercontent.com/wiki/Givingcode/images/music/Alan Walke.png\"}]}; options.element = document.getElementById(\"aplayer-POoBhBFa\"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);"}],"posts":[{"title":"java笔记","slug":"java","date":"2020-05-15T06:15:11.000Z","updated":"2020-05-18T13:16:20.164Z","comments":true,"path":"posts/7f1ae6d2.html","link":"","permalink":"http://www.htmler.cn/posts/7f1ae6d2.html","excerpt":"","text":"第一章 Java概述1.1 Java历史Java诞生于SUN（Stanford University Network），09年SUN被Oracle（甲骨文）收购。 Java之父是詹姆斯.高斯林(James Gosling)。 1996年发布JDK1.0版。 目前最新的版本是Java12。我们学习的Java8。 1.2 Java语言最主要的特点 特点一：面向对象 两个基本概念：类、对象 三大特性：封装、继承、多态 特点二：健壮性 吸收了C/C++语言的优点，但去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等），提供了一个相对安全的内存管理和访问机制 特点三：跨平台性 跨平台性：通过Java语言编写的应用程序在不同的系统平台上都可以运行。“Write once , Run Anywhere”一次编写，处处运行。 原理：只要在需要运行 java 应用程序的操作系统上，先安装一个Java虚拟机 (JVM Java Virtual Machine) 即可。由JVM来负责Java程序在该系统中的运行。因为有了JVM，同一个Java 程序在三个不同的操作系统中都可以执行。这样就实现了Java 程序的跨平台性。 1.3 Java环境搭建1.3.1 JDK、JRE、JVMJava开发人员需要安装JDK。如果仅仅是运行Java程序，那么只需要按照JRE。 JDK（Java Development kits）：Java开发工具包。 JRE（Java Runtime Environment）：Java运行环境。 JVM（Java Virtual Machine）：Java虚拟机。 JDK = JRE + 开发工具（javac.exe,java.exe,javadoc.exe等） JRE = JVM + 核心类库（常用类：String、日期时间、数学、集合、IO、网络、多线程等） 1.3.2 Java环境搭建1、安装JDK 2、配置JDK的开发工具目录到path环境变量中 ​ 例如：D:\\ProgramFiles\\Java\\jdk1.8.0_51\\bin; ​ 注意：这个安装目录以你自己的安装目录为准 （1）为什么配置path？ ​ 希望在命令行使用javac.exe等工具时，任意目录下都可以找到这个工具所在的目录。 （2）如何配置环境变量？ ​ 【计算机】右键【属性】，选择【高级系统设置】，选择【高级】，选择【环境变量】，选择【系统环境变量】，编辑path，在【path原有值】的前面加入D:\\ProgramFiles\\Java\\jdk1.8.0_51\\bin; 1.4 第一个Java应用程序java12345class HelloWorld&#123; public static void main(String[] args)&#123; System.out.print(\"Hello Java!\"); &#125;&#125; 1.4.1 Java程序的开发步骤三步： 1、编辑/编写源代码 要求：源文件必须是.java文件 2、编译 目的：把源文件编译为.class字节码文件（因为JVM只认识字节码） 工具：javac.exe 格式： cmd1javac 源文件名.java 3、运行 工具：java.exe 格式： cmd12java 类名java 字节码文件名 要求：可以被运行的类，必须包含main方法 1.4.2 Java程序的结构与格式结构： java12345类&#123; 方法&#123; 语句; &#125;&#125; 格式： （1）每一级缩进一个Tab键 （2）{}的左半部分在行尾，右半部分单独一行，与和它成对的”{“的行首对齐 1.4.3 Java程序的入口Java程序的入口是main方法 java123public static void main(String[] args)&#123; &#125; 1.4.4 Java注释1、单行注释 java1//注释内容 2、多行注释 java123/*注释内容*/ 3、文档注释 java123/**文档注释（后面注解部分讲解）*/ 1.5 编写Java程序时应该注意的问题1、字符编码问题 当cmd命令行窗口的字符编码与.java源文件的字符编码不一致，如何解决？ 解决方案一： ​ 在Notepad++等编辑器中，修改源文件的字符编码 解决方案二： ​ 在使用javac命令式，可以指定源文件的字符编码 cmd1javac -encoding utf-8 Review01.java 2、大小写问题 （1）源文件名： ​ 不区分大小写，我们建议大家还是区分 （2）字节码文件名与类名 ​ 区分大小写 （3）代码中 ​ 区分大小写 3、源文件名与类名一致问题？ （1）源文件名是否必须与类名一致？public呢？ 如果这个类不是public，那么源文件名可以和类名不一致。 如果这个类是public，那么要求源文件名必须与类名一致。 我们建议大家，不管是否是public，都与源文件名保持一致，而且一个源文件尽量只写一个类，目的是为了好维护。 （2）一个源文件中是否可以有多个类？public呢？ 一个源文件中可以有多个类，编译后会生成多个.class字节码文件。 但是一个源文件只能有一个public的类。 （3）main必须在public的类中吗？ 不是。 但是后面写代码时，基本上main习惯上都在public类中。 第二章 Java的基础语法2.1 标识符简单的说，凡是程序员自己命名的部分都可以称为标识符。 即给类、变量、方法、包等命名的字符序列，称为标识符。 1、标识符的命名规则 （1）Java的标识符只能使用26个英文字母大小写，0-9的数字，下划线_，美元符号$ （2）不能使用Java的关键字（包含保留字）和特殊值 （3）数字不能开头 （4）不能包含空格 （5）严格区分大小写 2、标识符的命名规范 （1）见名知意 （2）类名、接口名等：每个单词的首字母都大写，形式：XxxYyyZzz， 例如：HelloWorld，String，System等 （3）变量、方法名等：从第二个单词开始首字母大写，其余字母小写，形式：xxxYyyZzz， 例如：age,name,bookName,main （4）包名等：每一个单词都小写，单词之间使用点.分割，形式：xxx.yyy.zzz， 例如：java.lang （5）常量名等：每一个单词都大写，单词之间使用下划线_分割，形式：XXX_YYY_ZZZ， 例如：MAX_VALUE,PI 2.2 变量2.2.1 变量的概念变量的作用：用来存储数据，代表内存的一块存储区域，变量中的值是可以改变的。 2.2.2 变量的三要素1、数据类型 2、变量名 3、值 2.2.3 变量的使用应该注意什么？1、先声明后使用 如果没有声明，会报“找不到符号”错误 2、在使用之前必须初始化 如果没有初始化，会报“未初始化”错误 3、变量有作用域 如果超过作用域，也会报“找不到符号”错误 4、在同一个作用域中不能重名 2.2.4 变量的声明和赋值、使用的语法格式？1、变量的声明的语法格式： java1234567数据类型 变量名;例如：int age;String name;double weight;char gender;boolean isMarry; 2、变量的赋值的语法格式： java1234567变量名 = 值;例如：age = 18;name = \"柴林燕\"; //字符串的值必须用\"\"weight = 44.4;gender = '女';//单字符的值必须使用''isMarry = true; 3、变量的使用的语法格式： java123456789通过变量名直接引用例如：(1)输出变量的值System.out.print(name);System.out.print(\"姓名：\" + name);//\"\"中的内容会原样显示System.out.print(\"name = \" + name);(2)计算age = age + 1; 2.3 数据类型2.3.1 Java数据类型的分类1、基本数据类型 ​ 8种：整型系列（byte,short,int,long）、浮点型(float,double)、单字符型（char）、布尔型（boolean） 2、引用数据类型 ​ 类、接口、数组、枚举….. 2.3.2 Java的基本数据类型1、整型系列 （1）byte：字节类型 占内存：1个字节 存储范围：-128~127 （2）short：短整型类型 占内存：2个字节 存储范围：-32768~32767 （3）int：整型 占内存：4个字节 存储范围：-2的31次方 ~ 2的31次方-1 （4）long：整型 占内存：8个字节 存储范围：-2的63次方 ~ 2的63次方-1 注意：如果要表示某个常量数字它是long类型，那么需要在数字后面加L 2、浮点型系列（小数） （1）float：单精度浮点型 占内存：4个字节 精度：科学记数法的小数点后6~7位 注意：如果要表示某个常量数字是float类型，那么需要在数字后面加F或f （2）double：双精度浮点型 占内存：8个字节 精度：科学记数法的小数点后15~16位 3、单字符类型 char：字符类型 占内存：2个字节 Java中使用的字符集：Unicode编码集 字符的三种表示方式： （1）’一个字符’ 例如：’A’，’0’，’尚’ （2）转义字符 tex1234567\\n：换行\\r：回车\\t：Tab键\\\\：\\\\\"：”\\'：\\b：删除键Backspace （3）\\u字符的Unicode编码值的十六进制型 例如：\\u5c1a代表’尚’ 4、布尔类型 boolean：只能存储true或false 2.3.3 进制（了解，可以暂时忽略）1、进制的分类： （1）十进制 ​ 数字组成：0-9 ​ 进位规则：逢十进一 （2）二进制 ​ 数字组成：0-1 ​ 进位规则：逢二进一 （3）八进制 ​ 数字组成：0-7 ​ 进位规则：逢八进一 （4）十六进制 ​ 数字组成：0-9，a~f（或A~F） ​ 进位规则：逢十六进一 2、请分别用四种类型的进制来表示10，并输出它的结果：（了解） （1）十进制：正常表示 System.out.println(10); （2）二进制：0b或0B开头 System.out.println(0B10); （3）八进制：0开头 System.out.println(010); （4）十六进制：0x或0X开头 System.out.println(0X10); 3、为什么byte是-128~127？（理解） 1个字节：8位 0000 0001 ~ 0111 111 ==&gt; 1~127 1000 0001 ~ 1111 1111 ==&gt; -127 ~ -1 0000 0000 ==&gt;0 1000 0000 ==&gt; -128（特殊规定） 解释：计算机数据的存储（了解） 计算机数据的存储使用二进制补码形式存储，并且最高位是符号位，1是负数，0是正数。 规定：正数的补码与反码、原码一样，称为三码合一； ​ 负数的补码与反码、原码不一样： ​ 负数的原码：把十进制转为二进制，然后最高位设置为1 ​ 负数的反码：在原码的基础上，最高位不变，其余位取反（0变1,1变0） ​ 负数的补码：反码+1 例如：byte类型（1个字节，8位） 25 ==&gt; 原码 0001 1001 ==&gt; 反码 0001 1001 –&gt;补码 0001 1001 -25 ==&gt;原码 1001 1001 ==&gt; 反码1110 0110 ==&gt;补码 1110 0111 底层是用加法代替减法：-128==》-127-1==》-127+(-1) ​ -127- -1 ==&gt; -127 + 1 4、学生疑惑解答？ （1）为什么float（4个字节）比long（8个字节）的存储范围大？ （2）为什么double（8个字节）比float（4个字节）精度范围大？ 因为float、double底层也是二进制，先把小数转为二进制，然后把二进制表示为科学记数法，然后只保存： （1）符号位（2）指数位（3）尾数位 详见《float型和double型数据的存储方式.docx》 2.3.4 基本数据类型的转换1、自动类型转换 （1）当把存储范围小的值（常量值、变量的值、表达式计算的结果值）赋值给了存储范围大的变量时， byte-&gt;short-&gt;int-&gt;long-&gt;float-&gt;double ​ char-&gt; java12int i = 'A';//char自动升级为intdouble d = 10;//int自动升级为double （2）当存储范围小的数据类型与存储范围大的数据类型一起混合运算时，会按照其中最大的类型运算 java12345int i = 1;byte b = 1;double d = 1.0;double sum = i + b + d;//混合运算，升级为double （3）当byte,short,char数据类型进行算术运算时，按照int类型处理 java1234567byte b1 = 1;byte b2 = 2;byte b3 = (byte)(b1 + b2);//b1 + b2自动升级为intchar c1 = '0';char c2 = 'A';System.out.println(c1 + c2);//113 （4）boolean类型不参与 2、强制类型转换 （1）当把存储范围大的值（常量值、变量的值、表达式计算的结果值）赋值给了存储范围小的变量时，需要强制类型转换 double-&gt;float-&gt;long-&gt;int-&gt;short-&gt;byte ​ -&gt;char 提示：有风险，可能会损失精度或溢出 java12345double d = 1.2;int num = (int)d;//损失精度int i = 200;byte b = (byte)i;//溢出 （2）boolean类型不参与 （3）当某个值想要提升数据类型时，也可以使用强制类型转换 java123int i = 1;int j = 2;double shang = (double)i/j; 提示：这个情况的强制类型转换是没有风险的。 2.3.5 特殊的数据类型转换1、任意数据类型的数据与String类型进行“+”运算时，结果一定是String类型 java1System.out.println(\"\" + 1 + 2);//12 2、但是String类型不能通过强制类型()转换，转为其他的类型 java12String str = \"123\";int num = (int)str;//错误的 2.4 运算符1、按照操作数个数的分类： （1）一元运算符：操作数只有一个 例如：正号（+），负号（-），自增（++），自减（–），逻辑非（！），按位取反（~） （2）二元运算符：操作数有两个 例如：加（+），减（-），乘（*），除（/），模（%） ​ 大于（&gt;），小于（&lt;），大于等于（&gt;=），小于等于（&lt;=），等于（==），不等于（!=） ​ 赋值（=，+=，-=，*=，/=，%=，&gt;&gt;=，&lt;&lt;=。。。） ​ 逻辑与（&amp;），逻辑或（|），逻辑异或（^），短路与（&amp;&amp;），短路或（||） ​ 左移（&lt;&lt;），右移（&gt;&gt;），无符号右移（&gt;&gt;&gt;），按位与（&amp;），按位或（|），按位异或（^） （3）三元运算符：操作数三个 例如： ？ ： 2、Java基本数据类型的运算符： （1）算术运算符 （2）赋值运算符 （3）比较运算符 （4）逻辑运算符 （5）条件运算符 （6）位运算符（难） 2.4.1 算术运算符加法：+ 减法：- 乘法：* 除法：/ 注意：整数与整数相除，只保留整数部分 取模：% 取余 注意：取模结果的正负号只看被模数 正号：+ 负号：- 自增：++ 自减：– 原则：自增与自减 ++/–在前的，就先自增/自减，后取值 ++/–在后的，就先取值，后自增/自减 整个表达式的扫描，是从左往右扫描，如果后面的先计算的，那么前面的就暂时先放到“操作数栈”中 代码示例： java1234567891011121314151617181920212223242526272829303132int i = 1;i++;//i=2int j = 1;++j;//j=2int a = 1;int b = a++;//(1)先取a的值“1”放操作数栈(2)a再自增,a=2(3)再把操作数栈中的\"1\"赋值给b,b=1int m = 1;int n = ++m;//(1)m先自增,m=2(2)再取m的值“2”放操作数栈(3)再把操作数栈中的\"2\"赋值给n,n=1int i = 1;int j = i++ + ++i * i++;/*从左往右加载(1)先算i++①取i的值“1”放操作数栈②i再自增 i=2（2）再算++i①i先自增 i=3②再取i的值“3”放操作数栈（3）再算i++①取i的值“3”放操作数栈②i再自增 i=4（4）先算乘法用操作数栈中3 * 3 = 9，并把9压会操作数栈（5）再算求和用操作数栈中的 1 + 9 = 10（6）最后算赋值j = 10*/ 2.4.2 赋值运算符基本赋值运算符：= 扩展赋值运算符：+=，-=，*=，/=，%=… 注意：所有的赋值运算符的=左边一定是一个变量 扩展赋值运算符=右边的计算结果的类型如果比左边的大的话会强制类型转换，所以结果可能有风险。 扩展赋值运算符的计算：（1）赋值最后算（2）加载数据的顺序是把左边的变量的值先加载，再去与右边的表达式进行计算 java123456789101112131415161718int i = 1;int j = 5;j *= i++ + j++;//j = j *(i++ + j++);/*(1)先加载j的值“5”(2)在计算i++①先加载i的值“1”②再i自增，i=2(3)再计算j++①先加载j的值\"5\"②再j自增，j=6(4)算 加法i + 5 = 6(5)算乘法5 * 6 = 30(6)赋值j = 30*/ 2.4.3 比较运算符大于：&gt; 小于：&lt; 大于等于：&gt;= 小于等于：&lt;= 等于：== 注意区分赋值运算符的= 不等于：!= 注意：比较表达式的运算结果一定只有true/false 比较表达式可以作为（1）条件（2）逻辑运算符的操作数 2.4.4 逻辑运算符 逻辑运算符的操作数必须是布尔值，结果也是布尔值 逻辑与：&amp; 运算规则：只有左右两边都为true，结果才为true。 例如：true &amp; true 结果为true false &amp; true 结果为false true &amp; false 结果为false false &amp; false 结果为false逻辑或：| 运算规则：只要左右两边有一个为true，结果就为true。 例如：true | true 结果为true false | true 结果为true true | false 结果为true false | false 结果为false逻辑异或：^ 运算规则：只有左右两边不同，结果才为true。 例如：true ^ true 结果为false false ^ true 结果为true true ^ false 结果为true false ^ false 结果为false 逻辑非：! 运算规则：布尔值取反 例如：!true 为false !false 为true 短路与：&amp;&amp; 运算规则：只有左右两边都为true，结果才为true。 例如：true &amp; true 结果为true true &amp; false 结果为false false &amp; ? 结果就为false 它和逻辑与不同的是当&amp;&amp;左边为false时，右边就不看了。 短路或：|| 运算规则：只要左右两边有一个为true，结果就为true。 例如：true | ? 结果为treu false | true 结果为true false | false 结果为false 它和逻辑或不同的是当||左边为true时，右边就不看了。 开发中一般用短路与和短路或比较多 面试题：&amp;&amp; 和 &amp;的区别？ &amp;&amp;当左边为false，右边不计算 &amp;不管左边是true还是false，右边都要计算 2.4.5 条件运算符 ? : 语法格式： java1条件表达式 ? 结果表达式1 : 结果表达式2 运算规则： 整个表达式的结果：当条件表达式为true时，就取结果表达式1的值，否则就取结果表达式2的值 代码示例： java123456789（1）boolean类型boolean marry = true;System.out.println(marry? \"已婚\" : \"未婚\");（2）求最值int i = 3;int j = 5;int max = i&gt;=j ? i : j;//当i&gt;=j时，max就赋值为i的值，否则就赋值为j的值 2.4.6 位运算符左移：&lt;&lt; ​ 运算规则：左移几位就相当于乘以2的几次方 右移：&gt;&gt; ​ 运算规则：右移几位就相当于除以2的几次方 无符号右移：&gt;&gt;&gt; ​ 运算规则：往右移动后，左边空出来的位直接补0，不看符号位 按位与：&amp; ​ 运算规则： ​ 1 &amp; 1 结果为1 ​ 1 &amp; 0 结果为0 ​ 0 &amp; 1 结果为0 ​ 0 &amp; 0 结果为0 按位或：| ​ 运算规则： ​ 1 | 1 结果为1 ​ 1 | 0 结果为1 ​ 0 | 1 结果为1 ​ 0 &amp; 0 结果为0 按位异或：^ ​ 运算规则： ​ 1 ^ 1 结果为0 ​ 1 ^ 0 结果为1 ​ 0 ^ 1 结果为1 ​ 0 ^ 0 结果为0 按位取反：~ ​ 运算规则：~0就是1 ​ ~1就是0 如何区分&amp;,|,^是逻辑运算符还是位运算符？ 如果操作数是boolean类型，就是逻辑运算符，如果操作数是整数，那么就位运算符。 2.4.7 运算符优先级 提示说明： （1）表达式不要太复杂 （2）先算的使用() 2.4.8 运算符操作数类型说明1、算术运算符 数字和单个字符可以使用算术运算符。 其中+，当用于字符串时，表示拼接。 2、赋值运算符 右边的常量值、表达式的值、变量的值的类型必须与左边的变量一致或兼容（可以实现自动类型转换）或使用强制类型转换可以成功。 3、比较运算符 其他的比较运算符都是只能用于8种基本数据类型。 其中的==和!=可以用于引用数据类型的比较，用于比较对象的地址。（后面讲） java1234567int i = 10;int j = 10;System.out.println(i==j);//truechar c1 = '帅';char c2 = '帅';System.out.println(c1 == c2);//true 4、逻辑运算符 逻辑运算符的操作数必须是boolean值 5、条件运算符 ?前面必须是条件，必须是boolean值 结果表达式1和结果表达式2要保持类型一致或兼容 6、位运算符 一般用于整数系列 以上运算符都是针对基本数据类型设计的。 能够用于引用数据类型只有基本的赋值运算符=，和比较运算符中的==和!=。其他运算符都不能用于引用数据类型。 其中字符串类型还有一个+，表示拼接。 第三章 流程控制语句结构流程控制语句结构分为： 1、顺序结构：从上到下依次执行 2、分支结构：多个分支选择其中一个分支执行 3、循环结构：重复执行某些代码 3.1 顺序结构执行过程：从上到下顺序执行 3.1.1 输出语句1、System.out.print(输出内容); #输出内容后不换行 2、System.out.println(输出内容); #输出内容后换行 java12345678910111213141516171819202122232425#输出常量System.out.print(1);System.out.print('尚');System.out.print(44.4);System.out.print(true);System.out.print(\"尚硅谷\");#输出变量int a = 1;char c = '尚';double d = 44.4;boolean b = true;String school = \"尚硅谷\";System.out.print(a);System.out.print(c);System.out.print(d);System.out.print(b);System.out.print(school);#输出拼接结果System.out.print(\"a = \" + a);System.out.print(\"c = \" + c);System.out.print(\"d = \" + d);System.out.print(\"b = \" + b);System.out.print(\"school = \" + school); 3.1.2 输入语句键盘输入代码的三个步骤： 1、准备Scanner类型的变量 2、提示输入xx 3、接收输入内容 示例代码： java12345678910111213141516//1、准备Scanner类型的变量java.util.Scanner input = new java.util.Scanner(System.in);//System.in默认代表键盘输入//2、提示输入xxSystem.out.print(\"请输入一个整数：\");//3、接收输入内容int num = input.nextInt();//列出各种数据类型的输入int num = input.nextInt();long bigNum = input.nextLong();double d = input.nextDouble();boolean b = input.nextBoolean();String s = input.next();char c = input.next().charAt(0);//先按照字符串接收，然后再取字符串的第一个字符（下标为0） 3.2 分支结构分支结构：根据条件选择性的执行某些代码 分为： 1、条件判断：if…else系列 2、选择结构：switch…case系列 3.2.1 条件判断1、单分支结构语法格式： java123if(条件表达式)&#123; 当条件表达式成立(true)时需要执行的语句块;&#125; 执行过程： ​ 条件成立，就执行{}其中的语句块，不成立就不执行。 注意： （1）if(条件表达式)中的条件表达式的结果必须是boolean类型 （2）当{}中的语句只有一个语句（简单的语句，也可以是一个复合语句）时，可以省略{}，但是我们不建议省略 java1234567891011121314//省略&#123;&#125;的情况if(score&lt;0 || score&gt;100) System.out.println(\"输入有误！\");//简单的语句else //复合语句 if(score==100)&#123; System.out.println(\"满分\"); &#125;else if(score&gt;=80)&#123; System.out.println(\"优秀\"); &#125;else if(score&gt;=60)&#123; System.out.println(\"及格\"); &#125;else&#123; System.out.println(\"不及格\"); &#125; 示例代码： java12345int year = 2019;int days = 28;if(year%4==0 &amp;&amp; year%100!=0 || year%400==0)&#123; days= 29;&#125; 2、双分支结构语法格式： java12345if(条件表达式)&#123; 当条件表达式成立(true)时需要执行的语句块1;&#125;else&#123; 当条件表达式不成立(false)时需要执行的语句块2;&#125; 执行过程： ​ 当条件表达式成立(true)时执行语句块1，否则执行语句块2 注意： （1）if(条件表达式)中的条件表达式的结果必须是boolean类型 （2）当{}中的语句只有一个语句（简单的语句，也可以是一个复合语句）时，可以省略{}，但是我们不建议 示例代码： java123456int num = 10;if(num%2==0)&#123; System.out.println(num + \"是偶数\")；&#125;else&#123; System.out.println(num + \"是奇数\")；&#125; 3、多分支结构语法格式： java1234567891011121314if(条件表达式1)&#123; 当条件表达式1成立的时候，执行的语句块1；&#125;else if(条件表达式2)&#123; 当条件表达式1不成立， 条件表达式2成立的时候，执行的语句块2；&#125;else if(条件表达式3)&#123; 当条件表达式1不成立， 条件表达式2也不成立， 条件表达式3成立的时候，执行的语句块3；&#125;。。。【else&#123; 当以上所有的条件表达式都不成立，需要执行的语句块n+1;&#125;】 执行过程： （1）多个条件顺序往下判断，如果上面有一个条件成立了，下面的条件就不看了 （2）多个分支也只会执行其中的一个 注意： （1）每一个条件表达式都必须是boolean值 （2）当{}中只有一个语句时，也可以省略{}，但不建议省略 （3）当多个条件是“互斥”关系（没有重叠部分），顺序可以随意； ​ 当多个条件是“包含”关系（有重叠部分），顺序不能随意，小的在上，大的在下面 示例代码： java12345678910int score = 78;if(score==100)&#123; System.out.println(\"满分\");&#125;else if(score&gt;=80)&#123; System.out.println(\"优秀\");&#125;else if(score&gt;=60)&#123; System.out.println(\"及格\");&#125;else&#123; System.out.println(\"不及格\");&#125; 4、嵌套执行过程： ​ 当嵌套在if中，就是当外面的if成立时，才会看里面的条件判断； ​ 当嵌套在else中，就当外面的else满足时，才会看里面的条件判断； 3.2.2 选择结构语法格式： java12345678910111213switch(表达式)&#123; case 常量值1: 语句块1; 【break;】 case 常量值2: 语句块2; 【break;】 。。。 【default: 语句块n+1; 【break;】 】&#125; 执行过程： （1）入口 ①当switch(表达式)的值与case后面的某个常量值匹配，就从这个case进入； ②当switch(表达式)的值与case后面的所有常量值都不匹配，寻找default分支进入; （2）一旦从“入口”进入switch，就会顺序往下执行，直到遇到“出口” （3）出口 ①自然出口：遇到了switch的结束} ②中断出口：遇到了break等 注意： （1）switch(表达式)的值的类型，只能是：4种基本数据类型（byte,short,int,char），两种引用数据类型（枚举、String） （2）case后面必须是常量值，而且不能重复 示例代码： java12345678910111213141516171819202122232425int month = 4;switch(month)&#123; case 3: case 4: case 5: System.out.println(\"春季\"); break; case 6: case 7: case 8: System.out.println(\"夏季\"); break; case 9: case 10: case 11: System.out.println(\"秋季\"); break; case 12: case 1: case 2: System.out.println(\"冬季\"); break; default: System.out.println(\"输入有误！\");&#125; 3.3 循环结构循环结构： ​ “重复”执行某些代码 循环结构的分类： 1、for循环 2、while循环 3、do…while循环 3.3.1 for循环语法格式： java123456789for(;;)&#123; 循环体语句块； if(条件表达式)&#123; break; &#125;&#125;for(初始化表达式; 循环条件; 迭代表达式)&#123; 循环体语句块；（需要重复执行的代码）&#125; 执行过程： （1）初始化表达式; （2）判断循环条件; （3）如果循环条件成立，先执行循环体语句块；然后执行迭代表达式，再回到（2）… （4）如果循环条件不成立，会结束for； ​ 或者在当前循环中遇到break语句，也会结束当前for循环; 注意： （1）for(;;)中的两个；是不能多也不能少 （2）循环条件必须是boolean类型 示例代码： java1234567891011//遍历1-100之间的偶数for(int i=1; i&lt;=100; i++)&#123;//每次循环的步幅是1 if(i%2==0)&#123; System.out.println(i); &#125;&#125;//遍历1-100之间的偶数for(int i=2; i&lt;=100; i+=2)&#123;//每次循环的步幅是2 System.out.println(i);&#125; 3.3.2 while循环语法格式： java1234567891011while(循环条件)&#123; 循环体语句块;&#125;经典的形式：while(true)&#123; 循环体语句块; if(条件表达式)&#123; break; &#125;&#125; 执行过程： （1）先判断循环条件 （2）如果循环条件成立，就执行循环体语句块；然后回到（1） （3）如果循环条件不成立，就结束while循环； ​ 如果在循环体语句块中，遇到break，也会结束while循环； 注意： （1）while(循环条件)中循环条件必须是boolean类型 示例代码： java123456//遍历1-100之间的偶数int num = 2;while(num&lt;=100)&#123; System.out.println(num); num+=2;&#125; 3.3.3 do…while循环语法格式： java123do&#123; 循环体语句块;&#125;while(循环条件); 执行过程： （1）先执行一次循环体语句块； （2）判断循环条件 （3）如果循环条件成立，再次执行循环体语句块；然后回到（2）… （4）如果循环条件不成立，就结束do…while循环； ​ 如果在循环体语句块中，遇到break，也会结束do…while循环； 注意： （1）while(循环条件)中循环条件必须是boolean类型 （2）do{}while();最后有一个分号 （3）do…while结构的循环体语句是至少会执行一次，这个和for和while是不一样的 示例代码： java12345678910111213141516171819//从键盘输入整数，统计正数、负数的个数，输入0结束java.util.Scanner input = new java.util.Scanner(System.in);int num;int positive = 0;int negative = 0;do&#123; System.out.print(\"请输入整数（0结束）：\"); num = input.nextInt(); if(num &gt; 0)&#123; positive++; &#125;else if(num &lt; 0)&#123; negatvie++; &#125;&#125;while(num!=0);System.out.println(\"正数的个数：\" + positive);System.out.println(\"负数的个数：\" + negatvie); 3.3.4 三种循环的选择原则：三种循环之间是可以互相转换的，都能实现循环的功能 建议（习惯上）：当我们次数比较明显的时候，或者说从几循环到几的时候，一般先考虑for； ​ 当循环体语句块至少要执行一次的时候，一般先考虑do…while； ​ 当循环条件比较明显，但是次数不明显，循环体语句块也不是至少执行一次，那么可以考虑while结构； 三种循环结构都具有四要素： （1）循环变量的初始化表达式 （2）循环条件 （3）循环变量的修改的迭代表达式 （4）循环体语句块 3.3.5 跳转语句1、break 用于： （1）switch结构 作用：结束switch结构 （2）循环结构 作用：结束当前循环 2、continue 用于： 只能用于循环结构 作用：提前结束本次循环，继续下一次循环 3、return（后面讲） 第四章 数组4.1 数组的相关概念和名词（了解）1、数组(array)： ​ 一组具有相同数据类型的数据的按照一定顺序排列的集合。 ​ 把有限的几个相同类型的变量使用一个名称来进行统一管理。 2、数组名： ​ （1）这个数组名，代表的是一组数 ​ （2）这个数组名中存储的整个数组的“首地址” 3、下标(index)： ​ 我们使用编号、索引、下标来区别表示一组数当中某一个。 ​ 范围：[0,数组长度-1] ​ 例如：for(int i = 0; i&lt;arr.length; i++){} 4、元素(element)： ​ 这一组中的的每一个数据都是元素。 ​ 如何表示数组元素？ 数组名[下标] 5、数组的长度(length) ​ 数组中元素的总个数。 ​ 如何获取数组长度？ 数组名.length 注意：名称是为了沟通的方便，概念不用一字不落背下来 4.2 数组的相关语法4.2.1 数组的声明语法格式： java12345 //推荐元素的数据类型[] 数组名; //也对，但是不推荐元素的数据类型 数组名[]; 示例： java12345678//要存储一组整数int[] array;//要存储一组单字符char[] array;//要存储一组字符串String[] array; 4.2.2 数组的初始化初始化的目的：（1）确定数组的长度（2）为元素赋值 两种初始化方式： 1、动态初始化 语法格式： java12345678910//指定数组长度数组名 = new 元素的数据类型[长度];//为元素赋值数组名[下标] = 值; //这个值可以是个常量值，也可以是个表达式的计算结果，也可以是键盘输入的//如果每个元素的赋值比较有规律，通常使用for循环赋值for(int i=0; i&lt;长度; i++)&#123; 数组名[下标] = 值;&#125; 问：如果只指定数组长度，没有为元素手动赋值，那么元素有值吗？ 有默认值 （1）基本数据类型 ​ byte,short,int,long：0 ​ float,double：0.0 ​ char：\\u0000 ​ boolean：false （2）引用数据类型 ​ 统统都是null 2、静态初始化 语法格式： java1234567数组名 = new 元素的数据类型[]&#123;值列表&#125;;//int[] arr = new int[5]&#123;1,2,3,4,5&#125;;//错误的//更简洁//当声明与静态初始化一起完成时，可以简化元素的数据类型[] 数组名 = &#123;值列表&#125;; 适用场合： ​ 当数组的元素是已知的有限个时，可以使用静态初始化。 示例代码： java12345String[] weeks = &#123;\"monday\",\"tuesday\",\"wednesday\",\"thursday\",\"friday\",\"saturday\",\"sunday\"&#125;;int[] daysOfMonths = &#123;31,28,31,30,31,30,31,31,30,31,30,31&#125;;char[] letters = &#123;'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'&#125;; 4.2.3 数组的遍历for循环遍历数组： java1234567891011for(int i=0; i&lt;数组名.lenght; i++)&#123; //或赋值 数组名[i] = 值; //或显示 System.out.println(数组名[i])； //或其他操作 //例如：判断是否是偶数 if(数组名[i]%2==0)&#123; //... &#125;&#125; 4.2.4 数组的内存分析元素是基本数据类型的一维数组内存分析： angelscript1int[] arr = &#123;1,2,3,4,5&#125;; java1234int[] arr = new int[5];for(int i=0; i&lt;arr.length; i++)&#123; arr[i] = i+1;&#125; 4.3 数组的相关算法4.3.1 数组找最值1、数组中找最值 思路： （1）先假设第一个元素最大/最小 （2）然后用max/min与后面的元素一一比较 示例代码： java12345678int[] arr = &#123;4,5,6,1,9&#125;;//找最大值int max = arr[0];for(int i=1; i&lt;arr.length; i++)&#123; if(arr[i] &gt; max)&#123; max = arr[i]; &#125;&#125; 2、数组中找最值及其下标 情况一：找最值及其第一次出现的下标 思路： （1）先假设第一个元素最大/最小 （2）然后用max/min与后面的元素一一比较 示例代码： java12345678910int[] arr = &#123;4,5,6,1,9&#125;;//找最大值int max = arr[0];int index = 0;for(int i=1; i&lt;arr.length; i++)&#123; if(arr[i] &gt; max)&#123; max = arr[i]; index = i; &#125;&#125; 或 java123456789int[] arr = &#123;4,5,6,1,9&#125;;//找最大值int maxIndex = 0;for(int i=1; i&lt;arr.length; i++)&#123; if(arr[i] &gt; arr[maxIndex])&#123; maxIndex = i; &#125;&#125;System.out.println(\"最大值：\" + arr[maxIndex]); 情况二：找最值及其所有最值的下标（即可能最大值重复） 思路： （1）先找最大值 ①假设第一个元素最大 ②用max与后面的元素一一比较 （2）遍历数组，看哪些元素和最大值是一样的 示例代码： java123456789101112131415int[] arr = &#123;4,5,6,1,9&#125;;//找最大值int max = arr[0];for(int i=1; i&lt;arr.length; i++)&#123; if(arr[i] &gt; max)&#123; max = arr[i]; &#125;&#125;//遍历数组，看哪些元素和最大值是一样的for(int i=0; i&lt;arr.length; i++)&#123; if(max == arr[i])&#123; System.out.print(i+\"\\t\"); &#125;&#125; 4.3.2 数组统计：求总和、均值、统计偶数个数等思路：遍历数组，挨个的累加，判断每一个元素 示例代码： java1234567int[] arr = &#123;4,5,6,1,9&#125;;//求总和、均值int sum = 0;//因为0加上任何数都不影响结果for(int i=0; i&lt;arr.length; i++)&#123; sum += arr[i];&#125;double avg = (double)sum/arr.length; 示例代码2： java1234567int[] arr = &#123;4,5,6,1,9&#125;;//求总乘积long result = 1;//因为1乘以任何数都不影响结果for(int i=0; i&lt;arr.length; i++)&#123; result *= arr[i];&#125; 示例代码3： java12345678int[] arr = &#123;4,5,6,1,9&#125;;//统计偶数个数int even = 0;for(int i=0; i&lt;arr.length; i++)&#123; if(arr[i]%2==0)&#123; even++; &#125;&#125; 4.3.3 反转方法有两种： 1、借助一个新数组 2、首尾对应位置交换 第一种方式示例代码： java123456789101112131415161718int[] arr = &#123;1,2,3,4,5,6,7,8,9&#125;;//(1)先创建一个新数组int[] newArr = new int[arr.length];//(2)复制元素int len = arr.length;for(int i=0; i&lt;newArr.length; i++)&#123; newArr[i] = arr[len -1 - i];&#125;//(3)舍弃旧的，让arr指向新数组arr = newArr;//这里把新数组的首地址赋值给了arr//(4)遍历显示for(int i=0; i&lt;arr.length; i++)&#123; System.out.println(arr[i]);&#125; 第二种方式示例代码： java123456789101112131415int[] arr = &#123;1,2,3,4,5,6,7,8,9&#125;;//(1)计算要交换的次数： 次数 = arr.length/2//(2)首尾交换for(int i=0; i&lt;arr.length/2; i++)&#123;//循环的次数就是交换的次数 //首 与 尾交换 int temp = arr[i]; arr[i] = arr[arr.length-1-i]; arr[arr.length-1-i] = temp;&#125;//（3）遍历显示for(int i=0; i&lt;arr.length; i++)&#123; System.out.println(arr[i]);&#125; 4.3.4 复制应用场景： 1、扩容 2、备份 3、截取 示例代码：扩容 java12345678910111213141516171819202122int[] arr = &#123;1,2,3,4,5,6,7,8,9&#125;;//如果要把arr数组扩容，增加1个位置//(1)先创建一个新数组，它的长度 = 旧数组的长度+1int[] newArr = new int[arr.length + 1];//(2)复制元素//注意：i&lt;arr.length 因位arr比newArr短，避免下标越界for(int i=0; i&lt;arr.length; i++)&#123; newArr[i] = arr[i];&#125;//(3)把新元素添加到newArr的最后newArr[newArr.length-1] = 新值;//(4)如果下面继续使用arr，可以让arr指向新数组arr = newArr;//(4)遍历显示for(int i=0; i&lt;arr.length; i++)&#123; System.out.println(arr[i]);&#125; 示例代码：备份 java1234567891011121314int[] arr = &#123;1,2,3,4,5,6,7,8,9&#125;;//1、创建一个长度和原来的数组一样的新数组int[] newArr = new int[arr.length];//2、复制元素for(int i=0; i&lt;arr.length; i++)&#123; newArr[i] = arr[i];&#125;//3、遍历显示for(int i=0; i&lt;arr.length; i++)&#123; System.out.println(arr[i]);&#125; 示例代码：截取 java1234567891011121314151617int[] arr = &#123;1,2,3,4,5,6,7,8,9&#125;;int start = 2;int end = 5;//1、创建一个新数组，新数组的长度 = end-start + 1;int[] newArr = new int[end-start+1];//2、赋值元素for(int i=0; i&lt;newArr.length; i++)&#123; newArr[i] = arr[start + i];&#125;//3、遍历显示for(int i=0; i&lt;newArr.length; i++)&#123; System.out.println(newArr[i]);&#125; 4.3.5 查找查找分为两种： 1、顺序查找：挨个看 ​ 对数组没要求 2、二分查找：对折对折再对折 ​ 对数组有要求，元素必须有大小顺序的 顺序查找示例代码： java12345678910111213141516int[] arr = &#123;4,5,6,1,9&#125;;int value = 1;int index = -1;for(int i=0; i&lt;arr.length; i++)&#123; if(arr[i] == value)&#123; index = i; break; &#125;&#125;if(index==-1)&#123; System.out.println(value + \"不存在\");&#125;else&#123; System.out.println(value + \"的下标是\" + index);&#125; 二分查找示例代码： java12345678910111213141516171819202122232425262728293031323334353637/*2、编写代码，使用二分查找法在数组中查找 int value = 2;是否存在，如果存在显示下标，不存在显示不存在。已知数组：int[] arr = &#123;1,2,3,4,5,6,7,8,9,10&#125;;*/class Exam2&#123; public static void main(String[] args)&#123; int[] arr = &#123;1,2,3,4,5,6,7,8,9&#125;;//数组是有序的 int value = 2; int index = -1; int left = 0; int right = arr.length - 1; int mid = (left + right)/2; while(left&lt;=right)&#123; //找到结束 if(value == arr[mid])&#123; index = mid; break; &#125;//没找到 else if(value &gt; arr[mid])&#123;//往右继续查找 //移动左边界，使得mid往右移动 left = mid + 1; &#125;else if(value &lt; arr[mid])&#123;//往左边继续查找 right = mid - 1; &#125; mid = (left + right)/2; &#125; if(index==-1)&#123; System.out.println(value + \"不存在\"); &#125;else&#123; System.out.println(value + \"的下标是\" + index); &#125; &#125;&#125; 使用for java12345678910111213141516171819202122232425262728293031class Exam2&#123; public static void main(String[] args)&#123; int[] arr = &#123;1,2,3,4,5,6,7,8,9&#125;;//数组是有序的 int value = 2; int index = -1; for(int left=0,right=arr.length-1,mid = (left+right)/2; left&lt;=right; mid = (left + right)/2)&#123; //找到结束 if(value == arr[mid])&#123; index = mid; break; &#125;//没找到 else if(value &gt; arr[mid])&#123;//往右继续查找 //移动左边界，使得mid往右移动 left = mid + 1; &#125;else if(value &lt; arr[mid])&#123;//往左边继续查找 right = mid - 1; &#125; &#125; if(index==-1)&#123; System.out.println(value + \"不存在\"); &#125;else&#123; System.out.println(value + \"的下标是\" + index); &#125; &#125;&#125; 4.3.6 排序数组的排序算法有千万种，我们只讲了两种： 1、冒泡排序 2、简单的直接排序 示例代码：冒泡：从小到大，从左到右两两比较 java12345678910111213141516171819int[] arr = &#123;5,4,6,3,1&#125;;for(int i=1; i&lt;arr.length; i++)&#123;//外循环的次数 = 轮数 = 数组的长度-1 /* 第1轮，i=1,从左到右两两比较，arr[0]与arr[1]。。。。。arr[3]与arr[4] 第2轮，i=2,从左到右两两比较，arr[0]与arr[1]。。。。。arr[2]与arr[3] ... arr[j]与arr[j+1]比较 找两个关键点：（1）j的起始值：0（2）找j的终止值，依次是3,2,1,0，得出j&lt;arr.length-i */ for(int j=0; j&lt;arr.length-i; j++)&#123; //两两比较 //从小到大，说明前面的比后面的大，就交换 if(arr[j] &gt; arr[j+1])&#123; int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125;&#125; 示例代码：从大到小，从右到左 java12345678910111213141516171819char[] arr = &#123;'h','e','l','l','o','j','a','v','a'&#125;;for(int i=1; i&lt;arr.length; i++)&#123;//外循环的次数 = 轮数 = 数组的长度-1 /* 第1轮，i=1，从右到左两两比较，arr[8]与arr[7]，arr[7]与arr[6]....arr[1]与arr[0] 第2轮，i=2，从右到左两两比较，arr[8]与arr[7]，arr[7]与arr[6]....arr[2]与arr[1] ... 第8轮，i=8，从右到左两两比较，arr[8]与arr[7] arr[j]与arr[j-1] 找两个关键点：（1）j的起始值：8（2）找j的终止值，依次是1,2,3,。。。8，得出j&gt;=i */ for(int j=8; j&gt;=i; j--)&#123; //从大到小，后面的元素 &gt; 前面的元素，就交换 if(arr[j]&gt;arr[j-1])&#123; int temp = arr[j]; arr[j] = arr[j-1]; arr[j-1] = temp; &#125; &#125;&#125; 示例代码：简单的直接选择排序 java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849int[] arr = &#123;3,2,6,1,8&#125;;for(int i=1; i&lt;arr.length; i++)&#123;//外循环的次数 = 轮数 = 数组的长度-1 //（1）找出本轮未排序元素中的最值 /* 未排序元素： 第1轮：i=1,未排序，[0,4] 第2轮：i=2,未排序，[1,4] ... 每一轮未排序元素的起始下标：0,1,2,3，正好是i-1的 未排序的后面的元素依次： 第1轮：[1,4] j=1,2,3,4 第2轮：[2,4] j=2,3,4 第3轮：[3,4] j=3,4 第4轮：[4,4] j=4 j的起点是i，终点都是4 */ int max = arr[i-1]; int index = i-1; for(int j=i; j&lt;arr.length; j++)&#123; if(arr[j] &gt; max)&#123; max = arr[j]; index = j; &#125; &#125; //（2）如果这个最值没有在它应该在的位置，就与这个位置的元素交换 /* 第1轮，最大值应该在[0] 第2轮，最大值应该在[1] 第3轮，最大值应该在[2] 第4轮，最大值应该在[3] 正好是i-1的值 */ if(index != i-1)&#123; //交换arr[i-1]与arr[index] int temp = arr[i-1]; arr[i-1] = arr[index]; arr[index] = temp; &#125;&#125;//显示结果for(int i=0; i&lt;arr.length; i++)&#123; System.out.print(arr[i]);&#125; 4.4 二维数组二维数组的标记：[][] 4.4.1 相关的表示方式（1）二维数组的长度/行数： ​ 二维数组名.length （2）二维数组的其中一行： ​ 二维数组名[行下标] ​ 行下标的范围：[0, 二维数组名.length-1] （3）每一行的列数： ​ 二维数组名[行下标].length ​ 因为二维数组的每一行是一个一维数组 （4）每一个元素 ​ 二维数组名[行下标][列下标] 4.4.2 二维数组的声明和初始化1、二维数组的声明 java1234567 //推荐 元素的数据类型[][] 二维数组的名称;//不推荐元素的数据类型 二维数组名[][];//不推荐 元素的数据类型[] 二维数组名[]; 面试： gml12int[] x, y[];//x是一维数组，y是二维数组 2、二维数组的初始化 （1）静态初始化 java1234567891011121314二维数组名 = new 元素的数据类型[][]&#123; &#123;第一行的值列表&#125;, &#123;第二行的值列表&#125;, ... &#123;第n行的值列表&#125; &#125;; //如果声明与静态初始化一起完成元素的数据类型[][] 二维数组的名称 = &#123; &#123;第一行的值列表&#125;, &#123;第二行的值列表&#125;, ... &#123;第n行的值列表&#125; &#125;; （2）动态初始化（不规则：每一行的列数可能不一样） java12345678//（1）先确定总行数二维数组名 = new 元素的数据类型[总行数][];//（2）再确定每一行的列数二维数组名[行下标] = new 元素的数据类型[该行的总列数];//(3)再为元素赋值二维数组名[行下标][列下标] = 值; （3）动态初始化（规则：每一行的列数是相同的） java12345//（1）确定行数和列数二维数组名 = new 元素的数据类型[总行数][每一行的列数];//（2）再为元素赋值二维数组名[行下标][列下标] = 值; 4.4.3 二维数组的遍历matlab123456for(int i=0; i&lt;二维数组名.length; i++)&#123; for(int j=0; j&lt;二维数组名[i].length; j++)&#123; System.out.print(二维数组名[i][j]); &#125; System.out.println();&#125; 第五章 面向对象基础5.1 类与对象1、类：一类具有相同特性的事物的抽象描述。 ​ 对象：类的一个个体，实例，具体的存在。 ​ 类是对象的设计模板。 2、如何声明类？ java123【修饰符】 class 类名&#123; 成员列表：属性、方法、构造器、代码块、内部类&#125; 3、如何创建对象？ java123new 类名(); //匿名对象类名 对象名 = new 类名(); //有名对象 5.2 类的成员之一：属性1、如何声明属性？ java1234【修饰符】 class 类名&#123; 【修饰符】 数据类型 属性名; //属性有默认值 【修饰符】 数据类型 属性名 = 值; //属性有初始值&#125; 说明：属性的类型可以是Java的任意类型，包括基本数据类型、引用数据类型（类、接口、数组等） 总结：Java的数据类型 （1）基本数据类型 byte,short,int,long,float,double,char,boolean （2）引用数据类型 ①类： ​ 例如：String、Student、Circle、System、Scanner、Math… ②接口：后面讲 ③数组： ​ 例如：int[]，String[]，char[]，int[][] java12345int[] arr = new int[5];这里把int[]看成数组类型，是一种引用数据类型，右边赋值的是一个数组的对象元素的数据类型：int数组的数据类型：int[] 2、如何为属性赋值？ （1）在声明属性时显式赋值 java123【修饰符】 class 类名&#123; 【修饰符】 数据类型 属性名 = 值; //属性有初始值&#125; 代码示例： java123456789101112131415161718192021class Student&#123; String name; char gender = '男';//显式赋值&#125;class TestStudent&#123; public static void main(String[] args)&#123; Student s1 = new Student(); System.out.println(\"姓名：\" + s1.name);//null System.out.println(\"性别：\" + s1.gender);//男 s1.name = \"小薇\";//修改属性的默认值 s1.gender = '女';//修改属性的初始值 System.out.println(\"姓名：\" + s1.name);//小薇 System.out.println(\"性别：\" + s1.gender);//女 Student s2 = new Student(); System.out.println(\"姓名：\" + s2.name);//null System.out.println(\"性别：\" + s2.gender);//男 &#125;&#125; （2）创建对象之后赋值 java123456789【修饰符】 class 类名&#123; 【修饰符】 数据类型 属性名; //属性有默认值&#125;//创建对象类名 对象名 = new 类名();//为对象的属性赋值对象名.属性名 = 值; 3、如何访问属性的值？ （1）在本类的方法中访问 示例代码： java1234567class Circle&#123; double radius; double getArea()&#123; return 3.14 * radius * radius;//直接访问 &#125;&#125; （2）在其他类的方法中访问 java12345678910class Circle&#123; double radius;&#125;class TestCircle&#123; public static void main(String[] args)&#123; Circle c1 = new Circle(); double area = 3.14 * c1.radius * c1.radius;//对象名.属性名 &#125;&#125; 4、属性的特点 （1）属性有默认值 基本数据类型： ​ byte,short,int,long：0 ​ float，double：0.0 ​ char：\\u0000 ​ boolean：false 引用数据类型： ​ null （2）每一个对象的属性是独立，互不干扰 5、对象属性的内存图 java123456789101112131415161718192021class Student&#123; String name; char gender = '男';//显式赋值&#125;class TestStudent&#123; public static void main(String[] args)&#123; Student s1 = new Student(); System.out.println(\"姓名：\" + s1.name);//null System.out.println(\"性别：\" + s1.gender);//男 s1.name = \"小薇\"; s1.gender = '女'; System.out.println(\"姓名：\" + s1.name);//小薇 System.out.println(\"性别：\" + s1.gender);//女 Student s2 = new Student(); System.out.println(\"姓名：\" + s2.name);//null System.out.println(\"性别：\" + s2.gender);//男 &#125;&#125; 5.4 类的成员之二：方法5.4.1 方法的概念方法（method）：代表一个独立的可复用的功能 目的/好处： （1）复用 （2）简化代码 5.4.2 方法的语法1、方法的声明格式： java12345【修饰符】 class 类名&#123; 【修饰符】 返回值类型 方法名(【形参列表】)&#123; 方法体：实现功能的代码 &#125;&#125; 说明： （1）【修饰符】：待讲 （2）返回值类型： ①void：表示无返回值 ②非void：所有的Java数据类型都可以 （3）方法名：能很好的体现方法的功能 命名的规范：①见名知意②从第二个单词开始首字母大写 （4）【形参列表】： ​ 在完成这个方法的功能时，需要一些数据，这些数据要由“调用者”来决定，那我们就可以设计形参。 ​ 语法格式： ​ ()：无参，空参 ​ (数据类型 形参名)：一个形参 ​ (数据类型1 形参名1, ……, 数据类型n 形参名n)：n个形参 （5）方法体：实现方法的功能，最好一个方法就完成一个独立的功能。 2、方法的调用格式： java12//本类同级别方法调用：直接调用【变量 = 】 方法名(【实参列表】); java12//在其他类的方法中调用【变量 = 】 对象名.方法名(【实参列表】); （1）是否传实参 看被调用的方法是否有形参 （2）是否接收返回值 看被调用的方法是否是void，如果是void，就不需要也不能接收，如果不是void，就可以接收。 3、方法的声明与调用的代码示例 （1）无参无返回值方法 java1234567891011//本类class Circle&#123; double radius; void printInfo()&#123; System.out.println(\"半径：\" + radius); &#125; void test()&#123; printInfo();//本类中调用无参无返回值方法 &#125;&#125; java1234567891011121314//其他类class Circle&#123; double radius; void printInfo()&#123; System.out.println(\"半径：\" + radius); &#125;&#125;class TestCircle&#123; public static void main(String[] args)&#123; Circle c1 = new Circle(); c1.printInfo(); //其他类中调用无参无返回值方法 &#125;&#125; （2）无参有返回值方法 java1234567891011121314//本类class Circle&#123; double radius; double getArea()&#123; return 3.14 * radius * radius(); &#125; void printInfo()&#123; // System.out.println(\"半径：\" + radius + \"，面积：\" + getArea());//本类中调用无参有返回值 double area = getArea();//本类中调用无参有返回值 System.out.println(\"半径：\" + radius + \"，面积：\" + area); &#125;&#125; java1234567891011121314151617//其他类class Circle&#123; double radius; double getArea()&#123; return 3.14 * radius * radius(); &#125;&#125;class TestCircle&#123; public static void main(String[] args)&#123; Circle c1 = new Circle(); double area = c1.getArea(); System.out.println(\"面积：\" + area); //或 System.out.println(\"面积：\" + c1.getArea()); &#125;&#125; （3）有参无返回值方法 java123456789101112131415//本类class GraphicTools&#123; void printRectange(int line, int column, char sign)&#123; for(int i=1; i&lt;=line; i++)&#123; for(int j=1; j&lt;=column; j++)&#123; Sytem.out.print(sign); &#125; System.out.println(); &#125; &#125; void test()&#123; printRectange(5,10,'%');//本类中调用有参无返回值方法 &#125;&#125; java1234567891011121314151617//其他类class GraphicTools&#123; void printRectange(int line, int column, char sign)&#123; for(int i=1; i&lt;=line; i++)&#123; for(int j=1; j&lt;=column; j++)&#123; Sytem.out.print(sign); &#125; System.out.println(); &#125; &#125;&#125;class Test&#123; public static void main(String[] args)&#123; GraphicTools tools = new GraphicTools(); tools.printRectange(5,10,'%'); &#125;&#125; （4）有参有返回值方法 java123456789101112//本类class MyMath&#123; int sum(int a,int b)&#123; return a+b; &#125; void print()&#123; int x = 4; int y = 7; System.out.println(x + \"+\" + y + \"=\" + sum(x,y);//本类中调用有参有返回值的方法 &#125;&#125; java123456789101112131415//其他类class MyMath&#123; int sum(int a,int b)&#123; return a+b; &#125;&#125;class Test&#123; public static void main(String[] args)&#123; MyMath my = new MyMath(); int x = 4; int y = 7; System.out.println(x + \"+\" + y + \"=\" + my.sum(x,y)); &#125;&#125; 4、方法声明与调用的原则 （1）方法必须先声明后调用 如果调用方法时，如果方法名写错或调用一个不存在的方法，编译会报错 （2）方法声明的位置必须在类中方法外 正确示例： java12345678类&#123; 方法1()&#123; &#125; 方法2()&#123; &#125;&#125; 错误示例： java1234567类&#123; 方法1()&#123; 方法2()&#123; //错误 &#125; &#125;&#125; （3）方法的调用的位置有要求 正确示例： java12345类&#123; 方法1()&#123; 调用方法 &#125;&#125; 错误示例： java1234567类&#123; 方法1()&#123; &#125; 调用方法 //错误位置&#125; （4）方法的调用格式要与方法的声明格式对应 ①是否要加“对象.”：看是否在本类中，还是其他类中 ②是否要接收返回值：看被调用方法是否是void ③是否要传实参：看被调用方法是有形参列表 5.4.3 方法的重载Overload概念：在同一个类中，出现了两个或多个的方法，它们的方法名称相同，形参列表不同，这样的形式称为方法的重载。和返回值类型无关。 示例代码： java1234567891011121314 //求两个整数的最大值public int max(int a,int b)&#123; return a&gt;b?a:b;&#125; //求三个整数的最大值public int max(int a, int b, int c)&#123; return max(max(a,b),c);&#125; //求两个小数的最大值public double max(double a, double b)&#123; return a&gt;b?a:b;&#125; 5.4.4 方法的参数传递机制Java中方法的参数传递机制：值传递 （1）形参是基本数据类型时，实参给形参传递数据值，是copy的形式，形参对值的修改不影响实参。（2）形参是引用数据类型时，实参给形参传递地址值，形参对对象的属性的修改，会影响实参对象的属性值，因为此时形参和实参就是指向同一个对象。示例代码： java12345678910111213class Test&#123; public static void swap(int a, int b)&#123; int temp = a; a = b; b = temp; &#125; public static void main（String[] args)&#123; int x = 1; int y = 2; swap(x,y);//调用完之后，x与y的值不变 &#125;&#125; 示例代码： java12345678910111213141516class Test&#123; public static void change(MyData my)&#123; my.num *= 2; &#125; public static void main(String[] args)&#123; MyData m = new MyData(); m.num = 1; change(m);//调用完之后，m对象的num属性值就变为2 &#125;&#125;class MyData&#123; int num;&#125; 陷阱1： java1234567891011121314151617181920/*陷阱1：在方法中，形参 = 新new对象，那么就和实参无关了*/class Test&#123; public static void change(MyData my)&#123; my = new MyData();//形参指向了新对象 my.num *= 2; &#125; public static void main(String[] args)&#123; MyData m = new MyData(); m.num = 1; change(m);//调用完之后，m对象的num属性值仍然为1 &#125;&#125;class MyData&#123; int num;&#125; 陷阱2：见字符串和包装类部分 5.3 对象数组一维数组： 1、元素是基本数据类型 2、元素是引用数据类型，也称为对象数组，即数组的元素是对象 注意：对象数组，首先要创建数组对象本身，即确定数组的长度，然后再创建每一个元素对象，如果不创建，数组的元素的默认值就是null，所以很容易出现空指针异常NullPointerException。 示例代码： java1234567891011121314151617class MyDate&#123; int year; int month; int day;&#125;class Test&#123; public static void main(String[] args)&#123; MyDate[] arr = new MyDate[3];//创建数组对象本身，指定数组的长度 for(int i=0; i&lt;arr.length; i++)&#123; arr[i] = new MyDate();//每一个元素要创建对象 arr[i].year = 1990 + i; arr[i].month = 1 + i; arr[i].day = 1 + i; &#125; &#125;&#125; 对象数组的内存图： 第六章 面向对象的基本特征面向对象的基本特征： 1、封装 2、继承 3、多态 6.1 封装1、好处： （1）隐藏实现细节，方便使用者使用 （2）安全，可以控制可见范围 2、如何实现封装？ 通过权限修饰符 面试题：请按照可见范围从小到大（从大到小）列出权限修饰符？ 修饰符 本类 本包 其他包的子类 任意位置 private √ × × × 缺省 √ √ × × protected √ √ √ × public √ √ √ √ 权限修饰符可以修饰什么？ 类（类、接口等）、属性、方法、构造器、内部类 类（外部类）：public和缺省 属性：4种 方法：4种 构造器：4种 内部类：4种 3、通常属性的封装是什么样的？ 当然属性的权限修饰符可以是private、缺省、protected、public。但是我们大多数时候，见到的都是private，然后给它们配上get/set方法。 示例代码：标准Javabean的写法 java1234567891011121314151617181920212223242526public class Student&#123; //属性私有化 private String name; private int age; private boolean marry; //公共的get/set public void setName(String n)&#123; name = n;//这里因为还没有学习this等，可能还会优化 &#125; public String getName()&#123; return name; &#125; public void setAge(int a)&#123; age = a; &#125; public int getAge()&#123; return age; &#125; public void setMarry(boolean m)&#123; marry = m; &#125; public boolean isMarry()&#123;//boolean类型的属性的get方法，习惯使用把get换成is return marry; &#125;&#125; 6.2 构造器1、构造器的作用：（1）和new一起使用创建对象 java12345//调用无参构造创建对象类名 对象名 = new 类名();//调用有参构造创建对象类名 对象名 = new 类名(实参列表); （2）可以在创建对象的同时为属性赋值 java12345678910public class Circle&#123; private double radius; public Circle()&#123; &#125; public Circle(double r)&#123; radius = r;//为radius赋值 &#125;&#125; 2、声明构造器的语法格式： java12345678【修饰符】 class 类名&#123; 【修饰符】 类名()&#123;//无参构造 &#125; 【修饰符】 类名(形参列表)&#123;//有参构造 &#125;&#125; 3、构造器的特点： （1）所有的类都有构造器 （2）如果一个类没有显式/明确的声明一个构造器，那么编译器将会自动添加一个默认的无参构造 （3）如果一个类显式/明确的声明了构造器，那么编译器将不再自动添加默认的无参构造，如果需要，那么就需要手动添加 （4）构造器的名称必须与类名相同 （5）构造器没有返回值类型 （6）构造器可以重载 示例代码： java12345678910public class Circle&#123; private double radius; public Circle()&#123; &#125; public Circle(double r)&#123; radius = r;//为radius赋值 &#125;&#125; 6.3 关键字this1、this关键字： 意思：当前对象 （1）如果出现在构造器中：表示正在创建的对象 （2）如果出现在成员方法中：表示正在调用这个方法的对象 2、this的用法： （1）this.属性 当局部变量与成员变量同名时，那么可以在成员变量的而前面加“this.”用于区别 （2）this.方法 调用当前对象的成员方法，完全可以省略“this.” （3）this()或this(实参列表) this()表示调用本类的无参构造 this(实参列表)表示调用本类的有参构造 this()或this(实参列表)要么没有，要么必须出现在构造器的首行 示例代码： java1234567891011121314151617181920212223242526public class Student&#123; private String name; private int score; public Student()&#123; &#125; public Student(String name)&#123; this.name = name; &#125; public Student(String name, int score)&#123; this(name); &#125; public void setName(String name)&#123; this.name = name; &#125; public String getName()&#123; return name; &#125; public void setScore(int score)&#123; this.score = score; &#125; public int getScore()&#123; return score; &#125;&#125; 3、成员变量与局部变量的区别？ 这里只讨论实例变量（关于类变量见static部分） （1）声明的位置不同 成员变量：类中方法外 局部变量：方法中或代码中 ​ ①方法的形参列表 ​ ②方法体中局部变量 ​ ③代码块中的局部变量 （2）运行时在内存中的存储位置不同 成员变量：堆 局部变量：栈 基本数据类型的变量在栈中，引用数据类型的变量在堆中：不准确 （3）修饰符 成员变量：有很多修饰符，例如：权限修饰符 局部变量：不能加权限修饰符，唯一的能加的是final （4）初始化 成员变量：有默认值 局部变量：没有默认值，必须手动初始化 （5）生命周期 成员变量：随着对象的创建而创建，随着对象被回收而消亡，即与对象同生共死。每一个对象都是独立的。 局部变量：方法调用时才分配，方法运行结束就没有了。每一次方法调用，都是独立的 6.4 包1、包的作用： （1）可以避免类重名 有了包之后，类的全名称就变为：包.类名 （2）分类组织管理众多的类 例如：java.lang包，java.util包，java.io包….. （3）可以控制某些类型或成员的可见范围 如果某个类型或者成员的权限修饰缺省的话，那么就仅限于本包使用 2、声明包的语法格式： java1package 包名; 注意： (1)必须在源文件的代码首行 (2)一个源文件只能有一个 3、包的命名规范和习惯：（1）所有单词都小写，每一个单词之间使用.分割（2）习惯用公司的域名倒置 例如：com.atguigu.xxx; 建议大家取包名时不要使用“java.xx”包 4、使用其他包的类： 前提：被使用的类或成员的权限修饰符是&gt;缺省的 （1）使用类型的全名称 例如：java.util.Scanner input = new java.util.Scanner(System.in); （2）使用import 语句之后，代码中使用简名称 5、import语句 java12import 包.类名;import 包.*; 注意：当使用两个不同包的同名类时，例如：java.util.Date和java.sql.Date。 一个使用全名称，一个使用简名称 示例代码： java123456789package com.atguigu.test;import java.util.Scanner;public class Test&#123; public static void main(String[] args)&#123; Scanner input = new Scanner(System.in); &#125;&#125; 6.5 eclipse的使用1、eclipse管理项目和代码的结构 workspace –&gt; project –&gt; 包–&gt;类… 一个工作空间可以有多个项目。 2、快捷键 常规快捷键： Ctrl + S：保存 Ctrl + C：复制 Ctrl + V：粘贴 Ctrl + X：剪切 Ctrl + Y：反撤销 Ctrl + Z：撤销 Ctrl + A：全选 eclipse中默认的快捷键： Ctrl + 1：快速修复 Alt + /：代码提示 Alt + ?： Alt + Shift + / 方法的形参列表提示 Ctrl + D：删除选中行 Ctrl + Alt + ↓：向下复制行 Ctrl + Alt + ↑：向上复制行 Alt + ↓：与下面的行交换位置 Alt + ↑：与下面的行交换位置 Ctrl + Shift + F：快速格式 Ctrl + /：单行注释，再按一次取消 Ctrl + Shift + /：多行注释 Ctrl + Shift +\\：取消多行注释 Shift + 回车：在光标下一行插入新航开始编辑 Ctrl + Shift + 回车：在光标上一行插入新航开始编辑 Alt + Shift + A：多行编辑 再按一次退出多行编辑模式 Alt + Shift + S：弹出自动生成代码的菜单选择，包括自动生成构造器、get/set、equals…… Ctrl + Shift + O：快速导包 Ctrl + Shift + T：打开某个类的源文件 Ctrl + O：打开某个类型的摘要outline 3、快速开发的代码模板 代码模板 + Alt + / （1）main public static void main(String[] args){ } （2）sysout System.out.println(); （3）for for(int i=0; i&lt;数组名.lenght; i++){ } 其他详细使用见《JavaSE_柴林燕_相关工具.docx》 6.6 面向对象的基本特征之二：继承1、为什么要继承？继承的好处？（理解） （1）代码的复用 （2）代码的扩展 2、如何实现继承？ 语法格式： java123【修饰符】 class 子类 extends 父类&#123; &#125; 3、继承的特点 （1）子类会继承父类的所有特征（属性、方法） 但是，私有的在子类中是不能直接使用的 （2）子类不会继承父类的构造器 因为，父类的构造器是用于创建父类的对象的 （3）子类的构造器中又必须去调用父类的构造器 在创建子类对象的同时，为从父类继承的属性进行初始化用，可以借助父类的构造器中的代码为属性赋值。 （4）Java只支持单继承：一个子类只能有一个“直接”父类 （5）Java又支持多层继承：父类还可以有父类，特征会代代相传 （6）一个父类可以同时拥有很多个子类 6.7 关键字supersuper关键字：引用父类的，找父类的xx 用法： （1）super.属性 当子类声明了和父类同名的成员变量时，那么如果要表示某个成员变量是父类的，那么可以加“super.” （2）super.方法 当子类重写了父类的方法，又需要在子类中调用父类被重写的方法，可以使用”super.” （3）super()或super(实参列表) super()：表示调用父类的无参构造 super(实参列表)：表示调用父类的有参构造 注意： （1）如果要写super()或super(实参列表)，必须写在子类构造器的首行 （2）如果子类的构造器中没有写：super()或super(实参列表)，那么默认会有 super() （3）如果父类没有无参构造，那么在子类的构造器的首行“必须”写super(实参列表) 6.8 方法的重写1、方法的重写（Override） 当子类继承了父类的方法时，又觉得父类的方法体的实现不适合于子类，那么子类可以选择进行重写。 2、方法的重写的要求 （1）方法名：必须相同 （2）形参列表：必须相同 （3）修饰符 ​ 权限修饰符： &gt;= （4）返回值类型 ​ 如果是基本数据类型和void：必须相同 ​ 如果是引用数据类型：&lt;= ​ 在Java中我们认为，在概念范围上：子类 &lt;父类 3、重载（Overload）与重写（Override）的区别 ​ 重载（Overload）：在同一个类中，方法名相同，形参列表不同，和返回值类型无关的两个或多个方法。 ​ 重写（Override）：在父子类之间。对方法签名的要求见上面。 特殊的重载： java123456789101112131415161718public class TestOverload &#123; public static void main(String[] args) &#123; B b = new B(); //b对象可以调用几个a方法 b.a(); b.a(\"\");//从b对象同时拥有两个方法名相同，形参不同的角度来说，算是重载 &#125;&#125;class A&#123; public void a()&#123; //... &#125;&#125;class B extends A&#123; public void a(String str)&#123; &#125;&#125; 6.9 非静态代码块1、语法格式 java12345【修饰符】 class 类名&#123; &#123; 非静态代码块 &#125;&#125; 2、作用 目的：在创建的过程中，为对象属性赋值，协助完成实例初始化的过程 3、什么时候执行？ （1）每次创建对象时都会执行 （2）优先于构造器执行 6.10 实例初始化过程1、概念描述 实例初始化过程：实例对象创建的过程 实例初始化方法：实例对象创建时要执行的方法 实例初始化方法的由来：它是有编译器编译生成的 实例初始化方法的形式：()或(形参列表) 实例初始化方法的构成： ①属性的显式赋值代码 ②非静态代码块的代码 ③构造器的代码 其中 ①和②按顺序执行，从上往下 ③在①和②的后面 因此一个类有几个构造器，就有几个实例初始化方法。 2、单个类实例初始化方法 示例代码： java123456789101112131415161718192021222324class Demo&#123; &#123; System.out.println(\"非静态代码块1\"); &#125; private String str = assign();//调用方法，来为str进行显式赋值 public Demo()&#123; System.out.println(\"无参构造\"); &#125; public Demo(String str)&#123; this.str = str; System.out.println(\"有参构造\"); &#125; &#123; System.out.println(\"非静态代码块2\"); &#125; public String assign()&#123; System.out.println(\"assign方法\"); return \"hello\"; &#125;&#125; 图解： 3、父子类的实例初始化 注意： （1）原先super()和super(实参列表)说是调用父类的构造器，现在就要纠正为调用父类的实例初始化方法了 （2）原先super()和super(实参列表)说是必须在子类构造器的首行，现在要纠正为必须在子类实例初始化方法的首行 结论： （1）执行顺序是先父类实例初始化方法，再子类实例初始化方法 （2）如果子类重写了方法，通过子类对象调用，一定是执行重写过的方法 示例代码： java123456789101112131415161718192021222324252627282930313233class Ba&#123; private String str = assign(); &#123; System.out.println(\"(1)父类的非静态代码块\"); &#125; public Ba()&#123; System.out.println(\"(2)父类的无参构造\"); &#125; public String assign()&#123; System.out.println(\"(3)父类的assign()\"); return \"ba\"; &#125;&#125;class Er extends Ba&#123; private String str = assign(); &#123; System.out.println(\"(4)子类的非静态代码块\"); &#125; public Er()&#123; //super() ==&gt;调用父类的实例初始化方法，而且它在子类实例初始化方法的首行 System.out.println(\"(5)子类的无参构造\"); &#125; public String assign()&#123; System.out.println(\"(6)子类的assign()\"); return \"er\"; &#125;&#125;class Test&#123; public static void main(String[] args)&#123; new Er();//612645 &#125;&#125; 图解： 6.11 面向对象的基本特征之三：多态1、多态： 语法格式： java1父类 引用/变量 = 子类的对象; 2、前提： （1）继承 （2）方法的重写 （3）多态引用 3、现象： ​ 编译时看左边/“父类”，运行时看右边/“子类”。 ​ 编译时，因为按父类编译，那么只能父类有的方法，子类扩展的方法是无法调用的； ​ 执行时一定是运行子类重写的过的方法体。 示例代码： java1234567891011121314151617181920212223242526272829303132333435363738class Person&#123; public void eat()&#123; System.out.println(\"吃饭\"); &#125; public void walk()&#123; System.out.println(\"走路\"); &#125;&#125;class Woman extends Person&#123; public void eat()&#123; System.out.println(\"细嚼慢咽的吃饭\"); &#125; public void walk()&#123; System.out.println(\"婀娜多姿走路\"); &#125; public void shop()&#123; System.out.println(\"买买买...\"); &#125;&#125;class Man extends Person&#123; public void eat()&#123; System.out.println(\"狼吞虎咽的吃饭\"); &#125; public void walk()&#123; System.out.println(\"大摇大摆的走路\"); &#125; public void smoke()&#123; System.out.println(\"吞云吐雾\"); &#125;&#125;class Test&#123; public static void main(String[] args)&#123; Person p = new Woman();//多态引用 p.eat();//执行子类重写 p.walk();//执行子类重写 //p.shop();//无法调用 &#125;&#125; 4、应用： （1）多态参数：形参是父类，实参是子类对象 （2）多态数组：数组元素类型是父类，元素存储的是子类对象 示例代码：多态参数 java12345678910class Test&#123; public static void main(String[] args)&#123; test(new Woman());//实参是子类对象 test(new Man());//实参是子类对象 &#125; public static void test(Person p)&#123;//形参是父类类型 p.eat(); p.walk(); &#125;&#125; 示例代码：多态数组 java123456789101112class Test&#123; public static void main(String[] args)&#123; Person[] arr = new Person[2];//多态数组 arr[0] = new Woman(); arr[1] = new Man(); for(int i=0; i&lt;arr.length; i++)&#123; all[i].eat(); all[i].walk(); &#125; &#125;&#125; 5、向上转型与向下转型：父子类之间的转换 （1）向上转型：自动类型转换 ​ 当把子类的对象赋值给父类的变量时（即多态引用时），在编译时，这个对象就向上转型为父类。此时就看不见子类“特有、扩展”的方法。 （2）向下转型：强制转换。有风险，可能会报ClassCastException异常。 ​ 当需要把父类的变量赋值给一个子类的变量时，就需要向下转型。 ​ 要想转型成功，必须保证该变量中保存的对象的运行时类型是&lt;=强转的类型 示例代码： java123456789class Person&#123; //方法代码省略...&#125;class Woman extends Person&#123; //方法代码省略...&#125;class ChineseWoman extends Woman&#123; //方法代码省略...&#125; java123456789101112131415public class Test&#123; public static void main(String[] args)&#123; //向上转型 Person p1 = new Woman(); //向下转型 Woman m = (Woman)p1; //p1变量中实际存储的对象就是Woman类型，和强转的Woman类型一样 //向上转型 Person p2 = new ChineseWoman(); //向下转型 Woman w2 = (Woman) p2; //p2变量中实际存储的对象是ChineseWoman类型，强制的类型是Woman，ChineseWoman&lt;Woman类型 &#125;&#125; 6、instanceof 表达式语法格式： java1对象/变量 instanceof 类型 运算结果：true 或 false 作用： 用来判断这个对象是否属于这个类型，或者说，是否是这个类型的对象或这个类型子类的对象 示例代码： java123456789class Person&#123; //方法代码省略...&#125;class Woman extends Person&#123; //方法代码省略...&#125;class ChineseWoman extends Woman&#123; //方法代码省略...&#125; java1234567891011121314151617public class Test&#123; public static void main(String[] args)&#123; Person p = new Person(); Woman w = new Woman(); ChineseWoman c = new ChineseWoman(); if(p instanceof Woman)&#123;//false &#125; if(w instanceof Woman)&#123;//true &#125; if(c instanceof Woman)&#123;//true &#125; &#125;&#125; 第七章 面向对象的高级特性修饰符的学习围绕三个问题： （1）单词的意思 （2）可以修饰什么？ （3）用它修饰后有什么不同？ 7.1 关键字：finalfinal：最终的 用法： （1）修饰类（包括外部类、内部类类） 表示这个类不能被继承，没有子类 （2）修饰方法 表示这个方法不能被重写 （3）修饰变量（成员变量（类变量、实例变量），局部变量） 表示这个变量的值不能被修改 注意：如果某个成员变量用final修饰后，也得手动赋值，而且这个值一旦赋完，就不能修改了，即没有set方法 7.2 关键字：nativenative：本地的，原生的用法： ​ 只能修饰方法 ​ 表示这个方法的方法体代码不是用Java语言实现的。 ​ 但是对于Java程序员来说，可以当做Java的方法一样去正常调用它，或者子类重写它。 JVM内存的管理： 方法区：类的信息、常量、静态变量、动态编译生成的字节码信息 虚拟机栈：Java语言实现的方法的局部变量 本地方法栈：非Java语言实现的方法的局部变量，即native方法执行时的内存区域 堆：new出来的对象 程序计数器：记录每一个线程目前执行到哪一句指令 7.3 关键字：staticstatic：静态的 用法： 1、成员方法：我们一般称为静态方法或类方法 （1）不能被重写 （2）被使用 本类中：其他方法中可以直接使用它 其他类中：可以使用“类名.方法”进行调用，也可以使用”对象名.方法”，推荐使用“类名.方法” （3）在静态方法中，我们不能出现：this，super，非静态的成员 2、成员变量：我们一般称为静态变量或类变量 （1）静态变量的值是该类所有对象共享的 （2）静态变量存储在方法区 （3）静态变量对应的get/set也是静态的 （4）静态变量与局部变量同名时，就可以使用“类名.静态变量”进行区分 3、内部类：后面讲 4、代码块：静态代码块 5、静态导入（JDK1.5引入） 没有静态导入 java12345678package com.atguigu.utils;public class Utils&#123; public static final int MAX_VALUE = 1000; public static void test()&#123; //... &#125;&#125; java12345678910package com.atguigu.test;import com.atguigu.utils;public class Test&#123; public static void main(String[] args)&#123; System.out.println(Utils.MAX_VALUE); Utils.test(); &#125;&#125; 使用静态导入 java12345678package com.atguigu.utils;public class Utils&#123; public static final int MAX_VALUE = 1000; public static void test()&#123; //... &#125;&#125; java12345678910package com.atguigu.test;import static com.atguigu.utils.Utils.*;public class Test&#123; public static void main(String[] args)&#123; System.out.println(MAX_VALUE); test(); &#125;&#125; 7.4 静态代码块1、语法格式： java12345【修饰符】 class 类名&#123; static&#123; 静态代码块; &#125;&#125; 2、作用： 协助完成类初始化，可以为类变量赋值。 3、类初始化() 类的初始化有： ①静态变量的显式赋值代码 ②静态代码块中代码 其中①和②按顺序执行 注意：类初始化方法，一个类只有一个 4、类的初始化的执行特点： （1）每一个类的()只执行一次 （2）如果一个子类在初始化时，发现父类也没有初始化，会先初始化父类 （3）如果既要类初始化又要实例化初始化，那么一定是先完成类初始化的 7.5 变量的分类与区别1、变量按照数据类型分： （1）基本数据类型的变量，里面存储数据值 （2）引用数据类型的变量，里面存储对象的地址值 java12345int a = 10;//a中存储的是数据值Student stu = new Student();//stu存储的是对象的地址值int[] arr = new int[5];//arr存储的是数组对象的地址值String str = \"hello\";//str存储的是\"hello\"对象的地址值 2、变量按照声明的位置不同： （1）成员变量 （2）局部变量 3、成员变量与局部变量的区别 （1）声明的位置不同 成员变量：类中方法外 局部变量：（1）方法的()中，即形参（2）方法体的{}的局部变量（3）代码块{}中 （2）存储的位置不同 成员变量： ​ 如果是静态变量（类变量），在方法区中 ​ 如果是非静态的变量（实例变量），在堆中 局部变量：栈 （3）修饰符不同 成员变量：4种权限修饰符、static、final。。。。 局部变量：只有final （4）生命周期 成员变量： ​ 如果是静态变量（类变量），和类相同 ​ 如果是非静态的变量（实例变量），和所属的对象相同，每一个对象是独立 局部变量：每次执行都是新的 （5）作用域 成员变量： ​ 如果是静态变量（类变量），在本类中随便用，在其他类中使用“类名.静态变量” ​ 如果是非静态的变量（实例变量），在本类中只能在非静态成员中使用，在其他类中使用“对象名.非静态的变量” 局部变量：有作用域 7.7 根父类1、java.lang.Object类是类层次结构的根父类。包括数组对象。 （1）Object类中声明的所有的方法都会被继承到子类中，那么即所有的对象，都拥有Object类中的方法 （2）每一个对象的创建，最终都会调用到Object实例初始化方法() （3）Object类型变量、形参、数组，可以存储任意类型的对象 2、Object类的常用方法 （1）public String toString()： ①默认情况下，返回的是“对象的运行时类型 @ 对象的hashCode值的十六进制形式” ②通常是建议重写，如果在eclipse中，可以用Alt +Shift + S–&gt;Generate toString() ③如果我们直接System.out.println(对象)，默认会自动调用这个对象的toString() （2）public final Class&lt;?&gt; getClass()：获取对象的运行时类型 （3）protected void finalize()：当对象被GC确定为要被回收的垃圾，在回收之前由GC帮你调用这个方法。而且这个方法只会被调用一次。子类可以选择重写。 （4）public int hashCode()：返回每个对象的hash值。 规定：①如果两个对象的hash值是不同的，那么这两个对象一定不相等； ​ ②如果两个对象的hash值是相同的，那么这两个对象不一定相等。 主要用于后面当对象存储到哈希表等容中时，为了提高性能用的。 （5）public boolean equals(Object obj)：用于判断当前对象this与指定对象obj是否“相等” ①默认情况下，equals方法的实现等价于与“==”，比较的是对象的地址值 ②我们可以选择重写，重写有些要求： A：如果重写equals，那么一定要一起重写hashCode()方法，因为规定： ​ a：如果两个对象调用equals返回true，那么要求这两个对象的hashCode值一定是相等的； ​ b：如果两个对象的hashCode值不同的，那么要求这个两个对象调用equals方法一定是false； ​ c：如果两个对象的hashCode值相同的，那么这个两个对象调用equals可能是true，也可能是false B：如果重写equals，那么一定要遵循如下几个原则： ​ a：自反性：x.equals(x)返回true ​ b：传递性：x.equals(y)为true, y.equals(z)为true，然后x.equals(z)也应该为true ​ c：一致性：只要参与equals比较的属性值没有修改，那么无论何时调用结果应该一致 ​ d：对称性：x.equals(y)与y.equals(x)结果应该一样 ​ e：非空对象与null的equals一定是false 7.8 关键字：abstract1、什么时候会用到抽象方法和抽象类？ 当声明父类的时候，在父类中某些方法的方法体的实现不能确定，只能由子类决定。但是父类中又要体现子类的共同的特征，即它要包含这个方法，为了统一管理各种子类的对象，即为了多态的应用。 那么此时，就可以选择把这样的方法声明为抽象方法。如果一个类包含了抽象方法，那么这个类就必须是个抽象类。 2、抽象类的语法格式 java123456【权限修饰符】 abstract class 类名&#123; &#125;【权限修饰符】 abstract class 类名 extends 父类&#123; &#125; 3、抽象方法的语法格式 java1【其他修饰符】 abstract 返回值类型 方法名(【形参列表】); 抽象方法没有方法体 4、抽象类的特点 （1）抽象类不能直接实例化，即不能直接new对象 （2）抽象类就是用来被继承的，那么子类继承了抽象类后，必须重写所有的抽象方法，否则这个子类也得是抽象类 （3）抽象类也有构造器，这个构造的作用不是创建抽象类自己的对象用的，给子类在实例化过程中调用； （4）抽象类也可以没有抽象方法，那么目的是不让你创建对象，让你创建它子类的对象 （5）抽象类的变量与它子类的对象也构成多态引用 5、不能和abstract一起使用的修饰符？ （1）final：和final不能一起修饰方法和类 （2）static：和static不能一起修饰方法 （3）native：和native不能一起修饰方法 （4）private：和private不能一起修饰方法 7.9 接口1、接口的概念 接口是一种标准。注意关注行为标准（即方法）。 面向对象的开发原则中有一条：面向接口编程。 2、接口的声明格式 java123【修饰符】 interface 接口名&#123; 接口的成员列表;&#125; 3、类实现接口的格式 java1234567【修饰符】 class 实现类 implements 父接口们&#123; &#125;【修饰符】 class 实现类 extends 父类 implements 父接口们&#123; &#125; 4、接口继承接口的格式 java123【修饰符】 interface 接口名 extends 父接口们&#123; 接口的成员列表;&#125; 5、接口的特点 （1）接口不能直接实例化，即不能直接new对象 （2）只能创建接的实现类对象，那么接口与它的实现类对象之间可以构成多态引用。 （3）实现类在实现接口时，必须重写所有抽象的方法，否则这个实现类也得是抽象类。 （4）Java规定类与类之间，只能是单继承，但是Java的类与接口之间是多实现的关系，即一个类可以同时实现多个接口 （5）Java还支持接口与接口之间的多继承。 6、接口的成员 JDK1.8之前： （1）全局的静态的常量：public static final，这些修饰符可以省略 （2）公共的抽象方法：public abstract，这些修饰符也可以省略 JDK1.8之后： （3）公共的静态的方法：public static ,这个就不能省略了 （4）公共的默认的方法：public default，这个就不能省略了 7、默认方法冲突问题 （1） 当一个实现类同时实现了两个或多个接口，这个多个接口的默认方法的签名相同。 解决方案： 方案一：选择保留其中一个 java1接口名.super.方法名(【实参列表】); 方案二：完全重写 （2）当一个实现类同时继承父类，又实现接口，父类中有一个方法与接口的默认方法签名相同 解决方案： 方案一：默认方案，保留父类的 方案二：选择保留接口的 java1接口名.super.方法名(【实参列表】); 方案三：完全重写 8、示例代码 java1234public interface Flyable&#123; long MAX_SPEED = 7900000; void fly();&#125; java12345public class Bird implements Flyable&#123; public void fly()&#123; //.... &#125;&#125; 9、常用的接口 （1）java.lang.Comparable接口：自然排序 ​ 抽象方法：int compareTo(Object obj) （2）java.util.Comparator接口：定制排序 ​ 抽象方法：int compare(Object obj1 ,Object obj2) （3）示例代码 如果员工类型，默认顺序，自然顺序是按照编号升序排列，那么就实现Comparable接口 java123456789101112class Employee implements Comparable&#123; private int id; private String name; private double salary; //省略了构造器，get/set,toString @Override public int compareTo(Object obj)&#123; return id - ((Employee)obj).id; &#125;&#125; 如果在后面又发现有新的需求，想要按照薪资排序，那么只能选择用定制排序，实现Comparator接口 java123456789101112class SalaryComparator implements Comparator&#123; public int compare(Object o1, Object o2)&#123; Employee e1 = (Employee)o1; Employee e2 = (Employee)o2; if(e1.getSalary() &gt; e2.getSalary())&#123; return 1; &#125;else if(e1.getSalary() &lt; e2.getSalary())&#123; return -1; &#125; return 0; &#125;&#125; 7.10 内部类1、内部类的概念 声明在另外一个类里面的类就是内部类。 2、内部类的4种形式 （1）静态内部类 （2）非静态成员内部类 （3）有名字的局部内部类 （4）匿名内部类 7.10.1 匿名内部类1、语法格式： java1234567891011121314//在匿名子类中调用父类的无参构造new 父类()&#123; 内部类的成员列表&#125;//在匿名子类中调用父类的有参构造new 父类(实参列表)&#123; 内部类的成员列表&#125;//接口没有构造器，那么这里表示匿名子类调用自己的无参构造，调用默认父类Object的无参构造new 父接口名()&#123; &#125; 2、匿名内部类、匿名对象的区别？ java1234567891011121314151617System.out.println(new Student(\"张三\"));//匿名对象Student stu = new Student(\"张三\");//这个对象有名字，stu//既有匿名内部类，又是一个匿名的对象new Object()&#123; public void test()&#123; ..... &#125;&#125;.test();//这个匿名内部类的对象，使用obj这个名字引用它，既对象有名字，但是这个Object的子类没有名字Object obj = new Object()&#123; public void test()&#123; ..... &#125;&#125;; 3、使用的形式 （1）示例代码：继承式 java1234567891011121314abstract class Father&#123; public abstract void test();&#125;class Test&#123; public static void main(String[] args)&#123; //用父类与匿名内部类的对象构成多态引用 Father f = new Father()&#123; public void test()&#123; System.out.println(\"用匿名内部类继承了Father这个抽象类，重写了test抽象方法\") &#125; &#125;; f.test(); &#125;&#125; （2）示例代码：实现式 java1234567891011121314interface Flyable&#123; void fly();&#125;class Test&#123; public static void main(String[] args)&#123; //用父接口与匿名内部类的对象构成了多态引用 Flyable f = new Flyable()&#123; public void fly()&#123; System.out.println(\"用匿名内部类实现了Flyable这个接口，重写了抽象方法\"); &#125; &#125;; f.fly(); &#125;&#125; （3）示例代码：用匿名内部类的匿名对象直接调用方法 java12345new Object()&#123; public void test()&#123; System.out.println(\"用匿名内部类的匿名对象直接调用方法\") &#125;&#125;.test(); （4）示例代码：用匿名内部类的匿名对象直接作为实参 java123456789101112131415Student[] all = new Student[3];all[0] = new Student(\"张三\",23);all[1] = new Student(\"李四\",22);all[2] = new Student(\"王五\",20);//用匿名内部类的匿名对象直接作为实参//这个匿名内部类实现了Comparator接口//这个匿名内部类的对象，是定制比较器的对象Arrays.sort(all, new Comparator()&#123; public int compare(Obeject o1, Object o2)&#123; Student s1 = (Student)o1; Student s2 = (Student)o2; return s1.getAge() - s2.getAge(); &#125;&#125;); 7.10.2 静态内部类1、语法格式 java1234567【修饰符】 class 外部类名 【extends 外部类的父类】 【implements 外部类的父接口们】&#123; 【其他修饰符】 static class 静态内部类 【extends 静态内部类自己的父类】 【implements 静态内部类的父接口们】&#123; 静态内部类的成员列表; &#125; 外部类的其他成员列表;&#125; 2、 使用注意事项 （1）包含成员是否有要求： ​ 可以包含类的所有成员 （2）修饰符要求： ​ 权限修饰符：4种 ​ 其他修饰符：abstract、final （3）使用外部类的成员上是否有要求 ​ 只能使用外部类的静态成员 （4）在外部类中使用静态内部类是否有要求 ​ 正常使用 （5）在外部类的外面使用静态内部类是否有要求 java1234567（1）如果使用的是静态内部类的静态成员 外部类名.静态内部类名.静态成员（2）如果使用的是静态内部类的非静态成员 ①先创建静态内部类的对象 外部类名.静态内部类名 对象名 = new 外部类名.静态内部类名(【实参列表】); ②通过对象调用非静态成员 对象名.xxx （6）字节码文件形式：外部类名$静态内部类名.class 3、示例代码 java123456789101112131415161718192021222324252627282930class Outer&#123; private static int i = 10; static class Inner&#123; public void method()&#123; //... System.out.println(i);//可以 &#125; public static void test()&#123; //... System.out.println(i);//可以 &#125; &#125; public void outMethod()&#123; Inner in = new Inner(); in.method(); &#125; public static void outTest()&#123; Inner in = new Inner(); in.method(); &#125;&#125;class Test&#123; public static void main(String[] args)&#123; Outer.Inner.test(); Outer.Inner in = new Outer.Inner(); in.method(); &#125;&#125; 7.10.3 非静态内部类1、语法格式 java1234567【修饰符】 class 外部类名 【extends 外部类的父类】 【implements 外部类的父接口们】&#123; 【修饰符】 class 非静态内部类 【extends 非静态内部类自己的父类】 【implements 非静态内部类的父接口们】&#123; 非静态内部类的成员列表; &#125; 外部类的其他成员列表;&#125; 2、 使用注意事项 （1）包含成员是否有要求： ​ 不允许出现静态的成员 （2）修饰符要求 ​ 权限修饰符：4种 ​ 其他修饰符：abstract，final （3）使用外部类的成员上是否有要求 ​ 都可以使用 （4）在外部类中使用非静态内部类是否有要求 ​ 在外部类的静态成员中不能使用非静态内部类 （5）在外部类的外面使用非静态内部类是否有要求 java12345678910111213//使用非静态内部类的非静态成员//(1)创建外部类的对象外部类名 对象名1 = new 外部类名(【实参列表】);//(2)通过外部类的对象去创建或获取非静态内部类的对象//创建外部类名.非静态内部类名 对象名2 = 对象名1.new 非静态内部类名(【实参列表】);//获取外部类名.非静态内部类名 对象名2 = 对象名1.get非静态内部类对象的方法(【实参列表】);//（3）通过非静态内部类调用它的非静态成员对象名2.xxx （6）字节码文件形式：外部类名$非静态内部类名.class 3、示例代码 java12345678910111213141516171819202122232425262728293031323334class Outer&#123; private static int i = 10; private int j = 20; class Inner&#123; public void method()&#123; //... System.out.println(i);//可以 System.out.println(j);//可以 &#125; &#125; public void outMethod()&#123; Inner in = new Inner(); in.method(); &#125; public static void outTest()&#123; // Inner in = new Inner();//不可以 &#125; public Inner getInner()&#123; return new Inner(); &#125;&#125;class Test&#123; public static void main(String[] args)&#123; Outer out = new Outer(); Outer.Inner in1 = out.new Inner(); //创建 in1.method(); Outer.Inner in2 = out.getInner(); //获取 in2.method(); &#125;&#125; 7.10.4 局部内部类1、语法格式 java12345678【修饰符】 class 外部类名 【extends 外部类的父类】 【implements 外部类的父接口们】&#123; 【修饰符】 返回值类型 方法名(【形参列表】)&#123; 【修饰符】 class 局部内部类 【extends 局部内部类自己的父类】 【implements 局部内部类的父接口们】&#123; 局部内部类的成员列表; &#125; &#125; 外部类的其他成员列表;&#125; 2、 使用注意事项 （1）包含成员是否有要求 ​ 不允许出现静态的成员 （2）修饰符要求 ​ 权限修饰符：不能 ​ 其他修饰符：abstract、final （3）使用外部类的成员等上是否有要求 ​ ①使用外部类的静态成员：随便用 ​ ②使用外部类的非静态成员：能不能用要看所在的方法是否是静态的 ​ ③使用所在方法的局部变量：必须 final修饰的 （4）在外部类中使用局部内部类是否有要求 ​ 有作用域 （5）在外部类的外面使用局部内部类是否有要求 ​ 没法使用 （6）字节码文件形式：外部类名$编号局部内部类名.class 3、示例代码 java123456789101112131415161718192021222324252627282930class Outer&#123; private static int i = 10; private int j = 20; public void outMethod()&#123; class Inner&#123; public void method()&#123; //... System.out.println(i);//可以 System.out.println(j);//可以 &#125; &#125; Inner in = new Inner(); in.method(); &#125; public static void outTest()&#123; final int k = 30; class Inner&#123; public void method()&#123; //... System.out.println(i);//可以 System.out.println(j);//不可以 System.out.println(k);//可以 &#125; &#125; Inner in = new Inner(); in.method(); &#125;&#125; 第八章 枚举与注解8.1 枚举1、枚举（JDK1.5引入的） 枚举类型的对象是有限、固定的几个常量对象。 2、语法格式 java1234567891011//形式一：枚举类型中只有常量对象列表【修饰符】 enum 枚举类型名&#123; 常量对象列表&#125;//形式二：枚举类型中只有常量对象列表【修饰符】 enum 枚举类型名&#123; 常量对象列表; 其他成员列表；&#125; 说明：常量对象列表必须在枚举类型的首行 回忆：首行 （1）super()或super(实参列表)：必须在子类构造器的首行 （2）this()或this(实参列表)：必须在本类构造器的首行 （3）package 包; 声明包的语句必须在源文件.java的代码首行 （4）枚举常量对象列表必须在枚举类型的首行 3、在其他类中如何获取枚举的常量对象 java12345678//获取一个常量对象枚举类型名.常量对象名//获取一个常量对象枚举类型名.valueOf(\"常量对象名\") //获取所有常量对象枚举类型名[] all = 枚举类型名.values(); 4、枚举类型的特点 （1）枚举类型有一个公共的基本的父类，是java.lang.Enum类型，所以不能再继承别的类型 （2）枚举类型的构造器必须是私有的 （3）枚举类型可以实现接口 java12345678910111213141516171819202122interface MyRunnable&#123; void run();&#125;enum Gender implements MyRunnable&#123; NAN,NV; public void run()&#123; //... &#125;&#125;//或enum Gender implements MyRunnable&#123; NAN&#123; public void run()&#123; //... &#125; &#125;,NV&#123; public void run()&#123; //... &#125; &#125;; &#125; 5、父类java.lang.Enum类型 （1）构造器 protected Enum(String name, int ordinal)：由编译器自动调用 （2）String name()：常量对象名 （3）int ordinal()：返回常量对象的序号，第一个的序号是0 （4）String toString()：返回常量对象名，如果子类想重写，需要手动 （5）int compareTo(Object obj)：按照常量对象的顺序比较 8.2 注解1、注解 它是代码级别的注释 2、标记符号：@ 3、系统预定义的三个最基本的注解： （1）@Override：表示某个方法是重写的方法 它只能用在方法上面，会让编译器对这个方法进行格式检查，是否满足重写的要求 （2）@SuppressWarnings(xx)：抑制警告 （3）@Deprecated：表示xx已过时 4、和文档注释相关的注解 （1）文档注释 java123/**文档注释*/ （2）常见的文档注释 @author：作者 @since：从xx版本加入的 @see：另请参考 @param：形参 @return：返回值 @throws或@exception：异常 5、JUnit相关的几个注解 （1）@Test：表示它是一个单元测试方法 这个方法需要是：public void xxx(){} （2）@Before：表示在每一个单元测试方法之前执行 这个方法需要是：public void xxx(){} （3）@After：表示在每一个单元测试方法之后执行 这个方法需要是：public void xxx(){} （4）@BeforeClass：表示在类初始化阶段执行，而且只执行一次 这个方法需要是：public static void xxx(){} （3）@AfterClass：表示在类的“卸载”阶段执行，而且只执行一次 这个方法需要是：public static void xxx(){} 6、元注解 （1）@Target(xx)：用它标记的注解能够用在xx位置 (xx)：由ElementType枚举类型的10个常量对象指定，例如：TYPE，METHOD，FIELD等 例如： java123@Target(ElementType.TYPE)@Target(&#123;ElementType.TYPE,ElementType.METHOD,ElementType.FIELD&#125;) java1234import static java.lang.annotation.ElementType.*;@Target(&#123;TYPE,METHOD,FIELD&#125;) （2）@Retention（xx）：用它标记的注解可以滞留到xx阶段 (xx)：由RetentionPolicy枚举类型的3个常量对象指定，分别是：SOURCE，CLASS，RUNTIME 唯有RUNTIME阶段的注解才能被反射读取到 例如： java1@Retention(RetentionPolicy.RUNTIME) （3）@Documentd：用它标记的注解可以读取到API中 （4）@Inherited：用它标记的注解可以被子类继承 7、自定义注解 java123456789@元注解【修饰符】 @interface 注解名&#123; &#125;@元注解【修饰符】 @interface 注解名&#123; 配置参数列表&#125; 配置参数的语法格式： java12345数据类型 配置参数名();或数据类型 配置参数名() default 默认值; 关于配置参数： （1）配置参数的类型有要求： 八种基本数据类型、String、枚举、Class类型、注解、它们的数组。 （2）如果自定义注解声明了配置参数，那么在使用这个注解时必须为配置参数赋值，除非它有默认值 java1234@自定义注解名(配置参数名1=值，配置参数名2=值。。。)//如果配置参数类型是数组，那么赋值时，可以用&#123;&#125;表示数组@自定义注解名(配置参数名1=&#123;值&#125;，配置参数名2=值。。。) （3）如果配置参数只有一个，并且名称是value，那么赋值时可以省略value= （4）如果读取这个注解时，要获取配置参数的值的话，可以当成方法一样来访问 abnf1自定义注解对象.配置参数(); 第九章 异常9.1 异常的类型的体系结构1、异常系列的超父类：java.lang.Throwable （1）只有它或它子类的对象，才能被JVM或throw语句“抛”出 （2）也只有它或它子类的对象，才能被catch“捕获” 2、Throwable分为两大派别 （1）Error：严重的错误，需要停下来重新设计、升级解决这个问题 （2）Exception： 一般的异常，可以通过判断、检验进行避免，或者使用try…catch进行处理 3、Exception又分为两大类 （1）运行时异常： ​ 它是RuntimeException或它子类的对象。 ​ 这种类型的异常，编译器不会提醒你，要进行throws或try…catch进行处理，但是运行时可能导致崩溃。 （2）编译时异常： ​ 异常除了运行时异常以外的都是编译时异常。 ​ 这种类型的异常，编译器是强制要求你，throws或try…catch进行处理，否则编译不通过。 4、列出常见的异常类型 （1）运行时异常 RuntimeException、NullPointerException（空指针异常），ClassCastException（类型转换异常），ArithmeticException（算术异常），NubmerFormatException（数字格式化异常），IndexOutOfBoundsException（下标越界异常）（ArrayIndexOutOfBoundsException（数组下标越界异常）、StringIndexOutOfBoundsException（字符串下标越界异常））、InputMisMatchException（输入类型不匹配异常）。。。。 （2）编译时异常 FileNotFoundException（文件找不到异常）、IOException（输入输出异常）、SQLException（数据库sql语句执行异常）。。。 9.2 异常的处理1、在当前方法中处理：try…catch…finally java12345678910111213141516171819202122232425262728//形式一：try...catchtry&#123; 可能发生异常的代码&#125;catch(异常类型 异常名e)&#123; 处理异常的代码（一般都是打印异常的信息的语句）&#125;catch(异常类型 异常名e)&#123; 处理异常的代码（一般都是打印异常的信息的语句）&#125;。。。//形式二：try...finallytry&#123; 可能发生异常的代码&#125;finally&#123; 无论try中是否有异常，也不管是不是有return，都要执行的部分&#125;//形式三：try..catch..finallytry&#123; 可能发生异常的代码&#125;catch(异常类型 异常名e)&#123; 处理异常的代码（一般都是打印异常的信息的语句）&#125;catch(异常类型 异常名e)&#123; 处理异常的代码（一般都是打印异常的信息的语句）&#125;。。。finally&#123; 无论try中是否有异常，也不管catch是否可以捕获异常，也不管try和catch中是不是有return，都要执行的部分&#125; 执行特点： （1）如果try中的代码没有异常，那么try中的代码会正常执行，catch部分就不执行，finally中会执行 （2）如果try中的代码有异常，那么try中发生异常的代码的后面就不执行了，找对应的匹配的catch分支执行，finally中会执行 2、finally与return混合使用时 （1）如果finally中有return，一定从finally中的return返回。 此时try和catch中的return语句，执行了一半，执行了第一个动作。所以，finally中的return语句会覆盖刚刚的返回值 return 返回值; 语句有两个动作：（1）把返回值放到“操作数栈”中，等当前方法结束后，这个“操作数栈”中的值会返回给调用处（2）结束当前方法的执行 （2）如果finally中没有return，finally中的语句会执行，但是不影响最终的返回值 即try和catch中的return语句两步拆开来走，先把（1）把返回值放到“操作数栈”中，（2）然后走finally中的语句（3）再执行return后半个动作，结束当前方法 3、在当前方法中不处理异常，明确要抛给调用者处理，使用throws 语法格式： java123【修饰符】 返回值类型 方法名(【形参列表】) throws 异常列表&#123; &#125; 此时调用者，就知道需要处理哪些异常。 方法的重写的要求： （1）方法名：相同 （2）形参列表：相同 （3）返回值类型： ​ 基本数据类型和void：相同 ​ 引用数据类型：&lt;= （4）修饰符： ​ 权限修饰符：&gt;= ​ 其他修饰符：static，final，private不能被重写 （5）throws：&lt;= 方法的重载： （1）方法名：相同 （2）形参列表：必须不同 （3）返回值类型：无关 （4）修饰符：无关 （5）throws：无关 9.3 手动抛出异常：throwjava1234throw 异常对象;//例如：throw new AccountException(\"xxx\"); throw抛出来的异常对象，和JVM抛出来的异常对象一样，也要用try..catch处理或者throws。 如果是运行时异常，编译器不会强制要求你处理，如果是编译时异常，那么编译器会强制要求你处理。 9.4 自定义异常1、必须继承Throwable或它的子类 我们见到比较多的是继承RuntimeException和Exception. 如果你继承RuntimeException或它的子类，那么你自定义的这个异常就是运行时异常。编译器就不会提醒你处理。 如果你继承Exception，那么它属于编译时异常，编译器会强制你处理。 2、建议大家保留两个构造器 java123456789//无参构造public 自定义异常名()&#123; &#125;//有参构造public 自定义异常名(String message)&#123; super(message);&#125; 3、自定义异常对象，必须手动抛出，用throw抛出 9.5 关于异常的几个方法（1）e.printStackTrace()：打印异常对象的详细信息，包括异常类型，message，堆栈跟踪信息。这个对于调试，或者日志跟踪是非常有用的 （2）e.getMessage()：只是获取异常的message信息 关于异常信息的打印： 用System.err打印和用e.printStackTrace()都是会标记红色的突出。 用System.out打印，当成普通信息打印。 这两个打印是两个独立的线程，顺序是不能精确控制的。 第十章 多线程10.1 相关的概念1、程序（Program） ​ 为了实现一个功能，完成一个任务而选择一种编程语言编写的一组指令的集合。 2、进程（Process） ​ 程序的一次运行。操作系统会给这个进程分配资源（内存）。 ​ 进程是操作系统分配资源的最小单位。 ​ 进程与进程之间的内存是独立，无法直接共享。 ​ 最早的DOS操作系统是单任务的，同一时间只能运行一个进程。后来现在的操作系统都是支持多任务的，可以同时运行多个进程。进程之间来回切换。成本比较高。 3、线程（Thread） ​ 线程是进程中的其中一条执行路径。一个进程中至少有一个线程，也可以有多个线程。有的时候也把线程称为轻量级的进程。 ​ 同一个进程的多个线程之间有些内存是可以共享的（方法区、堆），也有些内存是独立的（栈（包括虚拟机栈和本地方法栈）、程序计数器）。 ​ 线程之间的切换相对进程来说成本比较低。 4、并行： 多个处理器同时可以执行多条执行路径。 5、并发：多个任务同时执行，但是可能存在先后关系。 10.2 两种实现多线程的方式1、继承Thread类 步骤： （1）编写线程类，去继承Thread类 （2）重写public void run(){} （3）创建线程对象 （4）调用start() java12345678910111213141516171819202122232425262728class MyThread extends Thread &#123; public void run()&#123; //... &#125;&#125;class Test&#123; public static void main(String[] args)&#123; MyThread my = new MyThread(); my.start();//有名字的线程对象启动 new MyThread().start();//匿名线程对象启动 //匿名内部类的匿名对象启动 new Thread()&#123; public void run()&#123; //... &#125; &#125;.start(); //匿名内部类，但是通过父类的变量多态引用，启动线程 Thread t = new Thread()&#123; public void run()&#123; //... &#125; &#125;; t.start(); &#125;&#125; 2、实现Runnable接口 步骤： （1）编写线程类，实现Runnable接口 （2）重写public void run(){} （3）创建线程对象 （4）借助Thread类的对象启动线程 java12345678910111213141516171819202122232425class MyRunnable implements Runnable&#123; public void run()&#123; //... &#125;&#125;class Test &#123; public static void main(String[] args)&#123; MyRunnable my = new MyRunnable(); Thread t1 = new Thread(my); Thread t2 = new Thread(my); t1.start(); t2.start(); //两个匿名对象 new Thread(new MyRunnable()).start(); //匿名内部类的匿名对象作为实参直接传给Thread的构造器 new Thread(new Runnable()&#123; public void run()&#123; //... &#125; &#125;).start(); &#125;&#125; 10.3 线程的生命周期 10.4 Thread的相关API1、构造器 Thread() Thread(String name) Thread(Runnable target) Thread(Runnable target, String name) 2、其他方法 （1）public void run() （2）public void start() （3）获取当前线程对象：Thread.currentThread() （4）获取当前线程的名称：getName() （5）设置或获取线程的优先级：set/getPriority() 优先级的范围：[1,10]，Thread类中有三个常量：MAX_PRIORITY(10)，MIN_PRIORITY(1)，NORM_PRIORITY(5) 优先级只是影响概率。 （6）线程休眠：Thread.sleep(毫秒) （7）打断线程：interrupt() （8）暂停当前线程：Thread.yield() （9）线程要加塞：join() xx.join()这句代码写在哪个线程体中，哪个线程被加塞，和其他线程无关。 （10）判断线程是否已启动但未终止：isAlive() 10.5 关键字：volatilevolatile：易变，不稳定，不一定什么时候会变 修饰：成员变量 作用：当多个线程同时去访问的某个成员变量时，而且是频繁的访问，再多次访问时，发现它的值没有修改，Java执行引擎就会对这个成员变量的值进行缓存。一旦缓存之后，这个时候如果有一个线程把这个成员变量的值修改了，Jav执行引擎还是从缓存中读取，导致这个值不是最新的。如果不希望Java执行引擎把这个成员变的值缓存起来，那么就可以在成员变量的前面加volatile，每次用到这个成员变量时，都是从主存中读取。 10.6 关键字：synchronized（同步）1、什么情况下会发生线程安全问题？ （1）多个线程 （2）共享数据 （3）多个线程的线程体中，多条语句再操作这个共享数据时 2、如何解决线程安全问题？同步锁 形式一：同步代码块 形式二：同步方法 3、同步代码块 java123synchronized(锁对象)&#123; //一次任务代码，这其中的代码，在执行过程中，不希望其他线程插一脚&#125; 锁对象： （1）任意类型的对象 （2）确保使用共享数据的这几个线程，使用同一个锁对象 4、同步方法 java123synchronized 【修饰符】 返回值类型 方法名(【形参列表】)throws 异常列表&#123; //同一时间，只能有一个线程能进来运行&#125; 锁对象： （1）非静态方法：this（谨慎） （2）静态方法：当前类的Class对象 10.7 线程通信1、为了解决“生产者与消费者问题”。 当一些线程负责往“数据缓冲区”放数据，另一个线程负责从“数据缓冲区”取数据。 问题1：生产者线程与消费者线程使用同一个数据缓冲区，就是共享数据，那么要考虑同步 问题2：当数据缓冲区满的时候，生产者线程需要wait()， 当消费者消费了数据后，需要notify或notifyAll ​ 当数据缓冲区空的时候，消费者线程需要wait()， 当生产者生产了数据后，需要notify或notifyAll 2、java.lang.Object类中声明了： （1）wait()：必须由“同步锁”对象调用 （2）notfiy()和notifyAll()：必须由“同步锁”对象调用 3、面试题：sleep()和wait的区别 （1）sleep()不释放锁，wait()释放锁 （2）sleep()在Thread类中声明的，wait()在Object类中声明 （3）sleep()是静态方法，是Thread.sleep() ​ wait()是非静态方法，必须由“同步锁”对象调用 （4）sleep()方法导致当前线程进入阻塞状态后，当时间到或interrupt()醒来 ​ wait()方法导致当前线程进入阻塞状态后，由notify或notifyAll() 4、哪些操作会释放锁？ （1）同步代码块或同步方法正常执行完一次自动释放锁 （2）同步代码块或同步方法遇到return等提前结束 （3）wait() 5、不释放锁 （1）sleep() （2）yield() （3）suspend() 第十一章 常用类11.1 包装类11.1.1 包装类当要使用只针对对象设计的API或新特性（例如泛型），那么基本数据类型的数据就需要用包装类来包装。 序号 基本数据类型 包装类 1 byte Byte 2 short Short 3 int Integer 4 long Long 5 float Float 6 double Double 7 char Character 8 boolean Boolean 9 void Void 11.1.2 装箱与拆箱JDK1.5之后，可以自动装箱与拆箱。 注意：只能与自己对应的类型之间才能实现自动装箱与拆箱。 java12Integer i = 1;Double d = 1;//错误的，1是int类型 装箱：把基本数据类型转为包装类对象。 转为包装类的对象，是为了使用专门为对象设计的API和特性 拆箱：把包装类对象拆为基本数据类型。 转为基本数据类型，一般是因为需要运算，Java中的大多数运算符是为基本数据类型设计的。比较、算术等 总结：对象（引用数据类型）能用的运算符有哪些？ （1）instanceof （2）=：赋值运算符 （3）==和!=：用于比较地址，但是要求左右两边对象的类型一致或者是有父子类继承关系。 （4）对于字符串这一种特殊的对象，支持“+”，表示拼接。 11.1.3 包装类的一些API1、基本数据类型和字符串之间的转换 （1）把基本数据类型转为字符串 java123456int a = 10;//String str = a;//错误的//方式一：String str = a + \"\";//方式二：String str = String.valueOf(a); （2）把字符串转为基本数据类型 java123int a = Integer.parseInt(\"整数的字符串\");double a = Double.parseDouble(\"小数的字符串\");boolean b = Boolean.parseBoolean(\"true或false\"); 2、数据类型的最大最小值 java123Integer.MAX_VALUE和Integer.MIN_VALUELong.MAX_VALUE和Long.MIN_VALUEDouble.MAX_VALUE和Double.MIN_VALUE 3、转大小写 java12Character.toUpperCase('x');Character.toLowerCase('X'); 4、转进制 java123Integer.toBinaryString(int i) Integer.toHexString(int i)Integer.toOctalString(int i) 11.1.4 包装类对象的缓存问题 包装类 缓存对象 Byte -128~127 Short -128~127 Integer -128~127 Long -128~127 Float 没有 Double 没有 Character 0~127 Boolean true和false java12345678910111213141516171819Integer i = 1;Integer j = 1;System.out.println(i == j);//trueInteger i = 128;Integer j = 128;System.out.println(i == j);//falseInteger i = new Integer(1);//新new的在堆中Integer j = 1;//这个用的是缓冲的常量对象，在方法区System.out.println(i == j);//falseInteger i = new Integer(1);//新new的在堆中Integer j = new Integer(1);//另一个新new的在堆中System.out.println(i == j);//falseInteger i = new Integer(1);int j = 1;System.out.println(i == j);//true，凡是和基本数据类型比较，都会先拆箱，按照基本数据类型的规则比较 11.2 字符串11.2.1 字符串的特点1、字符串String类型本身是final声明的，意味着我们不能继承String。 2、字符串的对象也是不可变对象，意味着一旦进行修改，就会产生新对象 我们修改了字符串后，如果想要获得新的内容，必须重新接受。 如果程序中涉及到大量的字符串的修改操作，那么此时的时空消耗比较高。可能需要考虑使用StringBuilder或StringBuffer。 3、String对象内部是用字符数组进行保存的 JDK1.9之前有一个char[] value数组，JDK1.9之后byte[]数组 4、String类中这个char[] values数组也是final修饰的，意味着这个数组不可变，然后它是private修饰，外部不能直接操作它，String类型提供的所有的方法都是用新对象来表示修改后内容的，所以保证了String对象的不可变。 5、就因为字符串对象设计为不可变，那么所以字符串有常量池来保存很多常量对象 常量池在方法区。 如果细致的划分： （1）JDK1.6及其之前：方法区 （2）JDK1.7：堆 （3）JDK1.8：元空间 11.2.2 字符串对象的比较1、==：比较是对象的地址 只有两个字符串变量都是指向字符串的常量对象时，才会返回true java123String str1 = \"hello\";String str2 = \"hello\";str1 == str2//true 2、equals：比较是对象的内容，因为String类型重写equals，区分大小写 只要两个字符串的字符内容相同，就会返回true java123String str1 = new String(\"hello\");String str2 = new String(\"hello\");str1.equals(strs) //true 3、equalsIgnoreCase：比较的是对象的内容，不区分大小写 java123String str1 = new String(\"hello\");String str2 = new String(\"HELLO\");str1.equalsIgnoreCase(strs) //true 4、compareTo：String类型重写了Comparable接口的抽象方法，自然排序，按照字符的Unicode编码值进行比较大小的，严格区分大小写 java123String str1 = \"hello\";String str2 = \"world\";str1.compareTo(str2) //小于0的值 5、compareToIgnoreCase：不区分大小写，其他按照字符的Unicode编码值进行比较大小 java123String str1 = new String(\"hello\");String str2 = new String(\"HELLO\");str1.compareToIgnoreCase(str2) //等于0 11.2.3 空字符的比较1、哪些是空字符串 java123String str1 = \"\";String str2 = new String();String str3 = new String(\"\"); 空字符串：长度为0 2、如何判断某个字符串是否是空字符串 java1234567if(\"\".equals(str))if(str!=null &amp;&amp; str.isEmpty())if(str!=null &amp;&amp; str.equals(\"\"))if(str!=null &amp;&amp; str.length()==0) 11.2.4 字符串的对象的个数1、字符串常量对象 java1String str1 = \"hello\";//1个，在常量池中 2、字符串的普通对象 java123String str2 = new String();String str22 = new String(\"\");//两个对象，一个是常量池中的空字符串对象，一个是堆中的空字符串对象 3、字符串的普通对象和常量对象一起 java12String str3 = new String(\"hello\");//str3首先指向堆中的一个字符串对象，然后堆中字符串的value数组指向常量池中常量对象的value数组 11.2.5 字符串拼接结果原则： （1）常量+常量：结果是常量池 （2）常量与变量 或 变量与变量：结果是堆 （3）拼接后调用intern方法：结果在常量池 java123456789101112131415161718192021222324252627282930313233343536373839404142@Testpublic void test06()&#123; String s1 = \"hello\"; String s2 = \"world\"; String s3 = \"helloworld\"; String s4 = (s1 + \"world\").intern();//把拼接的结果放到常量池中 String s5 = (s1 + s2).intern(); System.out.println(s3 == s4);//true System.out.println(s3 == s5);//true&#125;@Testpublic void test05()&#123; final String s1 = \"hello\"; final String s2 = \"world\"; String s3 = \"helloworld\"; String s4 = s1 + \"world\";//s4字符串内容也helloworld，s1是常量，\"world\"常量，常量+ 常量 结果在常量池中 String s5 = s1 + s2;//s5字符串内容也helloworld，s1和s2都是常量，常量+ 常量 结果在常量池中 String s6 = \"hello\" + \"world\";//常量+ 常量 结果在常量池中，因为编译期间就可以确定结果 System.out.println(s3 == s4);//true System.out.println(s3 == s5);//true System.out.println(s3 == s6);//true&#125;@Testpublic void test04()&#123; String s1 = \"hello\"; String s2 = \"world\"; String s3 = \"helloworld\"; String s4 = s1 + \"world\";//s4字符串内容也helloworld，s1是变量，\"world\"常量，变量 + 常量的结果在堆中 String s5 = s1 + s2;//s5字符串内容也helloworld，s1和s2都是变量，变量 + 变量的结果在堆中 String s6 = \"hello\" + \"world\";//常量+ 常量 结果在常量池中，因为编译期间就可以确定结果 System.out.println(s3 == s4);//false System.out.println(s3 == s5);//false System.out.println(s3 == s6);//true&#125; 11.2.6 字符串的API（1）boolean isEmpty() （2）int length() （3）String concat(xx)：拼接，等价于+ （4）boolean contanis(xx) （5）int indexOf()：从前往后找，要是没有返回-1 （6）int lastIndexOf()：从后往前找，要是没有返回-1 （7）char charAt(index) （8）new String(char[] ) 或new String(char[] ,int, int) （9）char[] toCharArray() （10）byte[] getBytes()：编码，把字符串变为字节数组，按照平台默认的字符编码进行编码 ​ byte[] getBytes(字符编码方式)：按照指定的编码方式进行编码 （11）new String(byte[] ) 或 new String(byte[], int, int)：解码，按照平台默认的字符编码进行解码 ​ new String(byte[]，字符编码方式 ) 或 new String(byte[], int, int，字符编码方式)：解码，按照指定的编码方式进行解码 （12）String subString(int begin)：从[begin]开始到最后 String subString(int begin,int end)：从[begin, end) （13）boolean matchs(正则表达式) （14）String replace(xx,xx)：不支持正则 String replaceFirst(正则，value)：替换第一个匹配部分 String repalceAll(正则， value)：替换所有匹配部分 （15）String[] split(正则)：按照某种规则进行拆分 （16）boolean startsWith(xx)：是否以xx开头 boolean endsWith(xx)：是否以xx结尾 （17）String trim()：去掉前后空白符，字符串中间的空白符不会去掉 （18）String toUpperCase()：转大写 （19）String toLowerCase()：转小写 面试题：字符串的length和数组的length有什么不同？ 字符串的length()，数组的length属性 11.3 可变字符序列1、可变字符序列：StringBuilder和StringBuffer StringBuffer：老的，线程安全的（因为它的方法有synchronized修饰） StringBuilder：线程不安全的 2、面试题：String和StringBuilder、StringBuffer的区别？ String：不可变对象，不可变字符序列 StringBuilder、StringBuffer： 可变字符序列 3、常用的API，StringBuilder、StringBuffer的API是完全一致的 （1）append(xx)：拼接，追加 （2）insert(int index, xx)：插入 （3）delete(int start, int end) deleteCharAt(int index) （4）set(int index, xx) （5）reverse()：反转 …. 替换、截取、查找… 11.4 和数学相关的1、java.lang.Math类 （1）sqrt()：求平方根 （2）pow(x,y)：求x的y次方 （3）random()：返回[0,1)范围的小数 （4）max(x,y)：找x,y最大值 ​ min(x,y)：找最小值 （5）round(x)：四舍五入 ​ ceil(x)：进一 ​ floor(x)：退一 ….. 2、java.math包 BigInteger：大整数 BigDecimal：大小数 运算通过方法完成：add(),subtract(),multiply(),divide()…. 11.5 日期时间API11.5.1 JDK1.8之前1、java.util.Date new Date()：当前系统时间 long getTime()：返回该日期时间对象距离1970-1-1 0.0.0 0毫秒之间的毫秒值 new Date(long 毫秒)：把该毫秒值换算成日期时间对象 2、java.util.Calendar： （1）getInstance()：得到Calendar的镀锡 （2）get(常量) 3、java.text.SimpleDateFormat：日期时间的格式化 y：表示年 M：月 d：天 H： 小时，24小时制 h：小时，12小时制 m：分 s：秒 S：毫秒 E：星期 D：年当中的天数 java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081@Testpublic void test10() throws ParseException&#123; String str = \"2019年06月06日 16时03分14秒 545毫秒 星期四 +0800\"; SimpleDateFormat sf = new SimpleDateFormat(\"yyyy年MM月dd日 HH时mm分ss秒 SSS毫秒 E Z\"); Date d = sf.parse(str); System.out.println(d);&#125;@Testpublic void test9()&#123; Date d = new Date(); SimpleDateFormat sf = new SimpleDateFormat(\"yyyy年MM月dd日 HH时mm分ss秒 SSS毫秒 E Z\"); //把Date日期转成字符串，按照指定的格式转 String str = sf.format(d); System.out.println(str);&#125;@Testpublic void test8()&#123; String[] all = TimeZone.getAvailableIDs(); for (int i = 0; i &lt; all.length; i++) &#123; System.out.println(all[i]); &#125;&#125;@Testpublic void test7()&#123; TimeZone t = TimeZone.getTimeZone(\"America/Los_Angeles\"); //getInstance(TimeZone zone) Calendar c = Calendar.getInstance(t); System.out.println(c);&#125;@Testpublic void test6()&#123; Calendar c = Calendar.getInstance(); System.out.println(c); int year = c.get(Calendar.YEAR); System.out.println(year); int month = c.get(Calendar.MONTH)+1; System.out.println(month); //...&#125;@Testpublic void test5()&#123; long time = Long.MAX_VALUE; Date d = new Date(time); System.out.println(d);&#125;@Testpublic void test4()&#123; long time = 1559807047979L; Date d = new Date(time); System.out.println(d);&#125;@Testpublic void test3()&#123; Date d = new Date(); long time = d.getTime(); System.out.println(time);//1559807047979&#125;@Testpublic void test2()&#123; long time = System.currentTimeMillis(); System.out.println(time);//1559806982971 //当前系统时间距离1970-1-1 0:0:0 0毫秒的时间差，毫秒为单位&#125;@Testpublic void test1()&#123; Date d = new Date(); System.out.println(d);&#125; 11.5.2 JDK1.8之后java.time及其子包中。 1、LocalDate、LocalTime、LocalDateTime （1）now()：获取系统日期或时间 （2）of(xxx)：或者指定的日期或时间 （3）运算：运算后得到新对象，需要重新接受 plusXxx()：在当前日期或时间对象上加xx minusXxx() ：在当前日期或时间对象上减xx 方法 描述 now() / now(ZoneId zone) 静态方法，根据当前时间创建对象/指定时区的对象 of() 静态方法，根据指定日期/时间创建对象 getDayOfMonth()/getDayOfYear() 获得月份天数(1-31) /获得年份天数(1-366) getDayOfWeek() 获得星期几(返回一个 DayOfWeek 枚举值) getMonth() 获得月份, 返回一个 Month 枚举值 getMonthValue() / getYear() 获得月份(1-12) /获得年份 getHours()/getMinute()/getSecond() 获得当前对象对应的小时、分钟、秒 withDayOfMonth()/withDayOfYear()/withMonth()/withYear() 将月份天数、年份天数、月份、年份修改为指定的值并返回新的对象 with(TemporalAdjuster t) 将当前日期时间设置为校对器指定的日期时间 plusDays(), plusWeeks(), plusMonths(), plusYears(),plusHours() 向当前对象添加几天、几周、几个月、几年、几小时 minusMonths() / minusWeeks()/minusDays()/minusYears()/minusHours() 从当前对象减去几月、几周、几天、几年、几小时 plus(TemporalAmount t)/minus(TemporalAmount t) 添加或减少一个 Duration 或 Period isBefore()/isAfter() 比较两个 LocalDate isLeapYear() 判断是否是闰年（在LocalDate类中声明） format(DateTimeFormatter t) 格式化本地日期、时间，返回一个字符串 parse(Charsequence text) 将指定格式的字符串解析为日期、时间 2、DateTimeFormatter：日期时间格式化 该类提供了三种格式化方法： 预定义的标准格式。如：ISO_DATE_TIME;ISO_DATE 本地化相关的格式。如：ofLocalizedDate(FormatStyle.MEDIUM) 自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”) java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 @Test public void test10()&#123; LocalDateTime now = LocalDateTime.now(); // DateTimeFormatter df = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG);//2019年6月6日 下午04时40分03秒 DateTimeFormatter df = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.SHORT);//19-6-6 下午4:40 String str = df.format(now); System.out.println(str); &#125; @Test public void test9()&#123; LocalDateTime now = LocalDateTime.now(); DateTimeFormatter df = DateTimeFormatter.ISO_DATE_TIME;//2019-06-06T16:38:23.756 String str = df.format(now); System.out.println(str); &#125; @Test public void test8()&#123; LocalDateTime now = LocalDateTime.now(); DateTimeFormatter df = DateTimeFormatter.ofPattern(\"yyyy年MM月dd日 HH时mm分ss秒 SSS毫秒 E 是这一年的D天\"); String str = df.format(now); System.out.println(str); &#125; @Test public void test7()&#123; LocalDate now = LocalDate.now(); LocalDate before = now.minusDays(100); System.out.println(before);//2019-02-26 &#125; @Test public void test06()&#123; LocalDate lai = LocalDate.of(2019, 5, 13); LocalDate go = lai.plusDays(160); System.out.println(go);//2019-10-20 &#125; @Test public void test05()&#123; LocalDate lai = LocalDate.of(2019, 5, 13); System.out.println(lai.getDayOfYear()); &#125; @Test public void test04()&#123; LocalDate lai = LocalDate.of(2019, 5, 13); System.out.println(lai); &#125; @Test public void test03()&#123; LocalDateTime now = LocalDateTime.now(); System.out.println(now); &#125; @Test public void test02()&#123; LocalTime now = LocalTime.now(); System.out.println(now); &#125; @Test public void test01()&#123; LocalDate now = LocalDate.now(); System.out.println(now); &#125; 第十二章 集合12.1 概念数据结构：存储数据的某种结构 （1）底层的物理结构 ①数组：开辟连续的存储空间，每一个元素使用[下标]进行区别 ②链式：不需要开辟连续的存储空间，但是需要“结点”来包装要存储的数据，结点包含两部分内容： ​ A、数据 ​ B、记录其他结点的地址，例如：next，pre，left，right，parent等 （2）表现出来的逻辑结构：动态数组、单向链表、双向链表、队列、栈、二叉树、哈希表、图等 12.2 手动实现一些逻辑结构1、动态数组 包含： （1）内部使用一个数组，用来存储数据 （2）内部使用一个total，记录实际存储的元素的个数 java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173public class MyArrayList &#123; //为什么使用Object，因为只是说这个容器是用来装对象的，但是不知道用来装什么对象。 private Object[] data; private int total; public MyArrayList()&#123; data = new Object[5]; &#125; //添加一个元素 public void add(Object obj)&#123; //检查是否需要扩容 checkCapacity(); data[total++] = obj; &#125; private void checkCapacity() &#123; //如果data满了，就扩容为原来的2倍 if(total &gt;= data.length)&#123; data = Arrays.copyOf(data, data.length*2); &#125; &#125; //返回实际元素的个数 public int size()&#123; return total; &#125; //返回数组的实际容量 public int capacity()&#123; return data.length; &#125; //获取[index]位置的元素 public Object get(int index)&#123; //校验index的合理性范围 checkIndex(index); return data[index]; &#125; private void checkIndex(int index) &#123; if(index&lt;0 || index&gt;=total)&#123; throw new RuntimeException(index+\"对应位置的元素不存在\");// throw new IndexOutOfBoundsException(index+\"越界\"); &#125; &#125; //替换[index]位置的元素 public void set(int index, Object value)&#123; //校验index的合理性范围 checkIndex(index); data[index] = value; &#125; //在[index]位置插入一个元素value public void insert(int index, Object value)&#123; /* * (1)考虑下标的合理性 * (2)总长度是否够 * (3)[index]以及后面的元素往后移动，把[index]位置腾出来 * (4)data[index]=value 放入新元素 * (5)total++ 有效元素的个数增加 */ //(1)考虑下标的合理性：校验index的合理性范围 checkIndex(index); //(2)总长度是否够：检查是否需要扩容 checkCapacity(); //(3)[index]以及后面的元素往后移动，把[index]位置腾出来 /* * 假设total = 5, data.length= 10, index= 1 * 有效元素的下标[0,4] * 移动：[1]-&gt;[2],[2]-&gt;[3],[3]-&gt;[4],[4]-&gt;[5] * 移动元素的个数：total-index */ System.arraycopy(data, index, data, index+1, total-index); //(4)data[index]=value 放入新元素 data[index] = value; //(5)total++ 有效元素的个数增加 total++; &#125; //返回所有实际存储的元素 public Object[] getAll()&#123; //返回total个 return Arrays.copyOf(data, total); &#125; //删除[index]位置的元素 public void remove(int index)&#123; /* * (1)校验index的合理性范围 * (2)移动元素，把[index+1]以及后面的元素往前移动 * (3)把data[total-1]=null 让垃圾回收器尽快回收 * (4)总元素个数减少 total-- */ //(1)考虑下标的合理性：校验index的合理性范围 checkIndex(index); //(2)移动元素，把[index+1]以及后面的元素往前移动 /* * 假设total=8, data.length=10, index = 3 * 有效元素的范围[0,7] * 移动：[4]-&gt;[3],[5]-&gt;[4],[6]-&gt;[5],[7]-&gt;[6] * 移动了4个：total-index-1 */ System.arraycopy(data, index+1, data, index, total-index-1); //(3)把data[total-1]=null 让垃圾回收器尽快回收 data[total-1] = null; // (4)总元素个数减少 total-- total--; &#125; //查询某个元素的下标 public int indexOf(Object obj)&#123; if(obj == null)&#123; for (int i = 0; i &lt; total; i++) &#123; if(data[i] == null)&#123;//等价于 if(data[i] == obj) return i; &#125; &#125; &#125;else&#123; for (int i = 0; i &lt; data.length; i++) &#123; if(obj.equals(data[i]))&#123; return i; &#125; &#125; &#125; return -1; &#125; //删除数组中的某个元素 //如果有重复的，只删除第一个 public void remove(Object obj)&#123; /* * (1)先查询obj的[index] * (2)如果存在，就调用remove(index)删除就可以 */ //(1)先查询obj的[index] int index = indexOf(obj); if(index != -1)&#123; remove(index); &#125; //不存在，可以什么也不做 //不存在，也可以抛异常 //throw new RuntimeException(obj + \"不存在\"); &#125; public void set(Object old, Object value)&#123; /* * (1)查询old的[index] * (2)如果存在，就调用set(index, value) */ // (1)查询old的[index] int index = indexOf(old); if(index!=-1)&#123; set(index, value); &#125; //不存在，可以什么也不做 &#125;&#125; 2、单向链表 包含： （1）包含一个Node类型的成员变量first：用来记录第一个结点的地址 如果这个链表是空的，还没有任何结点，那么first是null。 最后一个结点的特征：就是它的next是null （2）内部使用一个total，记录实际存储的元素的个数 （3）使用了一个内部类Node java1234private class Node&#123; Object data; Node next;&#125; java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163public class SingleLinkedList &#123; //这里不需要数组，不需要其他的复杂的结构，我只要记录单向链表的“头”结点 private Node first;//first中记录的是第一个结点的地址 private int total;//这里我记录total是为了后面处理的方便，例如：当用户获取链表有效元素的个数时，不用现数，而是直接返回total等 /* * 内部类，因为这种Node结点的类型，在别的地方没有用，只在单向链表中，用于存储和表示它的结点关系。 * 因为我这里涉及为内部类型。 */ private class Node&#123; Object data;//因为数据可以是任意类型的对象，所以设计为Object Node next;//因为next中记录的下一个结点的地址，因此类型是结点类型 //这里data,next没有私有化，是希望在外部类中可以不需要get/set，而是直接“结点对象.data\",\"结点对象.next\"使用 Node(Object data, Node next)&#123; this.data = data; this.next = next; &#125; &#125; public void add(Object obj)&#123; /* * (1)把obj的数据，包装成一个Node类型结点对象 * (2)把新结点“链接”当前链表的最后 * ①当前新结点是第一个结点 * 如何判断是否是第一个 if(first==null)说明暂时还没有第一个 * ②先找到目前的最后一个，把新结点链接到它的next中 * 如何判断是否是最后一个 if(某个结点.next == null)说明这个结点是最后一个 */// (1)把obj的数据，包装成一个Node类型结点对象 //这里新结点的next赋值为null，表示新结点是最后一个结点 Node newNode = new Node(obj, null); //①当前新结点是第一个结点 if(first == null)&#123; //说明newNode是第一个 first = newNode; &#125;else&#123; //②先找到目前的最后一个，把新结点链接到它的next中 Node node = first; while(node.next != null)&#123; node = node.next; &#125; //退出循环时node指向最后一个结点 //把新结点链接到它的next中 node.next = newNode; &#125; total++; &#125; public int size()&#123; return total; &#125; public Object[] getAll()&#123; //(1)创建一个数组，长度为total Object[] all = new Object[total]; //(2)把单向链表的每一个结点中的data，拿过来放到all数组中 Node node = first; for (int i = 0; i &lt; total; i++) &#123;// all[i] = 结点.data; all[i] = node.data; //然后node指向下一个 node = node.next; &#125; //(3)返回数组 return all; &#125; public void remove(Object obj)&#123; if(obj == null)&#123; //(1)先考虑是否是第一个 if(first!=null)&#123;//链表非空 //要删除的结点正好是第一个结点 if(first.data == null)&#123; //让第一个结点指向它的下一个 first = first.next; total--; return; &#125; //要删除的不是第一个结点 Node node = first.next;//第二个结点 Node last = first; while(node.next!=null)&#123;//这里不包括最后一个，因为node.next==null，不进入循环，而node.next==null是最后一个 if(node.data == null)&#123; last.next = node.next; total--; return; &#125; last = node; node = node.next; &#125; //单独判断最后一个是否是要删除的结点 if(node.data == null)&#123; //要删除的是最后一个结点 last.next = null; total--; return; &#125; &#125; &#125;else&#123; //(1)先考虑是否是第一个 if(first!=null)&#123;//链表非空 //要删除的结点正好是第一个结点 if(obj.equals(first.data))&#123; //让第一个结点指向它的下一个 first = first.next; total--; return; &#125; //要删除的不是第一个结点 Node node = first.next;//第二个结点 Node last = first; while(node.next!=null)&#123;//这里不包括最后一个，因为node.next==null，不进入循环，而node.next==null是最后一个 if(obj.equals(node.data))&#123; last.next = node.next; total--; return; &#125; last = node; node = node.next; &#125; //单独判断最后一个是否是要删除的结点 if(obj.equals(node.data))&#123; //要删除的是最后一个结点 last.next = null; total--; return; &#125; &#125; &#125; &#125; public int indexOf(Object obj)&#123; if(obj == null)&#123; Node node = first; for (int i = 0; i &lt; total; i++) &#123; if(node.data == null)&#123; return i; &#125; node = node.next; &#125; &#125;else&#123; Node node = first; for (int i = 0; i &lt; total; i++) &#123; if(obj.equals(node.data))&#123; return i; &#125; node = node.next; &#125; &#125; return -1; &#125;&#125; 12.3 Collection因为集合的类型很多，那么我们把它们称为集合框架。 集合框架分为两个家族：Collection（一组对象）和Map（一组映射关系、一组键值对） 12.3.1 CollectionCollection是代表一种对象的集合。它是Collection系列的根接口。 它们虽然：有些可能是有序的，有些可能是无序的，有些可能可以重复的，有些不能重复的，但是它们有共同的操作规范，因此这些操作的规范就抽象为了Collection接口。 常用方法： （1）boolean add(Object obj)：添加一个 （2）boolean addAll（Collection c）：添加多个 （3）boolean remove(Object obj)：删除一个 （4）boolean removeAll(Collection c )： 删除多个 （5）boolean contains(Object c)：是否包含某个 （6）boolean containsAll(Collection c)： 是否包含所有 （7）boolean isEmpty()：是否为空 （8）int size()：获取元素个数 （9）void clear()：清空集合 （10）Object[] toArray()：获取所有元素 （11）Iterator iterator()： 获取遍历当前集合的迭代器对象 （12）retainAll(Collection c)：求当前集合与c集合的交集 12.3.2 Collection系列的集合的遍历1、明确使用Iterator迭代器 java1234567Collection c = ....;Iterator iter = c.iterator();while(iter.hashNext())&#123; Object obj = iter.next(); //...&#125; Iterator 接口的方法： （1）boolean hasNext() （2）Object next() （3）void remove() 2、foreach swift12345Collection c = ....;for(Object obj : c)&#123; //...&#125; 什么样的集合（容器）能够使用foreach遍历？ （1）数组： （2）实现了java.lang.Iterable接口 这个接口有一个抽象方法：Iterator iterator() Iterator也是一个接口，它的实现类，通常在集合（容器）类中用内部类实现。并在iterator()的方法中创建它的对象。 java1234567891011121314151617181920212223242526public class MyArrayList implements Iterable&#123; //为什么使用Object，因为只是说这个容器是用来装对象的，但是不知道用来装什么对象。 private Object[] data; private int total; //其他代码省略.... @Override public Iterator iterator() &#123; return new MyItr(); &#125; private class MyItr implements Iterator&#123; private int cursor;//游标 @Override public boolean hasNext() &#123; return cursor!=total; &#125; @Override public Object next() &#123; return data[cursor++]; &#125; &#125;&#125; 思考：如果遍历数组，什么情况下选用foreach，什么情况下选用for循环？ 当如果你的操作中涉及到[下标]操作时，用for最好。 当你只是查看元素的内容，那么选foreach更简洁一些。 思考：如果遍历Collection系列集合，什么情况下选用foreach，是否能选用for循环？ 首先考虑使用foreach，如果该集合也有索引信息的话，也可以通过for来操作，如果没有下标的信息，就不要用for。即，如果该集合的物理结构是数组的，那么可以用for，如果物理结构是链式，那么使用下标操作效率很低。 思考：如果遍历Collection系列集合，什么情况下选用foreach，什么情况下使用Iterator？ 如果只是查看集合的元素，使用foreach，代码会更简洁。 但是如果要涉及到在遍历集合的同时根据某种条件要删除元素等操作，那么选用Iterator。 12.4 List12.4.1 List概述List：是Collection的子接口。 List系列的集合：有序的、可重复的 List系列的常用集合：ArrayList、Vector、LinkedList、Stack 12.4.2 List的API常用方法： （1）boolean add(Object obj)：添加一个 （2）boolean addAll（Collection c）：添加多个 （3）void add(int index, Object obj)：添加一个，指定位置添加 （4）void addAll(int index, Collection c）：添加多个 （5）boolean remove(Object obj)：删除一个 （6）Object remove(int index)：删除指定位置的元素，并返回刚刚删除的元素 （7）boolean removeAll(Collection c )： 删除多个 （8）boolean contains(Object c)：是否包含某个 （9）boolean containsAll(Collection c)： 是否包含所有 （10）boolean isEmpty()：是否为空 （11）int size()：获取元素个数 （12）void clear()：清空集合 （13）Object[] toArray()：获取所有元素 （14）Iterator iterator()： 获取遍历当前集合的迭代器对象 （15）retainAll(Collection c)：求当前集合与c集合的交集 （16）ListIterator listIterator()：获取遍历当前集合的迭代器对象，这个迭代器可以往前、往后遍历 （17）ListIterator listIterator(int index)：从[index]位置开始，往前或往后遍历 （18）Object get(int index)：返回index位置的元素 （19）List subList(int start, int end)：截取[start,end)部分的子列表 12.4.3 ListIterator 接口Iterator 接口的方法： （1）boolean hasNext() （2）Object next() （3）void remove() ListIterator 是 Iterator子接口：增加了如下方法 （4）void add(Object obj) （5）void set(Object obj) （6）boolean hasPrevious() （7）Object previous() （8）int nextIndex() （9）int previousIndex() 12.4.4 List的实现类们的区别ArrayList、Vector、LinkedList、Stack （1）ArrayList、Vector：都是动态数组 Vector是最早版本的动态数组，线程安全的，默认扩容机制是2倍，支持旧版的迭代器Enumeration ArrayList是后增的动态数组，线程不安全的，默认扩容机制是1.5倍 （2）动态数组与LinkedList的区别 动态数组：底层物理结构是数组 ​ 优点：根据[下标]访问的速度很快 ​ 缺点：需要开辟连续的存储空间，而且需要扩容，移动元素等操作 LinkedList：底层物理结构是双向链表 ​ 优点：在增加、删除元素时，不需要移动元素，只需要修改前后元素的引用关系 ​ 缺点：我们查找元素时，只能从first或last开始查找 （3）Stack：栈 是Vector的子类。比Vector多了几个方法，能够表现出“先进后出或后进先出”的特点。 ①Object peek()：访问栈顶元素 ②Object pop()：弹出栈顶元素 ③push()：把元素压入栈顶 （4）LinkedList可以作为很多种数据结构使用 单链表：只关注next就可以 队列：先进先出，找对应的方法 双端队列(JDK1.6加入)：两头都可以进出，找对应的方法 栈：先进后出，找对应的方法 建议：虽然LinkedList是支持对索引进行操作，因为它实现List接口的所有方法，但是我们不太建议调用类似这样的方法，因为效率比较低。 12.4.5 源码分析（1）Vectorjava1234567891011121314151617 public Vector() &#123; this(10);//指定初始容量initialCapacity为10 &#125;public Vector(int initialCapacity) &#123; this(initialCapacity, 0);//指定capacityIncrement增量为0 &#125; public Vector(int initialCapacity, int capacityIncrement增量为0) &#123; super(); //判断了形参初始容量initialCapacity的合法性 if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); //创建了一个Object[]类型的数组 this.elementData = new Object[initialCapacity];//默认是10 //增量，默认是0，如果是0，后面就按照2倍增加，如果不是0，后面就按照你指定的增量进行增量 this.capacityIncrement = capacityIncrement; &#125; java1234567891011121314151617181920212223242526272829303132333435//synchronized意味着线程安全的 public synchronized boolean add(E e) &#123; modCount++; //看是否需要扩容 ensureCapacityHelper(elementCount + 1); //把新的元素存入[elementCount]，存入后，elementCount元素的个数增1 elementData[elementCount++] = e; return true; &#125; private void ensureCapacityHelper(int minCapacity) &#123; // overflow-conscious code //看是否超过了当前数组的容量 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);//扩容 &#125; private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length;//获取目前数组的长度 //如果capacityIncrement增量是0，新容量 = oldCapacity的2倍 //如果capacityIncrement增量是不是0，新容量 = oldCapacity + capacityIncrement增量; int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); //如果按照上面计算的新容量还不够，就按照你指定的需要的最小容量来扩容minCapacity if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; //如果新容量超过了最大数组限制，那么单独处理 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); //把旧数组中的数据复制到新数组中，新数组的长度为newCapacity elementData = Arrays.copyOf(elementData, newCapacity); &#125; java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public boolean remove(Object o) &#123; return removeElement(o);&#125;public synchronized boolean removeElement(Object obj) &#123; modCount++; //查找obj在当前Vector中的下标 int i = indexOf(obj); //如果i&gt;=0，说明存在，删除[i]位置的元素 if (i &gt;= 0) &#123; removeElementAt(i); return true; &#125; return false;&#125;public int indexOf(Object o) &#123; return indexOf(o, 0);&#125;public synchronized int indexOf(Object o, int index) &#123; if (o == null) &#123;//要查找的元素是null值 for (int i = index ; i &lt; elementCount ; i++) if (elementData[i]==null)//如果是null值，用==null判断 return i; &#125; else &#123;//要查找的元素是非null值 for (int i = index ; i &lt; elementCount ; i++) if (o.equals(elementData[i]))//如果是非null值，用equals判断 return i; &#125; return -1;&#125;public synchronized void removeElementAt(int index) &#123; modCount++; //判断下标的合法性 if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + \" &gt;= \" + elementCount); &#125; else if (index &lt; 0) &#123; throw new ArrayIndexOutOfBoundsException(index); &#125; //j是要移动的元素的个数 int j = elementCount - index - 1; //如果需要移动元素，就调用System.arraycopy进行移动 if (j &gt; 0) &#123; //把index+1位置以及后面的元素往前移动 //index+1的位置的元素移动到index位置，依次类推 //一共移动j个 System.arraycopy(elementData, index + 1, elementData, index, j); &#125; //元素的总个数减少 elementCount--; //将elementData[elementCount]这个位置置空，用来添加新元素，位置的元素等着被GC回收 elementData[elementCount] = null; /* to let gc do its work */&#125; （2）ArrayList源码分析JDK1.6： java123456789101112 public ArrayList() &#123;this(10);//指定初始容量为10 &#125; public ArrayList(int initialCapacity) &#123;super(); //检查初始容量的合法性 if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); //数组初始化为长度为initialCapacity的数组this.elementData = new Object[initialCapacity]; &#125; JDK1.7 java123456789101112131415161718192021 private static final int DEFAULT_CAPACITY = 10;//默认初始容量10private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;public ArrayList() &#123; super(); this.elementData = EMPTY_ELEMENTDATA;//数组初始化为一个空数组 &#125; public boolean add(E e) &#123; //查看当前数组是否够多存一个元素 ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == EMPTY_ELEMENTDATA) &#123;//如果当前数组还是空数组 //minCapacity按照 默认初始容量和minCapacity中的的最大值处理 minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; //看是否需要扩容处理 ensureExplicitCapacity(minCapacity); &#125;//... JDK1.8 java123456789101112131415161718192021222324252627282930313233343536373839404142434445private static final int DEFAULT_CAPACITY = 10;private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;//初始化为空数组 &#125; public boolean add(E e) &#123; //查看当前数组是否够多存一个元素 ensureCapacityInternal(size + 1); // Increments modCount!! //存入新元素到[size]位置，然后size自增1 elementData[size++] = e; return true; &#125; private void ensureCapacityInternal(int minCapacity) &#123; //如果当前数组还是空数组 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; //那么minCapacity取DEFAULT_CAPACITY与minCapacity的最大值 minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; //查看是否需要扩容 ensureExplicitCapacity(minCapacity); &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++;//修改次数加1 // 如果需要的最小容量 比 当前数组的长度 大，即当前数组不够存，就扩容 if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length;//当前数组容量 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);//新数组容量是旧数组容量的1.5倍 //看旧数组的1.5倍是否够 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; //看旧数组的1.5倍是否超过最大数组限制 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); //复制一个新数组 elementData = Arrays.copyOf(elementData, newCapacity); &#125; java12345678910111213141516171819202122232425262728293031public boolean remove(Object o) &#123; //先找到o在当前ArrayList的数组中的下标 //分o是否为空两种情况讨论 if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123;//null值用==比较 fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123;//非null值用equals比较 fastRemove(index); return true; &#125; &#125; return false;&#125;private void fastRemove(int index) &#123; modCount++;//修改次数加1 //需要移动的元素个数 int numMoved = size - index - 1; //如果需要移动元素，就用System.arraycopy移动元素 if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); //将elementData[size-1]位置置空，让GC回收空间，元素个数减少 elementData[--size] = null; // clear to let GC do its work&#125; java1234567891011121314151617181920 public E remove(int index) &#123; rangeCheck(index);//检验index是否合法 modCount++;//修改次数加1 //取出[index]位置的元素，[index]位置的元素就是要被删除的元素，用于最后返回被删除的元素 E oldValue = elementData(index); //需要移动的元素个数 int numMoved = size - index - 1; //如果需要移动元素，就用System.arraycopy移动元素 if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); //将elementData[size-1]位置置空，让GC回收空间，元素个数减少 elementData[--size] = null; // clear to let GC do its work return oldValue; &#125; java1234567891011121314public E set(int index, E element) &#123; rangeCheck(index);//检验index是否合法 //取出[index]位置的元素，[index]位置的元素就是要被替换的元素，用于最后返回被替换的元素 E oldValue = elementData(index); //用element替换[index]位置的元素 elementData[index] = element; return oldValue;&#125;public E get(int index) &#123; rangeCheck(index);//检验index是否合法 return elementData(index);//返回[index]位置的元素&#125; java12345678910111213141516171819202122232425262728public int indexOf(Object o) &#123; //分为o是否为空两种情况 if (o == null) &#123; //从前往后找 for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1;&#125;public int lastIndexOf(Object o) &#123; //分为o是否为空两种情况 if (o == null) &#123; //从后往前找 for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1;&#125; （3）LinkedList源码分析java123456789101112131415int size = 0;Node&lt;E&gt; first;//记录第一个结点的位置Node&lt;E&gt; last;//记录最后一个结点的位置 private static class Node&lt;E&gt; &#123; E item;//元素数据 Node&lt;E&gt; next;//下一个结点 Node&lt;E&gt; prev;//前一个结点 Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125; java123456789101112131415161718192021222324public boolean add(E e) &#123; linkLast(e);//默认把新元素链接到链表尾部 return true;&#125;void linkLast(E e) &#123; final Node&lt;E&gt; l = last;//用l 记录原来的最后一个结点 //创建新结点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); //现在的新结点是最后一个结点了 last = newNode; //如果l==null，说明原来的链表是空的 if (l == null) //那么新结点同时也是第一个结点 first = newNode; else //否则把新结点链接到原来的最后一个结点的next中 l.next = newNode; //元素个数增加 size++; //修改次数增加 modCount++;&#125; java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 public boolean remove(Object o) &#123; //分o是否为空两种情况 if (o == null) &#123; //找到o对应的结点x for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; unlink(x);//删除x结点 return true; &#125; &#125; &#125; else &#123; //找到o对应的结点x for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x);//删除x结点 return true; &#125; &#125; &#125; return false; &#125; E unlink(Node&lt;E&gt; x) &#123;//x是要被删除的结点 // assert x != null; final E element = x.item;//被删除结点的数据 final Node&lt;E&gt; next = x.next;//被删除结点的下一个结点 final Node&lt;E&gt; prev = x.prev;//被删除结点的上一个结点 //如果被删除结点的前面没有结点，说明被删除结点是第一个结点 if (prev == null) &#123; //那么被删除结点的下一个结点变为第一个结点 first = next; &#125; else &#123;//被删除结点不是第一个结点 //被删除结点的上一个结点的next指向被删除结点的下一个结点 prev.next = next; //断开被删除结点与上一个结点的链接 x.prev = null;//使得GC回收 &#125; //如果被删除结点的后面没有结点，说明被删除结点是最后一个结点 if (next == null) &#123; //那么被删除结点的上一个结点变为最后一个结点 last = prev; &#125; else &#123;//被删除结点不是最后一个结点 //被删除结点的下一个结点的prev执行被删除结点的上一个结点 next.prev = prev; //断开被删除结点与下一个结点的连接 x.next = null;//使得GC回收 &#125;//把被删除结点的数据也置空，使得GC回收 x.item = null; //元素个数减少 size--; //修改次数增加 modCount++; //返回被删除结点的数据 return element; &#125; 12.5 Set12.5.1 Set概述Set系列的集合：不可重复的 Set系列的集合，有有序的也有无序的。HashSet无序的，TreeSet按照元素的大小顺序遍历，LinkedHashSet按照元素的添加顺序遍历。 12.5.2 实现类的特点（1）HashSet： ​ 底层是HashMap实现。添加到HashSet的元素是作为HashMap的key，value是一个Object类型的常量对象PRESENT。 ​ 依赖于元素的hashCode()和equals()保证元素的不可重复，存储位置和hashCode()值有关，根据hashCode()来算出它在底层table数组中的[index] （2）TreeSet ​ 底层是TreeMap实现。添加到TreeSet的元素是作为TreeMap的key，value是一个Object类型的常量对象PRESENT。 ​ 依赖于元素的大小，要么是java.lang.Comparable接口compareTo(Object obj)，要么是java.util.Comparator接口的compare(Object o1, Object o2)来比较元素的大小。认为大小相等的两个元素就是重复元素。 （3）LinkedHashSet ​ 底层是LinkedHashMap。添加到LinkedHashSet的元素是作为LinkedHashMap的key，value是一个Object类型的常量对象PRESENT。 ​ LinkedHashSet是HashSet的子类，比父类多维护了元素的添加顺序。 ​ 当且仅当，你既想要元素不可重复，又要保证元素的添加顺序时，再使用它。 ​ 12.6 Map12.6.1 Map概述用来存储键值对，映射关系的集合。所有的Map的key都不能重复。 键值对、映射关系的类型：Entry类型 armasm1234Entry接口是Map接口的内部接口。所有的Map的键值对的类型都实现了这个接口。HashMap中的映射关系，是有一个内部类来实现Entry的接口，JDK1.7是一个叫做Entry的内部类实现Entry接口。JDK1.8是一个叫做Node的内部类实现Entry接口。TreeMap中的映射关系，是有一个内部类Entry来实现Entry的接口 12.6.2 API（1）put(Object key, Object value)：添加一对映射关系 （2）putAll(Map m)：添加多对映射关系 （3）clear()：清空map （4）remove(Object key)：根据key删除一对 （5）int size()：获取有效元素的对数 （6）containsKey(Object key)：是否包含某个key （7）containsValue(Object value)：是否包含某个value （8）Object get(Object key)：根据key获取value （9）遍历相关的几个方法 Collection values()：获取所有的value进行遍历 Set keySet()：获取所有key进行遍历 Set entrySet()：获取所有映射关系进行遍历 12.6.3 Map的实现类们的区别（1）HashMap： ​ 依据key的hashCode()和equals()来保证key是否重复。 ​ key如果重复，新的value会替换旧的value。 ​ hashCode()决定了映射关系在table数组中的存储的位置，index = hash(key.hashCode()) &amp; table.length-1 ​ HashMap的底层实现：JDK1.7是数组+链表；JDK1.8是数组+链表/红黑树 （2）TreeMap ​ 依据key的大小来保证key是否重复。key如果重复，新的value会替换旧的value。 ​ key的大小依赖于，java.lang.Comparable或java.util.Comparator。 （3）LinkedHashMap ​ 依据key的hashCode()和equals()来保证key是否重复。key如果重复，新的value会替换旧的value。 ​ LinkedHashMap是HashMap的子类，比HashMap多了添加顺序 12.6.4 HashMap源码分析JDK1.6源码：java12345678910111213public HashMap() &#123; //this.loadFactor加载因子，影响扩容的频率 //DEFAULT_LOAD_FACTOR：默认加载因子0.75 this.loadFactor = DEFAULT_LOAD_FACTOR; //threshold阈值 = 容量 * 加载因子 //threshold阈值，当size达到threhold时，考虑扩容 //扩容需要两个条件同时满足：（1）size &gt;= threhold （2）table[index]！=null，即新映射关系要存入的位置非空 threshold = (int)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR); //table是数组， //DEFAULT_INITIAL_CAPACITY：默认是16 table = new Entry[DEFAULT_INITIAL_CAPACITY]; init();&#125; JDK1.7源码：java12345678910111213141516171819202122 public HashMap() &#123; //DEFAULT_INITIAL_CAPACITY：默认初始容量16 //DEFAULT_LOAD_FACTOR：默认加载因子0.75 this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR); &#125; public HashMap(int initialCapacity, float loadFactor) &#123; //校验initialCapacity合法性 if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + //校验initialCapacity合法性 initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; //校验loadFactor合法性 if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor);//加载因子，初始化为0.75 this.loadFactor = loadFactor; // threshold 初始为初始容量 threshold = initialCapacity; init(); &#125; java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public V put(K key, V value) &#123; //如果table数组是空的，那么先创建数组 if (table == EMPTY_TABLE) &#123; //threshold一开始是初始容量的值 inflateTable(threshold); &#125; //如果key是null，单独处理 if (key == null) return putForNullKey(value); //对key的hashCode进行干扰，算出一个hash值 int hash = hash(key); //计算新的映射关系应该存到table[i]位置， //i = hash &amp; table.length-1，可以保证i在[0,table.length-1]范围内 int i = indexFor(hash, table.length); //检查table[i]下面有没有key与我新的映射关系的key重复，如果重复替换value for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; //添加新的映射关系 addEntry(hash, key, value, i); return null; &#125; private void inflateTable(int toSize) &#123; // Find a power of 2 &gt;= toSize int capacity = roundUpToPowerOf2(toSize);//容量是等于toSize值的最接近的2的n次方 //计算阈值 = 容量 * 加载因子 threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1); //创建Entry[]数组，长度为capacity table = new Entry[capacity]; initHashSeedAsNeeded(capacity); &#125; //如果key是null，直接存入[0]的位置 private V putForNullKey(V value) &#123; //判断是否有重复的key，如果有重复的，就替换value for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; //把新的映射关系存入[0]的位置，而且key的hash值用0表示 addEntry(0, null, value, 0); return null; &#125; void addEntry(int hash, K key, V value, int bucketIndex) &#123; //判断是否需要库容 //扩容：（1）size达到阈值（2）table[i]正好非空 if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; //table扩容为原来的2倍，并且扩容后，会重新调整所有映射关系的存储位置 resize(2 * table.length); //新的映射关系的hash和index也会重新计算 hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); &#125; //存入table中 createEntry(hash, key, value, bucketIndex); &#125; void createEntry(int hash, K key, V value, int bucketIndex) &#123; Entry&lt;K,V&gt; e = table[bucketIndex]; //原来table[i]下面的映射关系作为新的映射关系next table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); size++;//个数增加 &#125; 1、put(key,value) （1）当第一次添加映射关系时，数组初始化为一个长度为16的HashMap$Entry的数组，这个HashMap$Entry类型是实现了java.util.Map.Entry接口 （2）特殊考虑：如果key为null，index直接是[0] （3）在计算index之前，会对key的hashCode()值，做一个hash(key)再次哈希的运算，这样可以使得Entry对象更加散列的存储到table中 （4）计算index = table.length-1 &amp; hash; （5）如果table[index]下面，已经有映射关系的key与我要添加的新的映射关系的key相同了，会用新的value替换旧的value。 （6）如果没有相同的，会把新的映射关系添加到链表的头，原来table[index]下面的Entry对象连接到新的映射关系的next中。 （7）添加之前先判断if(size &gt;= threshold &amp;&amp; table[index]!=null)如果该条件为true，会扩容 ​ if(size &gt;= threshold &amp;&amp; table[index]!=null){ ​ ①会扩容 ​ ②会重新计算key的hash ​ ③会重新计算index ​ } 2、get(key) （1）计算key的hash值，用这个方法hash(key) （2）找index = table.length-1 &amp; hash; （3）如果table[index]不为空，那么就挨个比较哪个Entry的key与它相同，就返回它的value 3、remove(key) （1）计算key的hash值，用这个方法hash(key) （2）找index = table.length-1 &amp; hash; （3）如果table[index]不为空，那么就挨个比较哪个Entry的key与它相同，就删除它，把它前面的Entry的next的值修改为被删除Entry的next JDK1.8源码java12345678910111213几个常量和变量：（1）DEFAULT_INITIAL_CAPACITY：默认的初始容量 16（2）MAXIMUM_CAPACITY：最大容量 1 &lt;&lt; 30（3）DEFAULT_LOAD_FACTOR：默认加载因子 0.75（4）TREEIFY_THRESHOLD：默认树化阈值8，当链表的长度达到这个值后，要考虑树化（5）UNTREEIFY_THRESHOLD：默认反树化阈值6，当树中的结点的个数达到这个阈值后，要考虑变为链表（6）MIN_TREEIFY_CAPACITY：最小树化容量64 当单个的链表的结点个数达到8，并且table的长度达到64，才会树化。 当单个的链表的结点个数达到8，但是table的长度未达到64，会先扩容（7）Node&lt;K,V&gt;[] table：数组（8）size：记录有效映射关系的对数，也是Entry对象的个数（9）int threshold：阈值，当size达到阈值时，考虑扩容（10）double loadFactor：加载因子，影响扩容的频率 java1234public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted，其他字段都是默认值&#125; java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225 public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125;//目的：干扰hashCode值 static final int hash(Object key) &#123; int h; //如果key是null，hash是0 //如果key非null，用key的hashCode值 与 key的hashCode值高16进行异或 // 即就是用key的hashCode值高16位与低16位进行了异或的干扰运算 /* index = hash &amp; table.length-1 如果用key的原始的hashCode值 与 table.length-1 进行按位与，那么基本上高16没机会用上。 这样就会增加冲突的概率，为了降低冲突的概率，把高16位加入到hash信息中。 */ return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; //数组 Node&lt;K,V&gt; p; //一个结点 int n, i;//n是数组的长度 i是下标 //tab和table等价 //如果table是空的 if ((tab = table) == null || (n = tab.length) == 0)&#123; n = (tab = resize()).length; /* tab = resize(); n = tab.length;*/ /* 如果table是空的，resize()完成了①创建了一个长度为16的数组②threshold = 12 n = 16 */ &#125; //i = (n - 1) &amp; hash ，下标 = 数组长度-1 &amp; hash //p = tab[i] 第1个结点 //if(p==null) 条件满足的话说明 table[i]还没有元素 if ((p = tab[i = (n - 1) &amp; hash]) == null)&#123; //把新的映射关系直接放入table[i] tab[i] = newNode(hash, key, value, null); //newNode（）方法就创建了一个Node类型的新结点，新结点的next是null &#125;else &#123; Node&lt;K,V&gt; e; K k; //p是table[i]中第一个结点 //if(table[i]的第一个结点与新的映射关系的key重复) if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))&#123; e = p;//用e记录这个table[i]的第一个结点 &#125;else if (p instanceof TreeNode)&#123;//如果table[i]第一个结点是一个树结点 //单独处理树结点 //如果树结点中，有key重复的，就返回那个重复的结点用e接收，即e!=null //如果树结点中，没有key重复的，就把新结点放到树中，并且返回null，即e=null e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); &#125;else &#123; //table[i]的第一个结点不是树结点，也与新的映射关系的key不重复 //binCount记录了table[i]下面的结点的个数 for (int binCount = 0; ; ++binCount) &#123; //如果p的下一个结点是空的，说明当前的p是最后一个结点 if ((e = p.next) == null) &#123; //把新的结点连接到table[i]的最后 p.next = newNode(hash, key, value, null); //如果binCount&gt;=8-1，达到7个时 if (binCount &gt;= TREEIFY_THRESHOLD - 1)&#123; // -1 for 1st //要么扩容，要么树化 treeifyBin(tab, hash); &#125; break; &#125; //如果key重复了，就跳出for循环，此时e结点记录的就是那个key重复的结点 if (e.hash == hash &amp;&amp;((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))&#123; break; &#125; p = e;//下一次循环，e=p.next，就类似于e=e.next，往链表下移动 &#125; &#125; //如果这个e不是null，说明有key重复，就考虑替换原来的value if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null)&#123; e.value = value; &#125; afterNodeAccess(e);//什么也没干 return oldValue; &#125; &#125; ++modCount; //元素个数增加 //size达到阈值 if (++size &gt; threshold)&#123; resize();//一旦扩容，重新调整所有映射关系的位置 &#125; afterNodeInsertion(evict);//什么也没干 return null; &#125; final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table;//oldTab原来的table //oldCap：原来数组的长度 int oldCap = (oldTab == null) ? 0 : oldTab.length; //oldThr：原来的阈值 int oldThr = threshold;//最开始threshold是0 //newCap，新容量 //newThr：新阈值 int newCap, newThr = 0; if (oldCap &gt; 0) &#123;//说明原来不是空数组 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;//是否达到数组最大限制 threshold = Integer.MAX_VALUE; return oldTab; &#125;else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)&#123; //newCap = 旧的容量*2 ，新容量&lt;最大数组容量限制 //新容量：32,64，... //oldCap &gt;= 初始容量16 //新阈值重新算 = 24，48 .... newThr = oldThr &lt;&lt; 1; // double threshold &#125; &#125;else if (oldThr &gt; 0)&#123; // initial capacity was placed in threshold newCap = oldThr; &#125;else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY;//新容量是默认初始化容量16 //新阈值= 默认的加载因子 * 默认的初始化容量 = 0.75*16 = 12 newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr;//阈值赋值为新阈值12，24.。。。 //创建了一个新数组，长度为newCap，16，32,64.。。 @SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123;//原来不是空数组 //把原来的table中映射关系，倒腾到新的table中 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123;//e是table下面的结点 oldTab[j] = null;//把旧的table[j]位置清空 if (e.next == null)//如果是最后一个结点 newTab[e.hash &amp; (newCap - 1)] = e;//重新计算e的在新table中的存储位置，然后放入 else if (e instanceof TreeNode)//如果e是树结点 //把原来的树拆解，放到新的table ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; /* 把原来table[i]下面的整个链表，重新挪到了新的table中 */ do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; //创建一个新结点 return new Node&lt;&gt;(hash, key, value, next); &#125; final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123; int n, index; Node&lt;K,V&gt; e; //MIN_TREEIFY_CAPACITY：最小树化容量64 //如果table是空的，或者 table的长度没有达到64 if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) resize();//先扩容 else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123; //用e记录table[index]的结点的地址 TreeNode&lt;K,V&gt; hd = null, tl = null; /* do...while，把table[index]链表的Node结点变为TreeNode类型的结点 */ do &#123; TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null); if (tl == null) hd = p;//hd记录根结点 else &#123; p.prev = tl; tl.next = p; &#125; tl = p; &#125; while ((e = e.next) != null); //如果table[index]下面不是空 if ((tab[index] = hd) != null) hd.treeify(tab);//将table[index]下面的链表进行树化 &#125; &#125; 1、添加过程 （1）当第一次添加映射关系时，数组初始化为一个长度为16的HashMap$Node的数组，这个HashMap$Node类型是实现了java.util.Map.Entry接口 （2）在计算index之前，会对key的hashCode()值，做一个hash(key)再次哈希的运算，这样可以使得Entry对象更加散列的存储到table中 JDK1.8关于hash(key)方法的实现比JDK1.7要简洁。 key.hashCode() ^ key.Code()&gt;&gt;&gt;16; （3）计算index = table.length-1 &amp; hash; （4）如果table[index]下面，已经有映射关系的key与我要添加的新的映射关系的key相同了，会用新的value替换旧的value。 （5）如果没有相同的， ①table[index]链表的长度没有达到8个，会把新的映射关系添加到链表的尾 ②table[index]链表的长度达到8个，但是table.length没有达到64，会先对table进行扩容，然后再添加 ③table[index]链表的长度达到8个，并且table.length达到64，会先把该分支进行树化，结点的类型变为TreeNode，然后把链表转为一棵红黑树 ④table[index]本来就已经是红黑树了，那么直接连接到树中，可能还会考虑考虑左旋右旋以保证树的平衡问题 （6）添加完成后判断if(size &gt; threshold ){ ​ ①会扩容 ​ ②会重新计算key的hash ​ ③会重新计算index ​ } 2、remove(key) （1）计算key的hash值，用这个方法hash(key) （2）找index = table.length-1 &amp; hash; （3）如果table[index]不为空，那么就挨个比较哪个Entry的key与它相同，就删除它，把它前面的Entry的next的值修改为被删除Entry的next （4）如果table[index]下面原来是红黑树，结点删除后，个数小于等于6，会把红黑树变为链表 12.6.5 关于HashMap的面试问题1、HashMap的底层实现 答：JDK1.7是数组+链表，JDK1.8是数组+链表/红黑树 2、HashMap的数组的元素类型 答：java.util.Map$Entry接口类型。 JDK1.7的HashMap中有内部类Entry实现Entry接口 JDK1.8的HashMap中有内部类Node和TreeNode类型实现Entry接口 3、为什么要使用数组？ 答：因为数组的访问的效率高 4、为什么数组还需要链表？或问如何解决hash或[index]冲突问题？ 答：为了解决hash和[index]冲突问题 （1）两个不相同的key的hashCode值本身可能相同 （2）两个hashCode不相同的key，通过hash(key)以及 hash &amp; table.length-1运算得到的[index]可能相同 那么意味着table[index]下可能需要存储多个Entry的映射关系对象，所以需要链表 5、HashMap的数组的初始化长度 答：默认的初始容量值是16 6、HashMap的映射关系的存储索引index如何计算 答：hash &amp; table.length-1 7、为什么要使用hashCode()? 空间换时间 答：因为hashCode()是一个整数值，可以用来直接计算index，效率比较高，用数组这种结构虽然会浪费一些空间，但是可以提高查询效率。 8、hash()函数的作用是什么 答：在计算index之前，会对key的hashCode()值，做一个hash(key)再次哈希的运算，这样可以使得Entry对象更加散列的存储到table中 JDK1.8关于hash(key)方法的实现比JDK1.7要简洁。 key.hashCode() ^ key.Code()&gt;&gt;&gt;16; 因为这样可以使得hashCode的高16位信息也能参与到运算中来 9、HashMap的数组长度为什么一定要是2的幂次方 答：因为2的n次方-1的二进制值是前面都0，后面几位都是1，这样的话，与hash进行&amp;运算的结果就能保证在[0,table.length-1]范围内，而且是均匀的。 10、HashMap 为什么使用 &amp;按位与运算代替%模运算？ 答：因为&amp;效率高 11、HashMap的数组什么时候扩容？ 答：JDK1.7版：当要添加新Entry对象时发现（1）size达到threshold（2）table[index]!=null时，两个条件同时满足会扩容 JDK1.8版：当要添加新Entry对象时发现（1）size达到threshold（2）当table[index]下的结点个数达到8个但是table.length又没有达到64。两种情况满足其一都会导致数组扩容 而且数组一旦扩容，不管哪个版本，都会导致所有映射关系重新调整存储位置。 12、如何计算扩容阈值(临界值)？ 答：threshold = capacity * loadfactor 13、loadFactor为什么是0.75，如果是1或者0.1呢有什么不同？ 答：1的话，会导致某个table[index]下面的结点个数可能很长 0.1的话，会导致数组扩容的频率太高 14、JDK1.8的HashMap什么时候树化？ 答：当table[index]下的结点个数达到8个但是table.length已经达到64 15、JDK1.8的HashMap什么时候反树化？ 答：当table[index]下的树结点个数少于6个 16、JDK1.8的HashMap为什么要树化？ 答：因为当table[index]下的结点个数超过8个后，查询效率就低下了，修改为红黑树的话，可以提高查询效率 17、JDK1.8的HashMap为什么要反树化？ 答：因为因为当table[index]下树的结点个数少于6个后，使用红黑树反而过于复杂了，此时使用链表既简洁又效率也不错 18、作为HashMap的key类型重写equals和hashCode方法有什么要求 ​ （1）equals与hashCode一起重写 ​ （2）重写equals()方法，但是有一些注意事项； 自反性：x.equals(x)必须返回true。对称性：x.equals(y)与y.equals(x)的返回值必须相等。传递性：x.equals(y)为true，y.equals(z)也为true，那么x.equals(z)必须为true。一致性：如果对象x和y在equals()中使用的信息都没有改变，那么x.equals(y)值始终不变。非null：x不是null，y为null，则x.equals(y)必须为false。 ​ （3）重写hashCode（）的注意事项 如果equals返回true的两个对象，那么hashCode值一定相同，并且只要参与equals判断属性没有修改，hashCode值也不能修改；如果equals返回false的两个对象，那么hashCode值可以相同也可以不同；如果hashCode值不同的，equals一定要返回false；hashCode不宜过简单，太简单会导致冲突严重，hashCode也不宜过于复杂，会导致性能低下； 19、为什么大部分 hashcode 方法使用 31？ 答：因为31是一个不大不小的素数 20、请问已经存储到HashMap中的key的对象属性是否可以修改？为什么？ 答：如果该属性参与hashCode的计算，那么不要修改。因为一旦修改hashCode()已经不是原来的值。而存储到HashMap中时，key的hashCode()–&gt;hash()–&gt;hash已经确定了，不会重新计算。用新的hashCode值再查询get(key)/删除remove(key)时，算的hash值与原来不一样就不找不到原来的映射关系了。 21、所以为什么，我们实际开发中，key的类型一般用String和Integer 答：因为他们不可变。 22、为什么HashMap中的Node或Entry类型的hash变量与key变量加final声明？ 答：因为不希望你修改hash和key值 23、为什么HashMap中的Node或Entry类型要单独存储hash？ 答：为了在添加、删除、查找过程中，比较hash效率更高，不用每次重新计算key的hash值 24、请问已经存储到HashMap中的value的对象属性是否可以修改？为什么？ 答：可以。因为我们存储、删除等都是根据key，和value无关。 25、如果key是null是如何存储的？ 答：会存在table[0]中 12.7 集合框架图 第13章 泛型13.1 泛型的概述泛型：参数化类型 类型形参：，，，，，。。。。 类型实参：必须是引用数据类型，不能是基本数据类型 ​ ，，，&lt;ArrayList&gt;。。。 13.2 形式一：泛型类与泛型接口1、声明语法格式： scala12345678910【修饰符】 class 类名/接口&lt;类型形参列表&gt;&#123; &#125;【修饰符】 class 类名/接口&lt;类型形参1 extends 父类上限&gt;&#123; &#125;【修饰符】 class 类名/接口&lt;类型形参1 extends 父类上限 &amp; 父接口上限&gt;&#123; &#125; 在类名或接口名后面声明的泛型形参类型，可以在当前类或接口中使用，用作声明成员变量、方法的形参、方法的返回值。 但是不能用于静态成员上 2、使用语法格式 在（1）创建泛型类、泛型接口的对象时，为泛型形参指定具体类型 ​ （2）在继承泛型类或实现泛型接口时，为泛型形参指定具体类型 示例代码 java12345678910111213141516171819ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();//JDK1.7之后可以省略class MyStringArrayList extends ArrayList&lt;String&gt;&#123; &#125;class Employee implements Comparable&lt;Employee&gt;&#123; public int compareTo(Employee e)&#123; &#125;&#125;Arrays.sort(数组, new Comparator&lt;泛型实参&gt;()&#123; public int compare(泛型实参类型 o1, 泛型实参类型 o2)&#123; &#125;&#125;); 3、泛型如果没有指定，会被擦除，按照最左边的上限处理，如果没有指定上限，按照Object处理 13.3 形式二：泛型方法1、声明的语法格式 dust12【修饰符】 &lt;泛型形参列表&gt; 返回值类型 方法名(【数据形参列表】)【throws 异常列表】&#123;&#125;【修饰符】 &lt;泛型形参 extends 父类上限 &amp; 父接口上限&gt; 返回值类型 方法名(【数据形参列表】)【throws 异常列表】&#123;&#125; （1）在方法返回值类型前面声明的泛型形参类型，只能在当前方法中使用，用于表示形参的类型或返回值类型，或方法局部变量的类型，和别的方法无关。 （2）泛型方法可以是静态方法，也可以是非静态方法 2、 使用 当调用方法，会根据具体的数据的实参的类型，来确定泛型实参的类型。 13.4 通配符？（1）?：代表任意引用数据类型 （2）? extends 上限：代表上限本身或它的子类 （3）? super 下限：代表下限本身或它的父类 例如： ArrayList&lt;?&gt;：表示可以接受任意类型 java123ArrayList&lt;?&gt; list = new ArrayList&lt;String&gt;();ArrayList&lt;?&gt; list = new ArrayList&lt;Integer&gt;();ArrayList&lt;?&gt; list = new ArrayList&lt;Animal&gt;(); ArrayList&lt;? extends 上限&gt;： xml1234ArrayList&lt;? extends Person&gt; list = new ArrayList&lt;Person&gt;();ArrayList&lt;? extends Person&gt; list = new ArrayList&lt;Animal&gt;();//Animal不行，因为Animal是父类ArrayList&lt;? extends Person&gt; list = new ArrayList&lt;Student&gt;();ArrayList&lt;? extends Person&gt; list = new ArrayList&lt;Dog&gt;();//Dog也不行 ArrayList&lt;? super 下限&gt;： java1234ArrayList&lt;? super Person&gt; list = new ArrayList&lt;Person&gt;();ArrayList&lt;? super Person&gt; list = new ArrayList&lt;Animal&gt;();ArrayList&lt;? super Person&gt; list = new ArrayList&lt;Student&gt;();//Student，因为Student是子类ArrayList&lt;? super Person&gt; list = new ArrayList&lt;Dog&gt;();//Dog也不行 ArrayList&lt;?&gt;：不能添加元素，除了null ArrayList&lt;? extends 上限&gt;：不能添加元素，除了null ArrayList&lt;? super 下限&gt;：可以添加下限或下限子类的对象 13.5 Collections工具类java.util.Collections：工具类，操作集合 （1）public static boolean addAll(Collection&lt;? super T&gt; c, T… elements) 添加elements的几个对象到c集合中。T是elements对象的类型，要求Collection集合的元素类型必须是T或T的父类 （2）public static int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list,T key) 在list集合中用二分查找key的下标，如果存在返回的是合理的下标，如果不存在返回的是一个负数下标 T是元素的类型， &lt;? extends Comparable&lt;? super T&gt;&gt;，要求集合的元素必须实现Comparable接口 &lt;? super T&gt;，在实现Comparable接口，可以指定Comparable&lt;类型实参&gt;为T或T的父类。 （3）public static boolean disjoint(Collection&lt;?&gt; c1, Collection&lt;?&gt; c2) 判断c1和c2没有交集就为true （4）public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T max(Collection&lt;? extends T&gt; coll) 求coll集合中最大元素 &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt;：要求T或T的父类实现Comparable接口 因为找最大值需要比较大小 （5）public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List list) 给list集合排序 &lt;T extends Comparable&lt;? super T&gt;&gt;：要求T或T的父类实现Comparable接口 （6）public static Collection synchronizedCollection(Collection c) 以synchronizedXX开头的方法，表示把某种非线程安全集合转为一个线程安全的集合。 （7）public static List unmodifiableList(List&lt;? extends T&gt; list) 以unmodifiableXx开头的方法，表示返回一个“只读”的集合。 第十八章 设计模式18.1 模板设计模式（了解）1、当解决某个问题，或者完成某个功能时，主体的算法结构（步骤）是确定的，只是其中的一个或者几个小的步骤不确定，要有使用者（子类）来确定时，就可以使用模板设计模式 2、示例代码：计算任意一段代码的运行时间 java123456789101112131415161718//模板类public abstract class CalTime&#123; public long getTime()&#123; //1、获取开始时间 long start = System.currentTimeMills(); //2、运行xx代码：这个是不确定的 doWork(); //3、获取结束时间 long end = System.currentTimeMills(); //4、计算时间差 return end - start; &#125; protected abstract void doWork();&#125; 使用模板类： java12345public class MyCalTime extends CalTime&#123; protected void doWork()&#123; //....需要计算运行时间的代码 &#125;&#125; 测试类 java123456public class Test&#123; public static void main(String[] args)&#123; MyCalTime my = new MyCalTime(); System.out.println(\"运行时间：\" + my.getTime()); &#125;&#125; 18.2 单例设计模式单例：整个系统中，某个类型的对象只有一个。 1、饿汉式 （1）枚举式 java123public enum Single&#123; INSTANCE&#125; （2）形式二 java123456public class Single&#123; public static final Single INSTANCE = new Single(); private Single()&#123; &#125;&#125; （3）形式三 java123456789public class Single&#123; private static final Single INSTANCE = new Single(); private Single()&#123; &#125; public static Single getInstance()&#123; return INSTANCE; &#125;&#125; 2、懒汉式 （1）内部类形式 java123456789101112public class Single&#123; private Single()&#123;&#125; private static class Inner&#123; static final Single INSTANCE = new Single(); &#125; public static Single getInstance()&#123; return Inner.INSTANCE; &#125; &#125; （2）形式二 java123456789101112131415public class Single&#123; private static Single instance; private Single()&#123;&#125; public static Single getInstance()&#123; if(instance == null)&#123; synchronized(Single.class)&#123; if(instance == null)&#123; instance = new Single(); &#125; &#125; &#125; return instance; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://www.htmler.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.htmler.cn/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://www.htmler.cn/categories/java/"}]},{"title":"websocket + TLS带伪装V2ray","slug":"TLS带伪装V2ray","date":"2020-05-04T16:55:21.000Z","updated":"2020-05-06T04:01:12.815Z","comments":true,"path":"posts/8826f1ea.html","link":"","permalink":"http://www.htmler.cn/posts/8826f1ea.html","excerpt":"","text":"近期的科学上网难度增大，各大论坛里因为ip被和谐可谓是一片哀嚎，所以流量伪装显得格外重要，伪装的原理就是将梯子的流量代理到能正常访问的网站 准备事项一、服务器想要自己搭建科学上的梯子，首先要有一台能够上外网的服务器，在购买服务器方面，我之前有用过 BandwagonHost 也就是大家说的搬瓦工，也用过vultr，最近入手一台亚马逊的EC2,先说说优缺点吧 搬瓦工： 针对中国网络特别优化，网速很给力。支持支付宝，换ip需要手续费 官方网址 vultr: 支持支付宝和微信，随时、免费更换ip和机房,随时销毁vps，销毁后不计费,最低月资费$2.5起，Vultr服务器没有针对中国网络做优化 官方网址 AWS: 信用卡注册，首年$1用一年(到期前记得注销账号)，每个月12G流量/750H，ip免费任意换 官方网址 优劣势对比明显，新手的话，建议aws的ec2，12G流量一般还是够用了，如果经常大流量挂梯子的话建议随时关注消费情况，控制台可以查看实时消费 二、域名首先声明，该域名不需要备案，也不建议备案，道理大家都懂，域名租用的话，渠道很多，阿里的 万网 ,我一般是去 西部数码，做伪装的域名不用选太好，照最简易的挑就好，当然，土豪随意 操作步骤一、安装v2raysudo命令切换到管理员，这里使用了github 大佬 提供的一键脚本,在此感谢，命令行执行：bash1bash &lt;(curl -s -L https://git.io/v2ray.sh) ps: 安装过程建议全程Enter 如果提示 curl: command not found ，那是因为你的 VPS 没装 Curlubuntu/debian 系统安装 Curl 方法: apt-get update -y &amp;&amp; apt-get install curl -ycentos 系统安装 Curl 方法: yum update -y &amp;&amp; yum install curl -y安装好 curl 之后就能安装脚本了 安装完以后，使用v2ray命令可以进行相关操作Code123456789101112131415161718192021 1. 查看 V2Ray 配置 2. 修改 V2Ray 配置 3. 下载 V2Ray 配置 / 生成配置信息链接 / 生成二维码链接 4. 查看 Shadowsocks 配置 / 生成二维码链接 5. 修改 Shadowsocks 配置 6. 查看 MTProto 配置 / 修改 MTProto 配置 7. 查看 Socks5 配置 / 修改 Socks5 配置 8. 启动 / 停止 / 重启 / 查看日志 9. 更新 V2Ray / 更新 V2Ray 管理脚本10. 卸载 V2Ray11. 其他 在这里我们输入2回车，修改传输协议，继续输入2回车Code1234567891011121314151617181920212223242526272829303132 1. TCP 2. TCP_HTTP 3. WebSocket 4. WebSocket + TLS 5. HTTP/2 6. mKCP 7. mKCP_utp 8. mKCP_srtp 9. mKCP_wechat-video10. mKCP_dtls11. mKCP_wireguard12. QUIC13. QUIC_utp14. QUIC_srtp15. QUIC_wechat-video16. QUIC_dtls17. QUIC_wireguard18. TCP_dynamicPort19. TCP_HTTP_dynamicPort20. WebSocket_dynamicPort21. mKCP_dynamicPort22. mKCP_utp_dynamicPort23. mKCP_srtp_dynamicPort24. mKCP_wechat-video_dynamicPort25. mKCP_dtls_dynamicPort26. mKCP_wireguard_dynamicPort27. QUIC_dynamicPort28. QUIC_utp_dynamicPort29. QUIC_srtp_dynamicPort30. QUIC_wechat-video_dynamicPort31. QUIC_dtls_dynamicPort32. QUIC_wireguard_dynamicPort 选择 WebSocket + TLS协议，于是输入4回车，这时候会提示否有域名，输入Y回车，接着提示后续工作是否自动进行，输入N回车 二、域名DNS解析到域名控制台里面，将域名解析到服务器IP,如(192.168.1.1)，添加2条记录值 记录类型 主机记录 解析线路(isp) 记录值 A @ 默认 192.168.1.1 A www 默认 192.168.1.1 三、生成域名证书使用certbot生成免费证书，这样做是为了更稳定bash1234# 安装certbotyum install -y python3 &amp;&amp; pip3 install certbot# 生成证书,将htmler.cn替换为自己域名certbot certonly --standalone -d htmler.cn -d www.htmler.cn 注意：这一步需要关闭占用80/443端口的程序，如果生成失败，则多尝试几次 生成成功以后，记录下证书存放路径备用 四、创建项目、代理目录 代理目录：该目录作为代理转发使用，建议创建在根目录，同时不要删除 bash1mkdir /dontDelete 项目目录： 该目录存放真实项目 bash12# xxx替换为自己取得名字mkdir -p /www/xxx 接下来将项目部署到/www/xxx目录 五、安装/配置nginx安装nginx的教程可以参考 nginx安装 ,安装以后修改配置文件,nginx配置文件默认存放在 /etc/nginx/nginx.confbash1234567891011121314151617181920212223242526272829303132333435363738server &#123; listen 80; # 端口号 server_name htmler.cn www.htmler.cn; # htmler.cn替换为自己域名 rewrite ^(.*) https://$server_name$1 permanent; location / &#123; root /www/xxx; # /www/xxx替换为项目地址 index index.html; &#125;&#125;server &#123; listen 443 ssl; server_name www.htmler.cn htmler.cn; # htmler.cn替换为自己域名 charset utf-8; ssl_certificate /etc/letsencrypt/live/www.htmler.cn/fullchain.pem; # 这里替换为自己fullchain.pem地址 ssl_certificate_key /etc/letsencrypt/live/www.htmler.cn/privkey.pem; # 这里替换为自己privkey.pem地址 ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-SHA384; ssl_ecdh_curve secp384r1; ssl_prefer_server_ciphers on; ssl_session_cache shared:SSL:10m; ssl_session_timeout 10m; ssl_session_tickets off; keepalive_timeout 70; location / &#123; root /www/xxx; # /www/xxx替换为项目地址 index index.html; &#125; location /dontDelete &#123; # 这里改为自己创建的代理目录 proxy_redirect off; proxy_pass http://127.0.0.1:443; # 443改为v2ray的端口，默认为443，可以通过v2ray命令查看 proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125; 修改好以后按下esc键，输入:wq回车保存，然后重新加载一下nginx配置文件或者重启Nginx，附上几个nginx常用命令bash12345678# 启动命令nginx# 重载配置文件nginx -s reload# 重启nginx -s reopen# 停止nginx -s stop 以上步骤完成以后通过域名边可以访问自己项目了 六、修改v2ray配置使用命令： vi /etc/v2ray/config.json 修改streamSettings字段bash1234567\"streamSettings\": &#123; \"network\": \"ws\", # 载体配置段，设置为websocket \"wsSettings\": &#123; \"path\": \"/dontDelete\" # 与nginx中的路径保持一致 &#125; &#125;,\"listen\": \"127.0.0.1\" # 出于安全考虑，只接受本地连接 修改好以后，重启v2ray，依次输入v2ray回车，输入8回车，输入重启序号回车 以上步骤完成以后，通过 http://www.htmler.cn/dontDelete 访问，如果页面提示Bad Request则证明伪装成功 客户端设置 在服务器端输入v2ray回车，再输入1回车便可以获取后续配置采参数 以Windows平台的V2RayW软件为例，右键托盘图标，点击“配置”。在弹框中新建服务器，输入服务器ip，端口写443，把用户id、额外id信息填上，网络类型选择”ws”。接着点“传输设置”，找到“websocket”，路径一栏输入nginx和v2ray中的路径，例如“/dontDelete”；http头部输入：bash123&#123; \"Host\":\"www.htmler.cn\"&#125; ps： htmler.cn替换为你的域名接着点击“tls”，勾选：启用传输层加密tls、允许不安全的加密方式、允许不安全连接，在“服务器域名”的输入框中输入域名","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.htmler.cn/categories/Linux/"}],"tags":[{"name":"v2ray","slug":"v2ray","permalink":"http://www.htmler.cn/tags/v2ray/"},{"name":"梯子","slug":"梯子","permalink":"http://www.htmler.cn/tags/梯子/"},{"name":"Nginx","slug":"Nginx","permalink":"http://www.htmler.cn/tags/Nginx/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://www.htmler.cn/categories/Linux/"}]},{"title":"python自动化打包部署","slug":"python自动化打包部署","date":"2020-04-12T09:51:13.000Z","updated":"2020-04-28T05:03:32.990Z","comments":true,"path":"posts/eb712ecd.html","link":"","permalink":"http://www.htmler.cn/posts/eb712ecd.html","excerpt":"","text":"基于python实现前端项目打包部署，使用方法： 本地安装python环境，并且配置好环境变量，不会的点我 在本地新建auto.py然后粘贴进以下脚本，然后修改顶部注释部分的相关参数 打开命令行工具，cd到auto.py所在目录，然后python auto.py回车执行脚本 按照提示输入服务器登录密码，回车 python123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169import paramikoimport os# —————————————————————此处配置打包相关参数———————————————————————# 本地项目目录project_path = r'E:\\projects\\cloud-music'# 项目打包后的目录，一般为dist或者buildbuild_path = 'build'# 服务器目录remote_path = r'/www/cloud-music'# 服务器地址hostname = '192.168.1.225'# 登陆服务器的用户名username = 'fuck'# ————————————————————————配置结束—————————————————————————————class SSHConnect: # 定义一个私有变量，用来保存ssh连接通道，初始化为None __transport = None # 初始化构造函数（主机，用户名，密码，端口，默认22） def __init__(self, hostname, username, password, port=22): self.hostname = hostname self.port = port self.username = username self.password = password # 创建 ssh 连接通道 self.connect() # 建立ssh 连接通道，并绑定在 __transport 上 def connect(self): try: # 设置SSH 连接的远程主机地址和端口 self.__transport = paramiko.Transport((self.hostname, self.port)) # 通过用户名和密码连接SSH服务端 self.__transport.connect(username=self.username, password=self.password) except Exception as e: # 连接出错 print(e) # 执行linux命令 def exec(self, command): # 创建 ssh 客户端 ssh = paramiko.SSHClient() # 指定连接的通道 ssh._transport = self.__transport # 打开一个Channel并执行命令, 调用 exec_command 方法执行命令 stdin, stdout, stderr = ssh.exec_command(command) # 获取命令结果，返回是二进制，需要编码一下 res = stdout.read().decode('utf-8') # 获取错误信息 error = stderr.read().decode('utf-8') # 如果没出错 if error.strip(): # 返回错误信息 return error else: # 返回结果 return res # 前端打包（入参work_path为项目目录） def build(self, work_path): # 开始打包 print('_______________________________________________') print('正在打包...') # 打包命令 cmd = 'npm run build' # 切换到需要项目目录 os.chdir(work_path) # 当前项目目录下执行打包命令 if os.system(cmd) == 0: # 打包完成 print('打包完成！') print('开始上传文件...') # 文件上传 def upload(self, local_path, target_path): # 判断路径问题 if not os.path.exists(local_path): return print('local path is not exist') # 实例化一个 sftp 对象,指定连接的通道 sftp = paramiko.SFTPClient.from_transport(self.__transport) # 打包后的文件路径 local_path = os.path.join(local_path, build_path) # 本地路径转换，将windows下的 \\ 转成 / local_path = '/'.join(local_path.split('\\\\')) # 递归上传文件 self.upload_file(sftp, local_path, target_path) print('Everything is ok,Have a nice day!') # 关闭连接 self.close() # 递归上传文件 def upload_file(self, sftp, local_path, target_path): # 判断当前路径是否是文件夹 if not os.path.isdir(local_path): # 如果是文件，获取文件名 file_name = os.path.basename(local_path) # 检查服务器文件夹是否存在 self.check_remote_dir(sftp, target_path) # 服务器创建文件 target_file_path = os.path.join(target_path, file_name).replace('\\\\', '/') # 上传到服务器 sftp.put(local_path, target_file_path) else: # 查看当前文件夹下的子文件 file_list = os.listdir(local_path) # 遍历子文件 for p in file_list: # 拼接当前文件路径 current_local_path = os.path.join(local_path, p).replace('\\\\', '/') # 拼接服务器文件路径 current_target_path = os.path.join(target_path, p).replace('\\\\', '/') # 如果已经是文件，服务器就不需要创建文件夹了 if os.path.isfile(current_local_path): # 提取当前文件所在的文件夹 current_target_path = os.path.split(current_target_path)[0] # 递归判断 self.upload_file(sftp, current_local_path, current_target_path) # 创建服务器文件夹 def check_remote_dir(self, sftp, target_path): try: # 判断文件夹是否存在 sftp.stat(target_path) except IOError: # 创建文件夹 self.exec(r'mkdir -p %s ' % target_path) # 自动化打包部署 def auto_deploy(self, local_path, target_path): # 打包构建 self.build(local_path) # 清空文件 self.clear_remote_dir(target_path) # 文件上传 self.upload(local_path, target_path) # 清空文件夹 def clear_remote_dir(self, target_path): if target_path[-1] == '/': cmd = f'rm -rf &#123;target_path&#125;*' else: cmd = f'rm -rf &#123;target_path&#125;/*' self.exec(cmd) # 关闭连接 def close(self): self.__transport.close() # 销毁实例 def __del__(self): self.__transport.close()if __name__ == '__main__': # 实例化 password = input(\"请输入服务器连接密码：\") ssh = SSHConnect(hostname=hostname, username=username, password=password) # 自动打包部署 ssh.auto_deploy(project_path, remote_path)","categories":[{"name":"Python","slug":"Python","permalink":"http://www.htmler.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.htmler.cn/tags/Python/"},{"name":"部署","slug":"部署","permalink":"http://www.htmler.cn/tags/部署/"},{"name":"自动化","slug":"自动化","permalink":"http://www.htmler.cn/tags/自动化/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"http://www.htmler.cn/categories/Python/"}]},{"title":"pm2实现自动化部署","slug":"pm2实现自动化部署","date":"2020-03-01T07:21:45.000Z","updated":"2020-04-28T05:03:32.986Z","comments":true,"path":"posts/5ce4dbbc.html","link":"","permalink":"http://www.htmler.cn/posts/5ce4dbbc.html","excerpt":"","text":"基于git，使用node的pm2实现项目的自动化部署，服务器环境以centos为例 环境配置因为是基于git和node，所以本机和部署项目的服务器都需要安装node和git，然后安装pm2本地环境比较简单，不赘述，centos下可以借助yum来安装bash123456yum install -y nodejs# 装完以后继续安装pm2，本地环境同理npm install pm2 -g# 接下来安装gityum install -y git# 安装完以后可以git -v查看版本 配置ssh key这一步是为了让本地计算机、github、服务器之间建立连接，因此本机和部署项目的服务器都需要添加ssh，这个比较简单，不会的可以参考Github 简明教程 添加pm2配置文件在本地项目根目录添加ecosystem.json！！！注意：因为是json格式，实际使用请删除注释javascript1234567891011121314151617181920212223242526272829303132333435&#123; \"apps\":[ &#123; \"name\": \"app\", // 项目名称 \"script\": \"app.js\", // 入口文件 \"env\": &#123; \"COMMON_VARIABLE\": \"true\" &#125;, \"env_production\": &#123; \"NODE_ENV\": \"production\" // 环境变量 &#125; &#125; ], // 环境部署的配置 \"deploy\": &#123; \"production\": &#123; // 登录服务器的用户名 \"user\":\"slevin\", // 服务器ip \"host\": [\"12.34.56.78\"], // 服务器ssh登录端口，未修改的话一般默认为22 \"port\": \"22\", // 指定拉取的分支 \"ref\": \"origin/master\", // 远程仓库地址 \"repo\": \"git@github.com:yourName/xxx.git\", // 指定代码拉取到服务器的目录 \"path\": \"/home/projects/xxx\", \"ssh_options\": \"StrictHostKeyChecking=no\", \"env\": &#123; \"NODE_ENV\": \"production\" &#125; &#125; &#125;&#125; 本地push与服务器端pull github上创建仓库，比如xxx 在本地项目根目录执行以下命令 bash1234git init # 初始化仓库git commit -m \"init project\" # 添加提交信息git remote add origin git@github.com:yourName/xxx.git # 指定remote地址git push -u origin master # 推送 在服务器端 bash1234cd /home/projects/git clone git@github.com:yourName/xxx.git # 克隆github项目，(非node项目略过下面2步)cd xxxnpm install # 安装依赖 ps：以上步骤首次操作可能会提示你输入github登陆密码 自动化部署bash12pm2 deploy ecosystem.json production setup # 首次部署执行一次即可pm2 deploy ecosystem.json production 后续开发中，提交本地代码到remote后，只需要执行pm2 deploy ecosystem.json production即可 问题处理 提示bash: pm2: command not found post-deploy hook failed Deploy failed 1即是：找不到pm2命令，解决办法，添加pm2的软链接，在服务器端执行：bash123456# 查找pm2的路径whereis pm2# pm2: /usr/bin/pm2 /root/node/bin/pm2，添加软连接#sudo ln -s [查找到的链接] /usr/bin/pm2# 即是： sudo ln -s /usr/bin/pm2 /root/node/bin/pm2 /usr/bin/pm2","categories":[{"name":"node","slug":"node","permalink":"http://www.htmler.cn/categories/node/"}],"tags":[{"name":"pm2","slug":"pm2","permalink":"http://www.htmler.cn/tags/pm2/"},{"name":"部署","slug":"部署","permalink":"http://www.htmler.cn/tags/部署/"}],"keywords":[{"name":"node","slug":"node","permalink":"http://www.htmler.cn/categories/node/"}]},{"title":"React状态逻辑复用","slug":"React状态逻辑复用","date":"2020-02-15T06:22:33.000Z","updated":"2020-02-15T11:58:37.598Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"http://www.htmler.cn/posts/undefined.html","excerpt":"","text":"Mixin关于MixinMixin（混入）是一种通过扩展收集功能的方式，它本质上是将一个对象的属性拷贝到另一个对象上面去，不过你可以拷贝任意多个对象的任意方法到一个新对象上去，这是继承所不能实现的。它的出现主要就是为了解决代码复用问题。 写一个简单的Mixin方法：javascript12345678910111213141516function setMixin(target, mixin) &#123; if (arguments[2]) &#123; for (var i = 2, len = arguments.length; i &lt; len; i++) &#123; target.prototype[arguments[i]] = mixin.prototype[arguments[i]]; &#125; &#125; else &#123; for (var methodName in mixin.prototype) &#123; if (!Object.hasOwnProperty(target.prototype, methodName)) &#123; target.prototype[methodName] = mixin.prototype[methodName]; &#125; &#125; &#125;&#125;setMixin(User,LogMixin,'actionLog');setMixin(Goods,LogMixin,'requestLog'); Mixin应用React也提供了Mixin的实现，如果完全不同的组件有相似的功能，我们可以引入来实现代码复用，当然只有在使用createClass来创建React组件时才可以使用，因为在React组件的es6写法中它已经被废弃掉了。例如下面的例子，很多组件或页面都需要记录用户行为，性能指标等。如果我们在每个组件都引入写日志的逻辑，会产生大量重复代码，通过Mixin我们可以解决这一问题：javascript12345678910111213141516171819202122232425const LogMixin = &#123; log: function() &#123; console.log('log'); &#125;, componentDidMount: function() &#123; console.log('in'); &#125;, componentWillUnmount: function() &#123; console.log('out'); &#125;&#125;;const User = React.createClass(&#123; mixins: [LogMixin], render: function() &#123; return (&lt;div&gt;...&lt;/div&gt;) &#125;&#125;);const Goods = React.createClass(&#123; mixins: [LogMixin], render: function() &#123; return (&lt;div&gt;...&lt;/div&gt;) &#125;&#125;); 缺点 Mixin 可能会相互依赖，相互耦合，不利于代码维护 不同的Mixin中的方法可能会相互冲突 Mixin非常多时，组件是可以感知到的，甚至还要为其做相关处理，这样会给代码造成滚雪球式的复杂性 HOC关于HOC 高阶组件可以看作React对装饰模式的一种实现，高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。 HOC是React中的高级技术，用来重用组件逻辑。但高阶组件本身并不是React API。它只是一种模式，这种模式是由React自身的组合性质必然产生的javascript12345678910function visible(WrappedComponent) &#123; return class extends Component &#123; render() &#123; const &#123; visible, ...props &#125; = this.props; if (visible === false) return null; return &lt;WrappedComponent &#123;...props&#125; /&gt;; &#125; &#125;&#125; 上面的代码就是一个HOC的简单应用，函数接收一个组件作为参数，并返回一个新组件，新组建可以接收一个visible props，根据visible的值来判断是否渲染Visible。 实现方式属性代理函数返回一个我们自己定义的组件，然后在render中返回要包裹的组件，这样我们就可以代理所有传入的props，并且决定如何渲染，实际上 ，这种方式生成的高阶组件就是原组件的父组件，上面的函数visible就是一个HOC属性代理的实现方式 javascript1234567function proxyHOC(WrappedComponent) &#123; return class extends Component &#123; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; /&gt;; &#125; &#125;&#125; 对比原生组件增强的项： 可操作所有传入的props 可操作组件的生命周期 可操作组件的static方法 获取refs 反向继承返回一个组件，继承原组件，在render中调用原组件的render。由于继承了原组件，能通过this访问到原组件的生命周期、props、state、render等，相比属性代理它能操作更多的属性。 javascript1234567function inheritHOC(WrappedComponent) &#123; return class extends WrappedComponent &#123; render() &#123; return super.render(); &#125; &#125;&#125; 对比原生组件增强的项： 可操作所有传入的props 可操作组件的生命周期 可操作组件的static方法 获取refs 可操作state 可以渲染劫持 实际应用组合渲染可使用任何其他组件和原组件进行组合渲染，达到样式、布局复用等效果。 通过属性代理实现 javascript12345678910function stylHOC(WrappedComponent) &#123; return class extends Component &#123; render() &#123; return (&lt;div&gt; &lt;div className=\"title\"&gt;&#123;this.props.title&#125;&lt;/div&gt; &lt;WrappedComponent &#123;...this.props&#125; /&gt; &lt;/div&gt;); &#125; &#125;&#125; 通过反向继承实现 javascript12345678910function styleHOC(WrappedComponent) &#123; return class extends WrappedComponent &#123; render() &#123; return &lt;div&gt; &lt;div className=\"title\"&gt;&#123;this.props.title&#125;&lt;/div&gt; &#123;super.render()&#125; &lt;/div&gt; &#125; &#125;&#125; 条件渲染 通过属性代理实现 javascript12345678function visibleHOC(WrappedComponent) &#123; return class extends Component &#123; render() &#123; if (this.props.visible === false) return null; return &lt;WrappedComponent &#123;...props&#125; /&gt;; &#125; &#125;&#125; 通过反向继承实现 javascript1234567891011function visibleHOC(WrappedComponent) &#123; return class extends WrappedComponent &#123; render() &#123; if (this.props.visible === false) &#123; return null &#125; else &#123; return super.render() &#125; &#125; &#125;&#125; 操作props可以对传入组件的props进行增加、修改、删除或者根据特定的props进行特殊的操作。 通过属性代理实现javascript1234567891011function proxyHOC(WrappedComponent) &#123; return class extends Component &#123; render() &#123; const newProps = &#123; ...this.props, user: 'ConardLi' &#125; return &lt;WrappedComponent &#123;...newProps&#125; /&gt;; &#125; &#125;&#125; 获取refs高阶组件中可获取原组件的ref，通过ref获取组件实力，如下面的代码，当程序初始化完成后调用原组件的log方法 通过属性代理实现javascript12345678910function refHOC(WrappedComponent) &#123; return class extends Component &#123; componentDidMount() &#123; this.wapperRef.log() &#125; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; ref=&#123;ref =&gt; &#123; this.wapperRef = ref &#125;&#125; /&gt;; &#125; &#125;&#125; 状态管理将原组件的状态提取到HOC中进行管理，如下面的代码，我们将Input的value提取到HOC中进行管理，使它变成受控组件，同时不影响它使用onChange方法进行一些其他操作。基于这种方式，我们可以实现一个简单的双向绑定，具体请看双向绑定。 通过属性代理实现javascript1234567891011121314151617181920212223242526272829303132333435function proxyHoc(WrappedComponent) &#123; return class extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; value: '' &#125;; &#125; onChange = (event) =&gt; &#123; const &#123; onChange &#125; = this.props; this.setState(&#123; value: event.target.value, &#125;, () =&gt; &#123; if(typeof onChange ==='function')&#123; onChange(event); &#125; &#125;) &#125; render() &#123; const newProps = &#123; value: this.state.value, onChange: this.onChange, &#125; return &lt;WrappedComponent &#123;...this.props&#125; &#123;...newProps&#125; /&gt;; &#125; &#125;&#125;class HOC extends Component &#123; render() &#123; return &lt;input &#123;...this.props&#125;&gt;&lt;/input&gt; &#125;&#125;export default proxyHoc(HOC); 操作state上面的例子通过属性代理利用HOC的state对原组件进行了一定的增强，但并不能直接控制原组件的state，而通过反向继承，我们可以直接操作原组件的state。但是并不推荐直接修改或添加原组件的state，因为这样有可能和组件内部的操作构成冲突。 通过反向继承实现javascript12345678910111213function debugHOC(WrappedComponent) &#123; return class extends WrappedComponent &#123; render() &#123; console.log('props', this.props); console.log('state', this.state); return ( &lt;div className=\"debuging\"&gt; &#123;super.render()&#125; &lt;/div&gt; ) &#125; &#125;&#125; 上面的HOC在render中将props和state打印出来，可以用作调试阶段，当然你可以在里面写更多的调试代码。想象一下，只需要在我们想要调试的组件上加上@debug就可以对该组件进行调试，而不需要在每次调试的时候写很多冗余代码。(如果你还不知道怎么使用HOC，请👇如何使用HOC) 渲染劫持高阶组件可以在render函数中做非常多的操作，从而控制原组件的渲染输出。只要改变了原组件的渲染，我们都将它称之为一种渲染劫持。实际上，上面的组合渲染和条件渲染都是渲染劫持的一种，通过反向继承，不仅可以实现以上两点，还可直接增强由原组件render函数产生的React元素。 通过反向继承实现javascript1234567891011121314function hijackHOC(WrappedComponent) &#123; return class extends WrappedComponent &#123; render() &#123; const tree = super.render(); let newProps = &#123;&#125;; if (tree &amp;&amp; tree.type === 'input') &#123; newProps = &#123; value: '渲染被劫持了' &#125;; &#125; const props = Object.assign(&#123;&#125;, tree.props, newProps); const newTree = React.cloneElement(tree, props, tree.props.children); return newTree; &#125; &#125;&#125; 如何使用？上面的示例代码都写的是如何声明一个HOC，HOC实际上是一个函数，所以我们将要增强的组件作为参数调用HOC函数，得到增强后的组件。javascript123456class myComponent extends Component &#123; render() &#123; return (&lt;span&gt;原组件&lt;/span&gt;) &#125;&#125;export default inheritHOC(myComponent); Compose在实际应用中，一个组件可能被多个HOC增强，我们使用的是被所有的HOC增强后的组件假设现在我们有logger，visible，style等多个HOC，现在要同时增强一个Input组件：logger(visible(style(Input)))这种代码非常的难以阅读，我们可以手动封装一个简单的函数组合工具，将写法改写如下：javascript12const compose = (...fns) =&gt; fns.reduce((f, g) =&gt; (...args) =&gt; g(f(...args)));compose(logger,visible,style)(Input); compose函数返回一个所有函数组合后的函数，compose(f, g, h) 和 (…args) =&gt; f(g(h(…args)))是一样的。很多第三方库都提供了类似compose的函数，例如lodash.flowRight，Redux提供的combineReducers函数等。 Decorators我们还可以借助ES7为我们提供的Decorators来让我们的写法变的更加优雅：javascript123456@logger@visible@styleclass Input extends Component &#123; // ...&#125; Decorators是ES7的一个提案，还没有被标准化，但目前Babel转码器已经支持，我们需要提前配置babel-plugin-transform-decorators-legacy：“plugins”: [“transform-decorators-legacy”]还可以结合上面的compose函数使用：javascript12345const hoc = compose(logger, visible, style);@hocclass Input extends Component &#123; // ...&#125; HOC的实际应用下面是一些我在生产环境中实际对HOC的实际应用场景，由于文章篇幅原因，代码经过很多简化，如有问题欢迎在评论区指出： 日志打点实际上这属于一类最常见的应用，多个组件拥有类似的逻辑，我们要对重复的逻辑进行复用， 官方文档中CommentList的示例也是解决了代码复用问题，写的很详细某些页面需要记录用户行为，性能指标等等，通过高阶组件做这些事情可以省去很多重复代码。javascript123456789101112131415161718function logHoc(WrappedComponent) &#123; return class extends Component &#123; componentWillMount() &#123; this.start = Date.now(); &#125; componentDidMount() &#123; this.end = Date.now(); console.log(`$&#123;WrappedComponent.dispalyName&#125; 渲染时间：$&#123;this.end - this.start&#125; ms`); console.log(`$&#123;user&#125;进入$&#123;WrappedComponent.dispalyName&#125;`); &#125; componentWillUnmount() &#123; console.log(`$&#123;user&#125;退出$&#123;WrappedComponent.dispalyName&#125;`); &#125; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; /&gt; &#125; &#125;&#125; 可用、权限控制javascript1234567891011function auth(WrappedComponent) &#123; return class extends Component &#123; render() &#123; const &#123; visible, auth, display = null, ...props &#125; = this.props; if (visible === false || (auth &amp;&amp; authList.indexOf(auth) === -1)) &#123; return display &#125; return &lt;WrappedComponent &#123;...props&#125; /&gt;; &#125; &#125;&#125; authList是我们在进入程序时向后端请求的所有权限列表，当组件所需要的权限不列表中，或者设置的 visible是false，我们将其显示为传入的组件样式，或者null。我们可以将任何需要进行权限校验的组件应用HOC：javascript1234567@authclass Input extends Component &#123; ... &#125;@authclass Button extends Component &#123; ... &#125;&lt;Button auth=\"user/addUser\"&gt;添加用户&lt;/Button&gt;&lt;Input auth=\"user/search\" visible=&#123;false&#125; &gt;添加用户&lt;/Input&gt; 双向绑定在vue中，绑定一个变量后可实现双向数据绑定，即表单中的值改变后绑定的变量也会自动改变。而React中没有做这样的处理，在默认情况下，表单元素都是非受控组件。给表单元素绑定一个状态后，往往需要手动书写onChange方法来将其改写为受控组件，在表单元素非常多的情况下这些重复操作是非常痛苦的。我们可以借助高阶组件来实现一个简单的双向绑定，代码略长，可以结合下面的思维导图进行理解。 首先我们自定义一个Form组件，该组件用于包裹所有需要包裹的表单组件，通过contex向子组件暴露两个属性：model：当前Form管控的所有数据，由表单name和value组成，如{name:’ConardLi’,pwd:’123’}。model可由外部传入，也可自行管控。changeModel：改变model中某个name的值。 javascript123456789101112131415161718192021222324252627282930313233343536373839class Form extends Component &#123; static childContextTypes = &#123; model: PropTypes.object, changeModel: PropTypes.func &#125; constructor(props, context) &#123; super(props, context); this.state = &#123; model: props.model || &#123;&#125; &#125;; &#125; componentWillReceiveProps(nextProps) &#123; if (nextProps.model) &#123; this.setState(&#123; model: nextProps.model &#125;) &#125; &#125; changeModel = (name, value) =&gt; &#123; this.setState(&#123; model: &#123; ...this.state.model, [name]: value &#125; &#125;) &#125; getChildContext() &#123; return &#123; changeModel: this.changeModel, model: this.props.model || this.state.model &#125;; &#125; onSubmit = () =&gt; &#123; console.log(this.state.model); &#125; render() &#123; return &lt;div&gt; &#123;this.props.children&#125; &lt;button onClick=&#123;this.onSubmit&#125;&gt;提交&lt;/button&gt; &lt;/div&gt; &#125;&#125; 下面定义用于双向绑定的HOC，其代理了表单的onChange属性和value属性：发生onChange事件时调用上层Form的changeModel方法来改变context中的model。在渲染时将value改为从context中取出的值。 javascript1234567891011121314151617181920212223242526272829303132function proxyHoc(WrappedComponent) &#123; return class extends Component &#123; static contextTypes = &#123; model: PropTypes.object, changeModel: PropTypes.func &#125; onChange = (event) =&gt; &#123; const &#123; changeModel &#125; = this.context; const &#123; onChange &#125; = this.props; const &#123; v_model &#125; = this.props; changeModel(v_model, event.target.value); if(typeof onChange === 'function')&#123;onChange(event);&#125; &#125; render() &#123; const &#123; model &#125; = this.context; const &#123; v_model &#125; = this.props; return &lt;WrappedComponent &#123;...this.props&#125; value=&#123;model[v_model]&#125; onChange=&#123;this.onChange&#125; /&gt;; &#125; &#125;&#125;@proxyHocclass Input extends Component &#123; render() &#123; return &lt;input &#123;...this.props&#125;&gt;&lt;/input&gt; &#125;&#125; 上面的代码只是简略的一部分，除了input，我们还可以将HOC应用在select等其他表单组件，甚至还可以将上面的HOC兼容到span、table等展示组件，这样做可以大大简化代码，让我们省去了很多状态管理的工作，使用如下： javascript12345678910export default class extends Component &#123; render() &#123; return ( &lt;Form &gt; &lt;Input v_model=\"name\"&gt;&lt;/Input&gt; &lt;Input v_model=\"pwd\"&gt;&lt;/Input&gt; &lt;/Form&gt; ) &#125;&#125; 表单校验基于上面的双向绑定的例子，我们再来一个表单验证器，表单验证器可以包含验证函数以及提示信息，当验证不通过时，展示错误信息：javascript12345678910111213141516171819202122232425262728293031323334function validateHoc(WrappedComponent) &#123; return class extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; error: '' &#125; &#125; onChange = (event) =&gt; &#123; const &#123; validator &#125; = this.props; if (validator &amp;&amp; typeof validator.func === 'function') &#123; if (!validator.func(event.target.value)) &#123; this.setState(&#123; error: validator.msg &#125;) &#125; else &#123; this.setState(&#123; error: '' &#125;) &#125; &#125; &#125; render() &#123; return &lt;div&gt; &lt;WrappedComponent onChange=&#123;this.onChange&#125; &#123;...this.props&#125; /&gt; &lt;div&gt;&#123;this.state.error || ''&#125;&lt;/div&gt; &lt;/div&gt; &#125; &#125;&#125;const validatorName = &#123; func: (val) =&gt; val &amp;&amp; !isNaN(val), msg: '请输入数字'&#125;const validatorPwd = &#123; func: (val) =&gt; val &amp;&amp; val.length &gt; 6, msg: '密码必须大于6位'&#125;&lt;HOCInput validator=&#123;validatorName&#125; v_model=\"name\"&gt;&lt;/HOCInput&gt;&lt;HOCInput validator=&#123;validatorPwd&#125; v_model=\"pwd\"&gt;&lt;/HOCInput&gt; 当然，还可以在Form提交的时候判断所有验证器是否通过，验证器也可以设置为数组等等，由于文章篇幅原因，代码被简化了很多，有兴趣的同学可以自己实现。Redux的connect redux中的connect，其实就是一个HOC，下面就是一个简化版的connect实现：javascript1234567891011121314151617181920212223242526272829303132333435export const connect = (mapStateToProps, mapDispatchToProps) =&gt; (WrappedComponent) =&gt; &#123; class Connect extends Component &#123; static contextTypes = &#123; store: PropTypes.object &#125; constructor () &#123; super() this.state = &#123; allProps: &#123;&#125; &#125; &#125; componentWillMount () &#123; const &#123; store &#125; = this.context this._updateProps() store.subscribe(() =&gt; this._updateProps()) &#125; _updateProps () &#123; const &#123; store &#125; = this.context let stateProps = mapStateToProps ? mapStateToProps(store.getState(), this.props): &#123;&#125; let dispatchProps = mapDispatchToProps? mapDispatchToProps(store.dispatch, this.props) : &#123;&#125; this.setState(&#123; allProps: &#123; ...stateProps, ...dispatchProps, ...this.props &#125; &#125;) &#125; render () &#123; return &lt;WrappedComponent &#123;...this.state.allProps&#125; /&gt; &#125; &#125; return Connect&#125; 代码非常清晰，connect函数其实就做了一件事，将mapStateToProps和mapDispatchToProps分别解构后传给原组件，这样我们在原组件内就可以直接用props获取state以及dispatch函数了。 使用HOC的注意事项告诫—静态属性拷贝当我们应用HOC去增强另一个组件时，我们实际使用的组件已经不是原组件了，所以我们拿不到原组件的任何静态属性，我们可以在HOC的结尾手动拷贝他们：javascript12345678910function proxyHOC(WrappedComponent) &#123; class HOCComponent extends Component &#123; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; /&gt;; &#125; &#125; HOCComponent.staticMethod = WrappedComponent.staticMethod; // ... return HOCComponent;&#125; 如果原组件有非常多的静态属性，这个过程是非常痛苦的，而且你需要去了解需要增强的所有组件的静态属性是什么，我们可以使用hoist-non-react-statics来帮助我们解决这个问题，它可以自动帮我们拷贝所有非React的静态方法，使用方式如下：javascript12345678910import hoistNonReactStatic from 'hoist-non-react-statics';function proxyHOC(WrappedComponent) &#123; class HOCComponent extends Component &#123; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; /&gt;; &#125; &#125; hoistNonReactStatic(HOCComponent,WrappedComponent); return HOCComponent;&#125; 告诫—传递refs使用高阶组件后，获取到的ref实际上是最外层的容器组件，而非原组件，但是很多情况下我们需要用到原组件的ref。高阶组件并不能像透传props那样将refs透传，我们可以用一个回调函数来完成ref的传递：javascript12345678910111213141516171819function hoc(WrappedComponent) &#123; return class extends Component &#123; getWrappedRef = () =&gt; this.wrappedRef; render() &#123; return &lt;WrappedComponent ref=&#123;ref =&gt; &#123; this.wrappedRef = ref &#125;&#125; &#123;...this.props&#125; /&gt;; &#125; &#125;&#125;@hocclass Input extends Component &#123; render() &#123; return &lt;input&gt;&lt;/input&gt; &#125;&#125;class App extends Component &#123; render() &#123; return ( &lt;Input ref=&#123;ref =&gt; &#123; this.inpitRef = ref.getWrappedRef() &#125;&#125; &gt;&lt;/Input&gt; ); &#125;&#125; React 16.3版本提供了一个forwardRef API来帮助我们进行refs传递，这样我们在高阶组件上获取的ref就是原组件的ref了，而不需要再手动传递，如果你的React版本大于16.3，可以使用下面的方式:javascript1234567891011function hoc(WrappedComponent) &#123; class HOC extends Component &#123; render() &#123; const &#123; forwardedRef, ...props &#125; = this.props; return &lt;WrappedComponent ref=&#123;forwardedRef&#125; &#123;...props&#125; /&gt;; &#125; &#125; return React.forwardRef((props, ref) =&gt; &#123; return &lt;HOC forwardedRef=&#123;ref&#125; &#123;...props&#125; /&gt;; &#125;);&#125; 告诫—不要在render方法内创建高阶组件React Diff算法的原则是： 使用组件标识确定是卸载还是更新组件 如果组件的和前一次渲染时标识是相同的，递归更新子组件 如果标识不同卸载组件重新挂载新组件 每次调用高阶组件生成的都是是一个全新的组件，组件的唯一标识响应的也会改变，如果在render方法调用了高阶组件，这会导致组件每次都会被卸载后重新挂载。 约定-不要改变原始组件 官方文档对高阶组件的说明： 高阶组件就是一个没有副作用的纯函数。 我们再来看看纯函数的定义： 如果函数的调用参数相同，则永远返回相同的结果。它不依赖于程序执行期间函数外部任何状态或数据的变化，必须只依赖于其输入参数。 该函数不会产生任何可观察的副作用，例如网络请求，输入和输出设备或数据突变。 如果我们在高阶组件对原组件进行了修改，例如下面的代码： javascript1InputComponent.prototype.componentWillReceiveProps = function(nextProps) &#123; ... &#125; 这样就破坏了我们对高阶组件的约定，同时也改变了使用高阶组件的初衷：我们使用高阶组件是为了增强而非改变原组件。 约定-透传不相关的props使用高阶组件，我们可以代理所有的props，但往往特定的HOC只会用到其中的一个或几个props。我们需要把其他不相关的props透传给原组件，如下面的代码： javascript123456789function visible(WrappedComponent) &#123; return class extends Component &#123; render() &#123; const &#123; visible, ...props &#125; = this.props; if (visible === false) return null; return &lt;WrappedComponent &#123;...props&#125; /&gt;; &#125; &#125;&#125; 我们只使用visible属性来控制组件的显示可隐藏，把其他props透传下去。约定-displayName在使用React Developer Tools进行调试时，如果我们使用了HOC，调试界面可能变得非常难以阅读，如下面的代码： javascript123456789101112@visibleclass Show extends Component &#123; render() &#123; return &lt;h1&gt;我是一个标签&lt;/h1&gt; &#125;&#125;@visibleclass Title extends Component &#123; render() &#123; return &lt;h1&gt;我是一个标题&lt;/h1&gt; &#125;&#125; 为了方便调试，我们可以手动为HOC指定一个displayName，官方推荐使用HOCName(WrappedComponentName)： javascript1static displayName = `Visible($&#123;WrappedComponent.displayName&#125;)` 这个约定帮助确保高阶组件最大程度的灵活性和可重用性。 使用HOC的动机回顾下上文提到的 Mixin 带来的风险： Mixin 可能会相互依赖，相互耦合，不利于代码维护 不同的Mixin中的方法可能会相互冲突 Mixin非常多时，组件是可以感知到的，甚至还要为其做相关处理，这样会给代码造成滚雪球式的复杂性 而HOC的出现可以解决这些问题： 高阶组件就是一个没有副作用的纯函数，各个高阶组件不会互相依赖耦合 高阶组件也有可能造成冲突，但我们可以在遵守约定的情况下避免这些行为 高阶组件并不关心数据使用的方式和原因，而被包裹的组件也不关心数据来自何处。高阶组件的增加不会为原组件增加负担 HOC的缺陷 HOC需要在原组件上进行包裹或者嵌套，如果大量使用HOC，将会产生非常多的嵌套，这让调试变得非常困难。 HOC可以劫持props，在不遵守约定的情况下也可能造成冲突。 HooksHooks是React v16.7.0-alpha中加入的新特性。它可以让你在class以外使用state和其他React特性。使用Hooks，你可以在将含有state的逻辑从组件中抽象出来，这将可以让这些逻辑容易被测试。同时，Hooks可以帮助你在不重写组件结构的情况下复用这些逻辑。所以，它也可以作为一种实现状态逻辑复用的方案。阅读下面的章节使用Hook的动机你可以发现，它可以同时解决Mixin和HOC带来的问题。 官方提供的HooksState Hook我们要使用class组件实现一个计数器功能，我们可能会这样写：javascript12345678910111213141516export default class Count extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125; &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; &#123; this.setState(&#123; count: this.state.count + 1 &#125;) &#125;&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 通过useState，我们使用函数式组件也能实现这样的功能：javascript1234567891011export default function HookTest() &#123; const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; &#123; setCount(count + 1); setNumber(number + 1); &#125;&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; useState是一个钩子，他可以为函数式组件增加一些状态，并且提供改变这些状态的函数，同时它接收一个参数，这个参数作为状态的默认值。 Effect HookEffect Hook 可以让你在函数组件中执行一些具有 side effect（副作用）的操作 参数useEffect方法接收传入两个参数： 回调函数：在第组件一次render和之后的每次update后运行，React保证在DOM已经更新完成之后才会运行回调。 状态依赖(数组)：当配置了状态依赖项后，只有检测到配置的状态变化时，才会调用回调函数。 javascript123456useEffect(() =&gt; &#123; // 只要组件render后就会执行&#125;);useEffect(() =&gt; &#123; // 只有count改变时才会执行&#125;,[count]); 回调返回值useEffect的第一个参数可以返回一个函数，当页面渲染了下一次更新的结果后，执行下一次useEffect之前，会调用这个函数。这个函数常常用来对上一次调用useEffect进行清理。javascript1234567891011121314151617export default function HookTest() &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; console.log('执行...', count); return () =&gt; &#123; console.log('清理...', count); &#125; &#125;, [count]); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; &#123; setCount(count + 1); setNumber(number + 1); &#125;&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; 执行上面的代码，并点击几次按钮，如果加上浏览器渲染的情况，结果应该是这样的： 页面渲染…1 执行… 1 页面渲染…2 清理… 1 执行… 2 页面渲染…3 清理… 2 执行… 3 页面渲染…4 清理… 3 执行… 4 那么为什么在浏览器渲染完后，再执行清理的方法还能找到上次的state呢？原因很简单，我们在useEffect中返回的是一个函数，这形成了一个闭包，这能保证我们上一次执行函数存储的变量不被销毁和污染。你可以尝试下面的代码可能更好理解javascript12345678910111213141516171819202122var flag = 1;var clean;function effect(flag) &#123; return function () &#123; console.log(flag); &#125;&#125;clean = effect(flag);flag = 2;clean();clean = effect(flag);flag = 3;clean();clean = effect(flag);// 执行结果effect... 1clean... 1effect... 2clean... 2effect... 3 模拟componentDidMountcomponentDidMount等价于useEffect的回调仅在页面初始化完成后执行一次，当useEffect的第二个参数传入一个空数组时可以实现这个效果。function useDidMount(callback) { useEffect(callback, []);}官方不推荐上面这种写法，因为这有可能导致一些错误。 模拟componentWillUnmountjavascript123function useUnMount(callback) &#123; useEffect(() =&gt; callback, []);&#125; 不像 componentDidMount 或者 componentDidUpdate，useEffect 中使用的 effect 并不会阻滞浏览器渲染页面。这让你的 app 看起来更加流畅。 ref Hook使用useRef Hook，你可以轻松的获取到dom的ref。javascript123456789101112export default function Input() &#123; const inputEl = useRef(null); const onButtonClick = () =&gt; &#123; inputEl.current.focus(); &#125;; return ( &lt;div&gt; &lt;input ref=&#123;inputEl&#125; type=\"text\" /&gt; &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;/button&gt; &lt;/div&gt; );&#125; 注意useRef()并不仅仅可以用来当作获取ref使用，使用useRef产生的ref的current属性是可变的，这意味着你可以用它来保存一个任意值。 模拟componentDidUpdatecomponentDidUpdate就相当于除去第一次调用的useEffect，我们可以借助useRef生成一个标识，来记录是否为第一次执行：javascript12345678910function useDidUpdate(callback, prop) &#123; const init = useRef(true); useEffect(() =&gt; &#123; if (init.current) &#123; init.current = false; &#125; else &#123; return callback(); &#125; &#125;, prop);&#125; 使用Hook的注意事项使用范围只能在React函数式组件或自定义Hook中使用Hook。Hook的提出主要就是为了解决class组件的一系列问题，所以我们能在class组件中使用它。 声明约束不要在循环，条件或嵌套函数中调用Hook。Hook通过数组实现的，每次useState 都会改变下标，React需要利用调用顺序来正确更新相应的状态，如果useState 被包裹循环或条件语句中，那每就可能会引起调用顺序的错乱，从而造成意想不到的错误。我们可以安装一个eslint插件来帮助我们避免这些问题。javascript12345678910111213// 安装npm install eslint-plugin-react-hooks --save-dev// 配置&#123; \"plugins\": [ // ... \"react-hooks\" ], \"rules\": &#123; // ... \"react-hooks/rules-of-hooks\": \"error\" &#125;&#125; 自定义Hook像上面介绍的HOC和mixin一样，我们同样可以通过自定义的Hook将组件中类似的状态逻辑抽取出来。自定义Hook非常简单，我们只需要定义一个函数，并且把相应需要的状态和effect封装进去，同时，Hook之间也是可以相互引用的。使用use开头命名自定义Hook，这样可以方便eslint进行检查。下面我们看几个具体的Hook封装： 日志打点我们可以使用上面封装的生命周期Hook。javascript12345678910111213141516const useLogger = (componentName, ...params) =&gt; &#123; useDidMount(() =&gt; &#123; console.log(`$&#123;componentName&#125;初始化`, ...params); &#125;); useUnMount(() =&gt; &#123; console.log(`$&#123;componentName&#125;卸载`, ...params); &#125;) useDidUpdate(() =&gt; &#123; console.log(`$&#123;componentName&#125;更新`, ...params); &#125;);&#125;;function Page1(props)&#123; useLogger('Page1',props); return (&lt;div&gt;...&lt;/div&gt;)&#125; 修改title根据不同的页面名称修改页面title:javascript12345678910111213function useTitle(title) &#123; useEffect( () =&gt; &#123; document.title = title; return () =&gt; (document.title = \"主页\"); &#125;, [title] );&#125;function Page1(props)&#123; useTitle('Page1'); return (&lt;div&gt;...&lt;/div&gt;)&#125; 双向绑定我们将表单onChange的逻辑抽取出来封装成一个Hook，这样所有需要进行双向绑定的表单组件都可以进行复用：javascript1234567891011121314function useBind(init) &#123; let [value, setValue] = useState(init); let onChange = useCallback(function(event) &#123; setValue(event.currentTarget.value); &#125;, []); return &#123; value, onChange &#125;;&#125;function Page1(props)&#123; let value = useBind(''); return &lt;input &#123;...value&#125; /&gt;;&#125; 当然，你可以向上面的HOC那样，结合context和form来封装一个更通用的双向绑定，有兴趣可以手动实现一下。 使用Hook的动机减少状态逻辑复用的风险Hook和Mixin在用法上有一定的相似之处，但是Mixin引入的逻辑和状态是可以相互覆盖的，而多个Hook之间互不影响，这让我们不需要在把一部分精力放在防止避免逻辑复用的冲突上。在不遵守约定的情况下使用HOC也有可能带来一定冲突，比如props覆盖等等，使用Hook则可以避免这些问题。 避免地狱式嵌套大量使用HOC的情况下让我们的代码变得嵌套层级非常深，使用Hook，我们可以实现扁平式的状态逻辑复用，而避免了大量的组件嵌套。 让组件更容易理解在使用class组件构建我们的程序时，他们各自拥有自己的状态，业务逻辑的复杂使这些组件变得越来越庞大，各个生命周期中会调用越来越多的逻辑，越来越难以维护。使用Hook，可以让你更大限度的将公用逻辑抽离，将一个组件分割成更小的函数，而不是强制基于生命周期方法进行分割。 使用函数代替class相比函数，编写一个class可能需要掌握更多的知识，需要注意的点也越多，比如this指向、绑定事件等等。另外，计算机理解一个函数比理解一个class更快。Hooks让你可以在classes之外使用更多React的新特性。","categories":[{"name":"React","slug":"React","permalink":"http://www.htmler.cn/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://www.htmler.cn/tags/React/"},{"name":"Hooks","slug":"Hooks","permalink":"http://www.htmler.cn/tags/Hooks/"},{"name":"HOC","slug":"HOC","permalink":"http://www.htmler.cn/tags/HOC/"},{"name":"Mixin","slug":"Mixin","permalink":"http://www.htmler.cn/tags/Mixin/"}],"keywords":[{"name":"React","slug":"React","permalink":"http://www.htmler.cn/categories/React/"}]},{"title":"破解各音乐App的vip限制","slug":"破解各音乐App需要vip限制","date":"2020-02-15T05:13:03.000Z","updated":"2020-04-28T05:03:32.992Z","comments":true,"path":"posts/f351d41f.html","link":"","permalink":"http://www.htmler.cn/posts/f351d41f.html","excerpt":"","text":"众所周知，目前各大音乐App都存在版权，因此经常遇到一种尴尬的情况，平时习惯用QQ音乐，但是部分歌曲QQ音乐没有或者是需要开会员，对于重度强迫症(还不是因为穷)的我是没法接受的，因此今天带来一种跨平台的免vip听所有歌曲的办法 原理网易云音乐提供了音乐云盘的功能，可以上传本地的音乐，同时可以在pc、移动端同步，那么解决办法就有了 操作步骤寻找喜欢的音乐在这里推荐一个名为 超高无损音乐 的网站，该网站收录了很多无损音质的歌曲，是以百度网盘链接的形式分享，在搜索框搜索自己喜欢的音乐，如图所示： 选择需要的格式，去网盘下载到本地备用 歌曲上传 首先下载网易云音乐pc客户端，安装，注册账号并登陆(为了能够多端同步音乐)，这里不赘述，操作很简单 找到左侧 “我的音乐云盘”，然后点击右侧的 “+ 上传音乐” 按钮选择本地下载好的音乐，上传 上传成功以后手机端就可以同步了，至此，喜欢什么歌下载下来上传就好，免vip，跨平台使用 安卓端进入客户端后屏幕右滑，可以看到云盘 ios端进入客户端后选择底部的 “我的”，找到左上角的云朵图标可以进入云盘","categories":[{"name":"破解","slug":"破解","permalink":"http://www.htmler.cn/categories/破解/"}],"tags":[{"name":"网易云音乐","slug":"网易云音乐","permalink":"http://www.htmler.cn/tags/网易云音乐/"},{"name":"vip破解","slug":"vip破解","permalink":"http://www.htmler.cn/tags/vip破解/"}],"keywords":[{"name":"破解","slug":"破解","permalink":"http://www.htmler.cn/categories/破解/"}]},{"title":"flutter打包--Android","slug":"flutter打包--Android","date":"2020-01-14T08:22:51.000Z","updated":"2020-04-28T05:03:32.984Z","comments":true,"path":"posts/7208bb97.html","link":"","permalink":"http://www.htmler.cn/posts/7208bb97.html","excerpt":"","text":"项目图片/android/app/src/main/res/ 目录下根据mipmap-为前缀文件夹存入相应dpi的png图片 配置APP名称、图标和系统权限在 /android/app/src/main/AndroidManifest.xml目录下 java12android:label=\"App名字\"android:icon=\"@mipmap/ic_launcher\" //此属性为APP图标用到的图片名称 APP注册将keytool所在路径添加到系统环境变量,默认是在 C:\\Program Files\\Android\\Android Studio\\jre\\bin 下面，然后将生成的key存储到e盘根目录 java1keytool -genkey -v -keystore e:/key.jks -keyalg RSA -keysize 2048 -validity 100000 -alias key 回车以后会让你输入对应的信息，其中密匙一定要记住，接下来到项目目录的android文件夹下创建一个名为key.properties的文件，并打开贴入以下代码： java1234storePassword=创建KEY时输入的密钥库密码keyPassword=创建KEY时输入的密钥密码 keyAlias=keystoreFile=e:/key.jks 配置key注册打开/android/app/build.gradle文件，在 android { 这一行前面，加入代码： java123defkeystorePropertiesFile=rootProject.file(\"key.properties\")defkeystoreProperties=newProperties()keystoreProperties.load(newFileInputStream(keystorePropertiesFile)) 把如下代码： java12345buildTypes &#123; release &#123; signingConfig signingConfigs.debug &#125;&#125; 替换成： java1234567891011121314signingConfigs &#123; release &#123; keyAlias keystoreProperties['keyAlias'] keyPassword keystoreProperties['keyPassword'] storeFile file(keystoreProperties['storeFile']) storePassword keystoreProperties['storePassword'] &#125;&#125;buildTypes &#123; release &#123; signingConfig signingConfigs.release &#125;&#125; 到defaultConfig中，录入APPID和版本号： java123456789101112131415defaultConfig &#123; // APPID applicationId \"com.example.myflutter\" // 可运行应用的最低版本的 Android 平台，由该平台的 API 级别标识符指定 minSdkVersion 16 // 指定运行应用的目标 API 级别。 // 在某些情况下，这允许应用使用在目标 API 级别中定义的清单元素或行为， // 而不是仅限于使用那些针对最低 API 级别定义的元素或行为。 targetSdkVersion 27 //内部版本号 versionCode 1 //对外公布的版本号 versionName \"1.0\" testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\" &#125; 编译生成apk文件在项目根目录终端中输入命令： bash1flutter build apk 安装到手机cmake1flutter install .","categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://www.htmler.cn/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://www.htmler.cn/tags/Flutter/"},{"name":"Android","slug":"Android","permalink":"http://www.htmler.cn/tags/Android/"}],"keywords":[{"name":"Flutter","slug":"Flutter","permalink":"http://www.htmler.cn/categories/Flutter/"}]},{"title":"flutter状态管理之flutter_redux","slug":"flutter状态管理之flutter_redux","date":"2019-12-31T04:13:03.000Z","updated":"2020-04-28T05:03:32.984Z","comments":true,"path":"posts/dcdd92a8.html","link":"","permalink":"http://www.htmler.cn/posts/dcdd92a8.html","excerpt":"","text":"一、创建全局statedart12345678910111213141516171819202122// state.dartimport 'package:nicolas/redux/user/login_redux.dart';import 'package:nicolas/redux/user/user_redux.dart';import 'package:nicolas/redux/middleware/epic_middleware.dart'; // 在项目中引入epic_middleware中间件import 'package:redux/redux.dart';class GlobalState &#123; // 全局Redux对象，保存State数据 bool login; // 登陆状态 GlobalState(&#123;this.login&#125;);&#125;// 定义appReducer创建 store，通过 appReducer 将 GlobalState 内的login 和 对应的action 关联在一起GlobalState appReducer(GlobalState state, action) &#123; return GlobalState( login: loginReducer(state.login, action), );&#125;final List&lt;Middleware&lt;GlobalState&gt;&gt; middleware = [ EpicMiddleware&lt;GlobalState&gt;(LoginEpic()), LoginMiddleware(),]; 二、创建login的state管理dart123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import 'package:flutter/material.dart';import 'package:nicolas/redux/state.dart';import 'package:nicolas/redux/middleware/epic.dart';import 'package:nicolas/redux/middleware/epic_store.dart';import 'package:redux/redux.dart';final loginReducer = combineReducers&lt;bool&gt;([ TypedReducer&lt;bool, LoginSuccessAction&gt;(_loginResult), TypedReducer&lt;bool, LogoutAction&gt;(_logoutResult),]);bool _loginResult(bool result, LoginSuccessAction action) &#123; if (action.success == true) &#123; // 登陆成功以后.... &#125; return action.success;&#125;// LoginSuccessAction触发，就会调用到 _loginResult，它接受一个新的state，并返回class LoginSuccessAction &#123; final BuildContext context; final bool success; LoginSuccessAction(this.context, this.success);&#125;class LoginAction &#123; final BuildContext context; final String user; final String password; LoginAction(this.context, this.user, this.password);&#125;class LoginMiddleware implements MiddlewareClass&lt;GlobalState&gt; &#123; @override void call(Store&lt;GlobalState&gt; store, dynamic action, NextDispatcher next) &#123; if (action is LogoutAction) &#123; print('logout'); &#125; // Make sure to forward actions to the next middleware in the chain! next(action); &#125;&#125;class LoginEpic implements EpicClass&lt;GlobalState&gt; &#123; @override Stream&lt;dynamic&gt; call(Stream&lt;dynamic&gt; actions, EpicStore&lt;GlobalState&gt; store) &#123; return Observable(actions) .whereType&lt;LoginAction&gt;() .switchMap((action) =&gt; _loginIn(action, store)); &#125; Stream&lt;dynamic&gt; _loginIn( LoginAction action, EpicStore&lt;GlobalState&gt; store) async* &#123; var res = await UserDio.login( // 登陆请求 action.user.trim(), action.password.trim(), store); yield LoginSuccessAction(action.context, (res != null &amp;&amp; res.result)); // 登陆请求结果处理 &#125;&#125; 三、注册全局statedart123456789101112131415161718192021222324252627282930313233343536373839import 'dart:async';import 'package:flutter/material.dart';import 'package:nicolas/redux/state.dart';import 'package:nicolas/app.dart';import 'package:nicolas/page/user/login.dart';import 'package:flutter_redux/flutter_redux.dart';import 'package:nicolas/common/utils/navigator.dart';import 'package:fluttertoast/fluttertoast.dart';import 'package:redux/redux.dart';import 'common/event/index.dart';import 'package:nicolas/common/event/http_error_event.dart';import 'package:nicolas/common/http/code.dart';void main() =&gt; runApp(FlutterReduxApp());class FlutterReduxApp extends StatefulWidget &#123; @override _FlutterReduxAppState createState() =&gt; _FlutterReduxAppState();&#125;class _FlutterReduxAppState extends State&lt;FlutterReduxApp&gt; with HttpErrorListener &#123; final store = new Store&lt;GlobalState&gt;(appReducer, middleware: middleware, initialState: new GlobalState( // 初始化state数据 login: false, )); @override Widget build(BuildContext context) &#123; return new StoreProvider( store: store, // 挂载store child: new StoreBuilder&lt;GlobalState&gt;(builder: (context, store) &#123; return Text('xxxx); &#125;), ); &#125;&#125; 四、使用statedart12345678Container( child: new StoreConnector&lt;GlobalState, bool&gt;( converter: (store) =&gt; store.state.login, builder: (context, login) &#123; return Text(login.toString()); &#125;, ));","categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://www.htmler.cn/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://www.htmler.cn/tags/Flutter/"},{"name":"跨平台","slug":"跨平台","permalink":"http://www.htmler.cn/tags/跨平台/"}],"keywords":[{"name":"Flutter","slug":"Flutter","permalink":"http://www.htmler.cn/categories/Flutter/"}]},{"title":"linux安装nginx","slug":"linux安装nginx","date":"2019-06-14T01:14:05.000Z","updated":"2020-04-28T05:03:32.987Z","comments":true,"path":"posts/a5141d63.html","link":"","permalink":"http://www.htmler.cn/posts/a5141d63.html","excerpt":"","text":"nginx安装常规安装vala123456789101112131415161718192021222324252627# 安装wgetyum install -y weget# 安装编译工具和相关的库文件 yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel# 下载PCRE（让nginx支持RUL地址的重定向功能）wget https://sourceforge.net/projects/pcre/files/pcre/8.41/pcre-8.41.tar.gz# 解压tar -xvzf pcre-8.41.tar.gz# 进入安装包目录cd pcre-8.41# 编译安装./configuremake &amp;&amp; make install# 下载安装 nginxwget http://nginx.org/download/nginx-1.14.0.tar.gz# 解压tar -xvzf nginx-1.14.0.tar.gz# 进入安装包目录：cd nginx-1.14.0# 编译安装：./configure --prefix=/usr/local/share/applications/nginx-1.14.0/ --with-http_ssl_modulemake &amp;&amp; make install# 查找nginx安装路径find / -name nginx# 制作nginx软链接,格式为：ln -s 目标路径 /usr/sbin/nginx# 找到带sbin的nginx路径，如：/usr/local/share/applications/nginx-1.14.0/sbin/nginxln -s /usr/local/share/applications/nginx-1.14.0/sbin/nginx /usr/sbin/nginx yum安装添加yum源root权限下添加nginx的yum源，此处以RHEL/CentOS为例，其他版本的linux参考这里properties1234# 安装yum-utilsyum install yum-utils# 添加nginx.repovi /etc/yum.repos.d/nginx.repo 内容如下：ini123456789101112131415[nginx-stable]name=nginx stable repobaseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=1enabled=1gpgkey=https://nginx.org/keys/nginx_signing.keymodule_hotfixes=true[nginx-mainline]name=nginx mainline repobaseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/gpgcheck=1enabled=0gpgkey=https://nginx.org/keys/nginx_signing.keymodule_hotfixes=true 安装nginxbash1yum -y install nginx 启动nginxangelscript123456789nginx# 如果没任何提示，则代表nginx启动成功了，查看nginx端口占用lsof -i:80# nginx 1410 root 6u IPv4 22898 0t0 TCP *:http (LISTEN)# nginx 2206 nginx 6u IPv4 22898 0t0 TCP *:http (LISTEN)# 开放80端口firewall-cmd --permanent --zone=public --add-port=80/tcp# 重载防火墙firewall-cmd --reload 修改nginx配置vim1234# 查找配置文件路径find / -name nginx.conf# 得到路径如：/etc/nginx/nginx.conf，接下来编辑vi /etc/nginx/nginx.conf 找到server部分nginx123456789101112131415server &#123; listen 80; #监听的端口 server_name baidu.com; # 需要绑定的域名 location / &#123; root /www/test; # 项目路径 index index.html index.htm; # 默认首页 &#125; # 反向代理 location /api/ &#123; # 将所有带api的请求代理到127.0.0.1:3000 proxy_set_header Host $host:$proxy_port; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:3000; # host:port的格式 &#125;&#125; 配置完毕以后esc然后:wq回车，reload一下confbash1nginx -s reload nginx常规操作vala1234567891011121314151617181920# 启动nginxnginx# 重新载入配置文件nginx -s reload # 重启 nginxnginx -s reopen # 停止 nginxnginx -s stop# 添加开机启动systemctl enable nginx.service# 查看nginx错误日志(最近100条)tail -100f /var/log/nginx/error.log# 查看nginx请求日志(最近100条)tail -100f /var/log/nginx/access.log","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.htmler.cn/categories/Linux/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://www.htmler.cn/tags/nginx/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://www.htmler.cn/categories/Linux/"}]},{"title":"ios背景音乐autoplay","slug":"ios背景音乐autoplay","date":"2019-06-01T04:26:29.000Z","updated":"2020-04-28T05:03:32.985Z","comments":true,"path":"posts/21214a4.html","link":"","permalink":"http://www.htmler.cn/posts/21214a4.html","excerpt":"","text":"前端页面audio无法自动播放这个在 IOS/Android 上面目前已经是个惯例，如果调用audio.play必须在事件里面响应，换句话说，用户还没有交互，不让调play。网上也有一种解决方案是引导用户触发事件，能解决autoplay的问题，但是局限性很大，如果要播放多个音乐也就凉凉，同时也有AudioContext解决方案，经过尝试还是没达到预期，个人在公司项目中有个需求是进页面播放背景音乐，同时，基于不同阶段，会播放各种音效，因为ios策略限制，找到如下解决方案，ps：项目是基于vue的 soundjs的引入soundjs是专门处理音频的一个js库，这里不做过多介绍，传送门 因为项目是基于vue的，但遗憾的是soundjs没有npm包，所以可以通过官网提供的cdn在项目入口index.html通过script引入javascript1&lt;script type=\"text/javascript\" src=\"https://code.createjs.com/1.0.0/createjs.min.js\"&gt;&lt;/script&gt; 打开soundjs源码javascript12this.createjs=this.createjs||&#123;&#125;...... 可以看到里面创建了一个叫createjs的对象，绑定在this上面，当然了，根据上下文来讲此时的this指代的是window而不是vue实例,因为我们是在入口index.html引入的，算是全局引用，因此我们要使用createjs只需要window.createjs即可。 绑定音乐列表首先我这里有一个音乐列表javascript123456789101112131415list: [ &#123; name: 'a', // 音频名字 src: '../../static/a.mp3' // 音频路径 &#125;, &#123; name: 'b', src: '../../static/b.mp3' &#125;, &#123; name: 'c', src: '../../static/c.mp3' &#125; ] 接下来需要将音乐列表绑定到createjs对象上 javascript12345for (let i = 0; i &lt; this.list.length; i++) &#123; window.createjs.source || (window.createjs.source = &#123;&#125;) // 添加source属性存储音乐信息 window.createjs.Sound.registerSound(this.list[i].src, this.list[i].name) // 绑定音乐信息到createjs实例 window.createjs.source[this.list[i].name] = window.createjs.Sound.createInstance(this.list[i].name) // 创建播实例，添加映射&#125; 音乐操作接下来创建三个操作音乐的方法 播放音乐javascript123456789playSound (e, t, f) &#123; let i = window.createjs.source[e] i.playState &amp;&amp; i.stop() i.play(t) f &amp;&amp; f())&#125;// e: 需要播放的音乐名字，这里和音乐list里面的nane字段对应// t: 播放模式，传入一个对象&#123;loop: -1&#125; ,-1代表无限循环，1代表仅播放一次// f: callback 暂停音乐javascript123pausedSound (e, f) &#123; window.createjs.source[e].paused = !window.createjs.source[e].paused, f &amp;&amp; f()&#125;, 停止播放javascript123stopSound (e, f) &#123; return e ? window.createjs.source[e].stop() : window.createjs.Sound.stop(), f &amp;&amp; f()&#125; 静音javascript123mutedSound () &#123; window.createjs.Sound.muted = !window.createjs.Sound.muted&#125;","categories":[{"name":"vue","slug":"vue","permalink":"http://www.htmler.cn/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://www.htmler.cn/tags/vue/"},{"name":"audio","slug":"audio","permalink":"http://www.htmler.cn/tags/audio/"}],"keywords":[{"name":"vue","slug":"vue","permalink":"http://www.htmler.cn/categories/vue/"}]},{"title":"vue-cli配置多入口","slug":"vue-cli配置多入口","date":"2019-04-23T03:21:55.000Z","updated":"2020-04-28T05:03:32.987Z","comments":true,"path":"posts/7ac3b51.html","link":"","permalink":"http://www.htmler.cn/posts/7ac3b51.html","excerpt":"","text":"因实际需要，在公司移动端项目上线后机组做pc版，此时，如果重新构建一个pc项目的话一来维护不便，二来很多公共资源可以重复利用，因此在原来移动端的基础上构建多入口，实现一个项目两个版本，甚至多个 一、目录结构分析 配置多入口其实就是将pc版和手机版共用一个cli，在src目录下创建一个entries目录，里面分别创建pc、mobile目录存放分别的入口文件，接下来，将index.html、main.js、App.vue移动到pc目录并改名，手机端复制pc改名 原目录结构css1234567891011121314151617181920212223242526272829├── README.md 项目介绍├── index.html 入口页面├── build 构建脚本目录│ ├── build-server.js 运行本地构建服务器，可以访问构建后的页面│ ├── build.js 生产环境构建脚本│ ├── dev-client.js 开发服务器热重载脚本，主要用来实现开发阶段的页面自动刷新│ ├── dev-server.js 运行本地开发服务器│ ├── utils.js 构建相关工具方法│ ├── webpack.base.conf.js wabpack基础配置│ ├── webpack.dev.conf.js wabpack开发环境配置│ └── webpack.prod.conf.js wabpack生产环境配置├── config 项目配置│ ├── dev.env.js 开发环境变量│ ├── index.js 项目配置文件│ ├── prod.env.js 生产环境变量│ └── test.env.js 测试环境变量├── package.json npm包配置文件，里面定义了项目的npm脚本，依赖包等信息├── src 源码目录 │ ├── main.js 入口js文件│ ├── app.vue 根组件│ ├── components 公共组件目录│ ├── assets 资源目录，这里的资源会被wabpack构建│ │ └── images│ │ └── logo.png│ ├── routes 前端路由│ │ └── index.js├── static 纯静态资源，不会被wabpack构建。└── test 测试文件目录（unit&amp;e2e） └── unit 单元测试 配置多入口目录css12345678910111213├── src│ ├── entries 新的入口目录│ │ │── pc pc版入口文目录│ │ │ ├──pc.js pc版入口js(以前的main.js)│ │ │ ├──pc.vue pc版入口vue(以前的App.vue)│ │ │ └──pc.html pc版入口html(以前的index.html) │ │ └── mobile 手机版入口文目录│ │ ├──mobile.js 手机版入口js(以前的main.js)│ │ ├──mobile.vue 手机版入口vue(以前的App.vue)│ │ └──mobile.html 手机版入口vue(以前的App.vue)│ └─── router │ ├──mobile.js 手机版路由│ └──pc.js pc版路由 二、入口文件修改以pc.vue为例，mobile同理pgsql123456789import Vue from 'vue'import Pc from './pc.vue'import router from '../.././router/pc.js'new Vue(&#123; el: '#app', router, components: &#123; Pc &#125;, template: '&lt;Pc/&gt;'&#125;) 三、修改utils配置文件打开/build/utils.js加入如下内容javascript1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var glob = require('glob')// 页面模板var HtmlWebpackPlugin = require('html-webpack-plugin')// 取得相应的页面路径，因为之前的配置，所以是src文件夹下的entries文件夹var PAGE_PATH = path.resolve(__dirname, '../src/entries') // 用于做相应的merge处理var merge = require('webpack-merge')//多入口配置// 通过glob模块读取page文件夹下的所有对应文件夹下的js后缀文件，如果该文件存在// 那么就作为入口处理exports.entries = function() &#123; var entryFiles = glob.sync(PAGE_PATH + '/*/*.js') // 寻找入口js（原main.js） var map = &#123;&#125; entryFiles.forEach((filePath) =&gt; &#123; var filename = filePath.substring(filePath.lastIndexOf('\\/') + 1, filePath.lastIndexOf('.')) map[filename] = filePath &#125;) return map&#125;//多页面输出配置// 与上面的多页面入口配置相同，读取page文件夹下的对应的html后缀文件，然后放入数组中exports.htmlPlugin = function() &#123; let entryHtml = glob.sync(PAGE_PATH + '/*/*.html') let arr = [] entryHtml.forEach((filePath) =&gt; &#123; let filename = filePath.substring(filePath.lastIndexOf('\\/') + 1, filePath.lastIndexOf('.')) let conf = &#123; // 模板来源 template: filePath, // 文件名称 filename: filename + '.html', // 页面模板需要加对应的js脚本，如果不加这行则每个页面都会引入所有的js脚本 chunks: ['manifest', 'vendor', filename], inject: true &#125; if (process.env.NODE_ENV === 'production') &#123; conf = merge(conf, &#123; minify: &#123; removeComments: true, collapseWhitespace: true, removeAttributeQuotes: true &#125;, chunksSortMode: 'dependency' &#125;) &#125; arr.push(new HtmlWebpackPlugin(conf)) &#125;) return arr&#125; 四、修改webpack.dev.conf打开/build/webpack.dev.conf.js做如下修改： 找到 plugins:数组，将如下内容注释或删除 css12345new HtmlWebpackPlugin(&#123; filename: 'index.html', template: 'index.html', inject: true&#125;), 在plugins数组上拼接上在utils.js内获取到的入口内容修改完成以后的plugins如下： haxe123456789101112131415161718192021222324plugins: [ new webpack.DefinePlugin(&#123; 'process.env': require('../config/dev.env') &#125;), new webpack.HotModuleReplacementPlugin(), new webpack.NamedModulesPlugin(), // HMR shows correct file names in console on update. new webpack.NoEmitOnErrorsPlugin(), // https://github.com/ampedandwired/html-webpack-plugin // 注释开始 // new HtmlWebpackPlugin(&#123; // filename: 'index.html', // template: 'index.html', // inject: true // &#125;), // 注释结束 // copy custom static assets new CopyWebpackPlugin([ &#123; from: path.resolve(__dirname, '../static'), to: config.dev.assetsSubDirectory, ignore: ['.*'] &#125; ]) ].concat(utils.htmlPlugin()) // 这里是添加的部分 修改webpack.prod.conf打开/build/webpack.prod.conf做如下修改： 找到 plugins:数组，将如下内容注释或删除 yaml12345678910111213141516new HtmlWebpackPlugin(&#123; filename: process.env.NODE_ENV === 'testing' ? 'index.html' : config.build.index, template: 'index.html', inject: true, minify: &#123; removeComments: true, collapseWhitespace: true, removeAttributeQuotes: false // more options: // https://github.com/kangax/html-minifier#options-quick-reference &#125;, // necessary to consistently work with multiple chunks via CommonsChunkPlugin chunksSortMode: 'dependency'&#125;), 在plugins数组上拼接上在utils.js内获取到的入口内容 (操作同上一步) 五、添加客户端判断客户端访问项目时，通过js判断展示哪个版本在pc版本入口pc.html文件内添加如下jssmalltalk123if (/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) &#123; window.location.href = '/mobile.html#/'&#125; 同理，在mobile.html添加如下jssmalltalk123if (!/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) &#123; window.location.href = '/pc.html#/'&#125; 六、后续说明以上步骤操作完成以后便成功的添加了多入口，但是有几点需要注意： 本地运行调试的时候，以前我们是localhost:8080就可以访问了，但是现在我们需要 localhost:8080/pc.html或者localhost:8080/mobile.html 项目通过webpack打包以后会在根目录生成mobile.html和pc.html,在项目部署的时候需要配置默首页，也就是指定是mobile.html或者pc.html","categories":[{"name":"vue","slug":"vue","permalink":"http://www.htmler.cn/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://www.htmler.cn/tags/vue/"}],"keywords":[{"name":"vue","slug":"vue","permalink":"http://www.htmler.cn/categories/vue/"}]},{"title":"Hexo+Github搭建个人博客","slug":"Hexo+Github搭建个人博客","date":"2018-12-07T04:13:03.000Z","updated":"2020-04-28T05:03:32.981Z","comments":true,"path":"posts/405e7e90.html","link":"","permalink":"http://www.htmler.cn/posts/405e7e90.html","excerpt":"","text":"欢迎来到我的博客驿站，本站是使用Hexo+Github基于基于Node.js的静态博客框架, 官方文档请参考Hexo 安装Node及环境配置Node官网你可以根据不同平台系统选择你需要的Node.js安装包，安装过程很简单，下一步下一步就ok注意：Linux上安装Node.js需要安装Python，建议安装Python 3.6以上版本。 安装Hexo脚手架在安装了node之后，我们就可以使用node的包管理器npm安装hexo了，操作如下bash1npm install hexo-cli -g git相关配置本地搭建好博客项目之后需要提交到github上去.首先去GitHub申请个人账号，以便后期用来做博客的远程创库、域名、服务器之类的，github账号不再啰嗦了,跟一般的注册账号差不多 安装git打开git官网下载git，安装过程全程默认配置，下一步下一步安装 本地创建ssh key桌面右键git bash here，然后：excel1ssh-keygen -t rsa -C \"邮箱地址\" 之后会要求确认路径和输入密码，记住这个路径，我们这使用默认的一路回车就行。成功的话会在.ssh文件夹生成id_rsa.pub文件，用记事本打开，复制里面的内容，也就是我们需要的key github添加ssh key回到github页面上，点击头像右侧倒三角，选择Settings（账户配置），左边选择SSH Keys，点击右上角Add SSH Key,title随便填，下方文本框粘贴上一步上生成的key确定 ssh key本地验证回到刚才生成key的命令行，执行如下命令验证github用户名和邮箱bash12git config --global user.name \"你的用户名\"git config --global user.email \"你的邮箱\" 注意：执行这两条命令成功后没有任何提示 项目搭建接下来初始化Hexo项目，首先在需要保存项目的目录鼠标右键选择”git bash here”,然后： bash1hexo init blog blog为你博客的项目名称，接下来切换到博客路径bash1cd blog 安装项目依赖包cmake1npm install 至此，博客初始化完成，可以启动hexo服务了ebnf1hexo s 命令行提示：java12INFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 接下来可以在浏览器地址栏输入 http://localhost:4000 访问博客 主题更换 在主题网站查找自己喜欢的主题，找到以后点击进去预览，在博客预览页面找到博主的github链接 进入博主github首页，找到主题对应的仓库，点击右侧绿色”clone or download”按钮获取主题仓库地址 下载首先在命令行使用cd命令切换到themes目录，然后crmsh1git clone 主题地址 等待下载完毕以后会在themes文件夹内生成一个主题文件夹，接下来修改根目录_config.yml的theme选项为你刚才下载的主题名，接下来清除一下缓存ebnf1hexo clean 然后编译ebnf1hexo g 然后重启服务(在之前启动服务的命令行使用ctrl+c停止服务)，然后ebnf1hexo s 接下来在浏览器预览就可以看到新主题的效果了 托管到gitHub创建博客托管仓库创建一个与自己用户名同名的repository，在自己Github页面，点击头像左侧+按钮，选择new repository，比如我的Github账号是Givingcode，那么我应该创建的repository名字应该是Givingcode.github.io 添加deploy配置首先在根目录_config.yml文件内配置gitbash1234deploy: type: git repository: git@github.com:用户名/用户名.github.io.git branch: master repository：就是你的gitHub同名仓库的地址 代码托管安装 hexo-deployer-git依赖包sql1npm install hexo-deployer-git --save 然后使用如下命令 bash1hexo d 此时，你就可以在浏览器地址栏输入 “用户名.github.io”来访问你的个人博客(用户名：你gitHub的用户名) 域名绑定域名解析域名申请的途径非常多，建议使用阿里云的，方便后期备案，在阿里云购买了域名之后，到域名管理中心进行域名解析，添加以下几条记录值： 记录类型 主机记录 解析线路(isp) 记录值 CNAME www 默认 用户名.github.io A @ 默认 192.30.252.153 A @ 默认 192.30.252.154 创建域名关联文件在项目根目录source目录新建名为CNAME的文件，（注意：该文件没有后缀名）然后在CNAME文件里面填写你的域名，如：xxx.com 注意：不带www也不带http，只需要域名就好 接下来重新编译推送一下bash12hexo g # 编译hexo d # 推送 提示：INFO Deploy done: git 之后就可以使用域名访问你的个人博客了","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.htmler.cn/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.htmler.cn/tags/Hexo/"}],"keywords":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.htmler.cn/categories/Hexo/"}]},{"title":"Adobe PhotoShop CC激活破解","slug":"Adobe PhotoShop CC激活破解","date":"2018-10-29T05:13:03.000Z","updated":"2020-04-28T05:03:32.981Z","comments":true,"path":"posts/5b3ca933.html","link":"","permalink":"http://www.htmler.cn/posts/5b3ca933.html","excerpt":"","text":"工具下载在我的百度网盘提取码：ajif下载压缩包,解压,展开Adobe Photoshop CC 2017-18.0(64 bit)，得到如下文件： 安装ps 首先断开计算机网络(禁用电脑网络或者拔网线或者断wifi) 双击Set-up.exe,得到如下界面，等待进度条跑完，预计3分钟左右 安装结束后会在开始菜单生成如下2个快捷方式 点击蓝色ps按钮运行，选择以后登录 选择开始使用 接受 接下来会打开ps界面，等待10s左右等它加载完所有组件，关闭ps软件 破解激活 双击打开激活工具 在下拉列表选择Adobe Photoshop cc2015.5 点击install选择amtlib.dll文件默认在C:\\Program Files\\Adobe\\Adobe Photoshop CC 2017文件夹下 点击Advaced按钮，然后关闭5、激活破解完成，重新连接电脑网络，就可以正常使用ps了","categories":[{"name":"破解","slug":"破解","permalink":"http://www.htmler.cn/categories/破解/"}],"tags":[{"name":"PhotoShop","slug":"PhotoShop","permalink":"http://www.htmler.cn/tags/PhotoShop/"},{"name":"激活破解","slug":"激活破解","permalink":"http://www.htmler.cn/tags/激活破解/"}],"keywords":[{"name":"破解","slug":"破解","permalink":"http://www.htmler.cn/categories/破解/"}]},{"title":"vue实现拖拽","slug":"vue实现拖拽","date":"2018-10-21T09:21:43.000Z","updated":"2020-04-28T05:03:32.988Z","comments":true,"path":"posts/4461359d.html","link":"","permalink":"http://www.htmler.cn/posts/4461359d.html","excerpt":"","text":"html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;template&gt; &lt;div class=\"sidebar\"&gt; &lt;div class=\"slideContent\" :style=\"&#123;left: left + 'px', top: top + 'px'&#125;\"&gt; &lt;div class=\"move\" @mousedown=\"move($event)\"&gt; &lt;i class=\"el-icon-rank\"/&gt; &lt;/div&gt; &lt;div class=\"content\"&gt;....&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: \"index\", data() &#123; return &#123; left: window.innerWidth - 445, top: window.innerHeight - 640, &#125; &#125;, methods: &#123; move(e) &#123; const t = window.innerWidth - 375, a = window.innerHeight - 605 const i = document.getElementsByClassName(\"slideContent\")[0] const n = e.clientX - i.offsetLeft const s = e.clientY - i.offsetTop; return document.onmousemove = e =&gt; &#123; let r = e.clientX - n let o = e.clientY - s return r &lt;= 0 ? r = 0 : r &gt;= t &amp;&amp; (r = t), o &lt;= 20 ? o = 20 : o &gt;= a &amp;&amp; (o = a), i.style.left = r + \"px\", i.style.top = o + \"px\", !1 &#125;, document.onmouseup = () =&gt; &#123; document.onmousemove = null, document.onmouseup = null &#125;, document.onmouseleave = () =&gt; &#123; document.onmousemove = null, document.onmouseup = null &#125;, !1 &#125;, &#125; &#125;&lt;/script&gt;&lt;style lang=\"scss\" scoped&gt; .sidebar &#123; .slideContent &#123; position: fixed; background: rgb(239, 238, 244); width: 375px; height: 600px; right: 70px; top: 0px; z-index: 90; color: #fff; box-shadow: 0 5px 10px rgba(6, 6, 6, .3); .move &#123; cursor: move; user-select: none; position: relative; border-radius: 3px 3px 0 0; height: 20px; color: #333; background: linear-gradient(0deg, #bbb, #eee); width: 100%; line-height: 10px; display: block; padding: 5px 10px; i &#123; float: right; &#125; &#125; &#125; &#125;&lt;/style&gt;","categories":[{"name":"vue","slug":"vue","permalink":"http://www.htmler.cn/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://www.htmler.cn/tags/vue/"}],"keywords":[{"name":"vue","slug":"vue","permalink":"http://www.htmler.cn/categories/vue/"}]},{"title":"AWS创建EC2","slug":"AWS搭建EC2","date":"2018-10-11T08:13:03.000Z","updated":"2020-04-28T05:03:32.980Z","comments":true,"path":"posts/f886afb6.html","link":"","permalink":"http://www.htmler.cn/posts/f886afb6.html","excerpt":"","text":"切换pem为账号登陆 下载xxx.pem文件到本地 命令行cd到xxx.pem所在路径，使用pem登陆bash123456789101112131415161718192021ssh -i \"xxx.pem\" ec2-user@ec2-18-224-140-75.us-east-2.compute.amazonaws.com# 创建root密码sudo passwd root # 输入两次密码，期间没有任何提示# 切换到root身份su root# 编辑亚马逊主机的ssh登录方式 vi /etc/ssh/sshd_config # 把 PasswordAuthentication no 改为 PasswordAuthentication yes # ps: 如果没有则新插进去 # 重启sshd使修改生效service sshd restart# 修改root用户名(修改root登录用户名减少主机被暴力破解的风险)vi /etc/passwd# 修改第1行第1个root为新的用户名，esc然后:wq保存退出vi /etc/shadow# 修改第1行第1个root为新的用户名，esc然后:wq! 强制保存退出# 重启服务器reboot# 使用git bash或者xshell之类的ssh客户端通过用户名密码远程连接ssh 用户名@ip地址 搭建ftp服务器ps：这是单独搭建ftp服务器用于上传下载文件，但是一般不建议这么操作，容易被攻击，如果常用ssh客户端为xShell，那么可以使用xFtprouteros12345678910111213141516171819202122232425262728# 使用 yum 安装 vsftpdyum install -y vsftpd# 启动 VSFTPDservice vsftpd start# 查看端口netstat -nltp | grep 21# 配置 FTP 权限# 编辑 /etc/vsftpd/vsftpd.conf，找到下面两处配置并修改：# 禁用匿名用户 12 YES 改为NOanonymous_enable=NO# 禁止切换根目录 101 行 删除#chroot_local_user=YES# 重新启动 FTP 服务service vsftpd restart# 创建 FTP 用户（useradd 用户名）useradd web# 为用户 ftpuser 设置密码echo \"123456\" | passwd web --stdin# 限制用户 ftpuser只能通过 FTP 访问服务器，而不能直接登录服务器：usermod -s /sbin/nologin web# 为用户 ftpuser创建主目录并约定：# /data/ftp 为主目录, 该目录不可上传文件 # /data/ftp/pub 文件只能上传到该目录下mkdir -p /data/ftp/pub# 设置访问权限chmod a-w /data/ftp &amp;&amp; chmod 777 -R /data/ftp/pub# 设置为用户的主目录：usermod -d /data/ftp web 注意：记得关闭防火墙或者开放FTP默认端口(21) 关闭SELinux服务 angelscript1setenforce 0 关闭防火墙 ebnf1iptables -F 安装nodebash123456789101112131415161718192021# 下载node压缩包wget https://npm.taobao.org/mirrors/node/v10.6.0/node-v10.6.0-linux-x64.tar.xz# 解压tar -xvf node-v10.6.0-linux-x64.tar.xz# 更改node安装目录mv node-v10.6.0-linux-x64 /root/node# 配置全局环境变量 ln -s /root/node/bin/node /usr/sbin/nodeln -s /root/node/bin/npm /usr/sbin/npm# 安装守护程序forevernpm install forever -g# 查找forever的安装路径find / -name forerver# 我这里查到是在：/node/bin/，添加forever到PATHvi /etc/profile# 在结尾的地方添加记录export PATH=$PATH:/node/bin# 重建缓存source /etc/profile# forever启用node服务forever start xxx.js 安装ngnixbash123456789101112131415161718192021222324# 安装wgetyum install -y weget# 安装编译工具和相关的库文件 yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel# 下载PCRE（让Nginx支持RUL地址的重定向功能）wget https://sourceforge.net/projects/pcre/files/pcre/8.41/pcre-8.41.tar.gz# 解压tar -xvzf pcre-8.41.tar.gz# 进入安装包目录cd pcre-8.41# 编译安装./configuremake &amp;&amp; make install# 下载安装 Nginxwget http://nginx.org/download/nginx-1.14.0.tar.gz# 解压tar -xvzf nginx-1.14.0.tar.gz# 进入安装包目录：cd nginx-1.14.0# 编译安装：./configure --prefix=/usr/local/share/applications/nginx-1.14.0/ --with-http_ssl_modulemake &amp;&amp; make install# 启动Ngnix/usr/local/share/applications/nginx-1.14.0/sbin/nginx 接下来配置项目路径和域名 Code12345678910111213141516171819202122server &#123; listen 80; server_name aaa.com; location / &#123; root 项目路径1; index index.html index.htm; # 端口代理 proxy_pass http://127.0.0.1:3000; &#125;&#125;server &#123; listen 80; server_name bbb.com; location / &#123; root 项目路径2; index index.html index.htm; # 端口代理 proxy_pass http://127.0.0.1:4000; &#125;&#125; 配置完毕以后reload一下confbash1/usr/local/share/applications/nginx-1.14.0/sbin/nginx -s reload Ngnix常规操作dts1234567891011# 启动nginx/usr/local/share/applications/nginx-1.14.0/sbin/nginx # 重新载入配置文件/usr/local/share/applications/nginx-1.14.0/sbin/nginx -s reload # 重启 Nginx/usr/local/share/applications/nginx-1.14.0/sbin/nginx -s reopen # 停止 Nginx/usr/local/share/applications/nginx-1.14.0/sbin/nginx -s stop Ngnix常规选项 配置文件路径/usr/local/share/applications/nginx-1.14.0/conf默认项目目录/nginx-1.14.0/html 安装mysqlbash12345678910111213141516171819202122232425262728293031# 查看是否有自带的MySql库，如果先有卸载rpm -qa | grep mysql# 删除mysql-lib(系统自带的版本过低)yum remove mysql-libs# 下载mysqlwget https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.12-1.el6.x86_64.rpm-bundle.tar # 解压tar -xvf mysql-5.7.12-1.el6.x86_64.rpm-bundle.tar # 依次安装mysql包（common、libs、client、server）rpm -ivh mysql-community-common-5.7.12-1.el6.x86_64.rpmrpm -ivh mysql-community-libs-5.7.12-1.el6.x86_64.rpmrpm -ivh mysql-community-client-5.7.12-1.el6.x86_64.rpm rpm -ivh mysql-community-server-5.7.12-1.el6.x86_64.rpm # 启动mysql服务service mysqld start# 查看默认密码grep 'password' /var/log/mysqld.log# [Note] A temporary password is generated for root@localhost: x2sX3Gb6+Dtm# root@localhost: 这里后面就是默认密码# 登陆mysql -uroot -p# 修改默认密码SET PASSWORD = PASSWORD('Abcd1234.');# ps：这里需要大小写数组字符相结合，不然会通不过# 刷新系统权限flush privileges;# 开启远程登录权限GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'Abcd1234.' WITH GRANT OPTION;# 刷新系统权限flush privileges;# 接下来就可以远程登陆了 安装阿帕奇bash1234# 安装阿帕奇yum install httpd -y# 开启服务systemctl start httpd 添加阿帕奇工作空间修改/etc/httpd/conf/httpd.conf配置文件指定阿帕奇workspace为/var/www/html修改前apache1234&lt;Directory&gt; AllowOverride none Require all denied&lt;/Directory&gt; 修改后lasso1234&lt;Directory \"/var/www/html\"&gt; AllowOverride none Require all denied&lt;/Directory&gt; 启动服务 crmsh1systemctl start httpd 域名绑定在/etc/httpd/conf目录下创建default.conf添加如下内容 apache1234&lt;VirtualHost *:80&gt; DocumentRoot \"/var/www/html\" ServerName www.lidg.vip&lt;VirtualHost&gt; DocumentRoot:工作空间ServerName：域名 搭建vpn 安装wget bash1yum -y install wget 安装setuptools vim123456789wget --no-check-certificate https://pypi.python.org/packages/source/s/setuptools/setuptools-19.6.tar.gz#md5=c607dd118eae682c44ed146367a17e26 tar -zxvf setuptools-19.6.tar.gz cd setuptools-19.6 python setup.py build python setup.py install 下载pip安装包，解压到某个位置，我这里下载的是18.1版本，然后就可以安装了 bash123456789wget --no-check-certificate https://pypi.python.org/packages/source/p/pip/pip-8.0.2.tar.gz#md5=3a73c4188f8dbad6a1e6f6d44d117eeb tar -zxvf pip-8.0.2.tar.gz cd pip-8.0.2 python setup.py build python setup.py install 安装shadowsocks cmake1pip install shadowsocks 添加shadowsocks配置文件 jboss-cli123mkdir /etc/shadowsocks/cd /etc/shadowsocks/vi config.json 粘贴如下内容：json123456789&#123; \"server\":\"0.0.0.0\", \"server_port\":8388, \"local_port\":1080, \"password\":\"把这段汉字替换为你的vpn连接密码\", \"timeout\":600, \"method\":\"aes-256-cfb\", \"fast_open\":false&#125; 启动服务pgsql1ssserver -c /etc/shadowsocks/config.json -d start","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.htmler.cn/categories/Linux/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://www.htmler.cn/tags/Nginx/"},{"name":"Linux","slug":"Linux","permalink":"http://www.htmler.cn/tags/Linux/"},{"name":"EC2","slug":"EC2","permalink":"http://www.htmler.cn/tags/EC2/"},{"name":"vpn","slug":"vpn","permalink":"http://www.htmler.cn/tags/vpn/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://www.htmler.cn/categories/Linux/"}]},{"title":"RedHat常规操作","slug":"RedHat常规操作","date":"2018-09-29T08:13:03.000Z","updated":"2020-04-28T05:03:32.982Z","comments":true,"path":"posts/48e6a2a8.html","link":"","permalink":"http://www.htmler.cn/posts/48e6a2a8.html","excerpt":"","text":"RedHat设置网络开机自动连接 切换到root账户 安装网络工具 cmake1yum install -y net-tools\\* 使用vim修改 /etc/sysconfig/network-scripts/ifcfg-enpxxxxxx文件ifcfg-enpxxxxxx文件为你的网卡名配置文件将文件最后一行的ONBOOT= no改为yes，保存即可。个别情况下，为了后期远程连接方便，我们可以做如下更改修改上边文件 ：BOOTPROTO=static同时文件的最后添加以下内容：IPADDR=176.202.123.234 #静态IPGATEWAY=176.202.123.1 #默认网关NETMASK=255.255.255.0 #子网掩码DNS1=176.202.0.227 #DNS 配置 ps：以上参数根据自己网段设置即可 设置完毕以后，重启网卡routeros1service network restart","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.htmler.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.htmler.cn/tags/Linux/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://www.htmler.cn/categories/Linux/"}]},{"title":"vue移动端屏幕适配解决方案new","slug":"vue移动端屏幕适配解决方案new","date":"2018-09-08T06:57:41.000Z","updated":"2020-04-28T05:03:32.990Z","comments":true,"path":"posts/a6052580.html","link":"","permalink":"http://www.htmler.cn/posts/a6052580.html","excerpt":"","text":"项目原地址参考这里 插件安装bash12345# 安装适配插件lib-flexiblenpm i lib-flexible -S# 安装px转rem插件npm i px2rem-loader -S 文件引入在vue的入口文件main.js内引入lib-flexiblebash1import 'lib-flexible/flexible.js' 添加meta标签在入口index.html内添加视口修饰metahtml1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; 配置utils在build/utils.js文件内：在cssLoaders里面添加px2remLoader方法用于将px转换为remjavascript123456const px2remLoader = &#123; loader: 'px2rem-loader', options: &#123; 'remUnit':75,'baseDpr':2 // 设计稿width为750，因此这里是75 &#125; &#125; 接下来将px2remLoader方法添加到generateLoaders的loaders数组内javascript1const loaders = [cssLoader, px2remLoader] 使用方法以上几个步骤配置完毕以后，重启服务，然后组件中写尺寸单位就可以直接写px，具体值直接按照设计稿来做就ok","categories":[{"name":"vue","slug":"vue","permalink":"http://www.htmler.cn/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://www.htmler.cn/tags/vue/"},{"name":"移动端","slug":"移动端","permalink":"http://www.htmler.cn/tags/移动端/"}],"keywords":[{"name":"vue","slug":"vue","permalink":"http://www.htmler.cn/categories/vue/"}]},{"title":"vue移动端屏幕适配","slug":"vue移动端屏幕适配","date":"2018-08-30T03:21:55.000Z","updated":"2020-04-28T05:03:32.989Z","comments":true,"path":"posts/db9d62b2.html","link":"","permalink":"http://www.htmler.cn/posts/db9d62b2.html","excerpt":"","text":"vue移动端屏幕适配,查看项目地址 效果预览bash1234567891011# 项目clonegit clone git@github.com:NicolasGui/flexible.git# 进入项目目录cd flexible# 安装依赖npm install# 启动服务 localhost:8080npm run dev 原理概述插件安装bash12345# 插件一：amfe-flexiblenpm install amfe-flexible --save# 插件二： node-sassnpm install amfe-flexible --save # 同时，在main.js文件内引入npm install sass-loader --save 编写js处理方法在utils目录下创建flex.js文件，内容如下：javascript123456789101112import Vue from 'vue'Vue.prototype.$setTitle = function (text) &#123; document.title = text&#125;Vue.prototype.$getPX = function (design, designWidth = 750) &#123; // 750为设计稿宽度 // 获取窗口尺寸 let width = document.documentElement.getBoundingClientRect().width // 计算缩放比例 let scale = width / designWidth // 获取实时尺寸 return design * scale&#125; 同时，在main.js文件内引入该js文件javascript12345678910111213import Vue from 'vue'import App from './App'import router from './router'import 'amfe-flexible'import './utils/flex'Vue.config.productionTip = falsenew Vue(&#123; el: '#app', router, components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;) 编写css处理方法在src目录创建styles目录，同时在该目录新增common.scss文件，内容如下：scss123456789101112131415161718192021222324252627282930313233343536body,div,ul,ol,dl,li,dt,dd,h1,h2,h3,h4,p,form,iframe,input,textarea,a,span,em,strong,img,html,nav,header,article,button,footer,var &#123; padding:0; margin:0;&#125;body &#123; font:12px/1.2rem \"Microsoft YaHei\",tahoma,arial,sans-serif;min-width:320px;position:relative; &#125;form,input &#123;background:none;border:none;&#125;ul,dl,ol &#123;list-style-type:none;&#125;h1, h2, h3, h4, h5 &#123; font:12px/1.2rem \"Microsoft YaHei\",arial,tahoma; &#125;a &#123; text-decoration:none; &#125;a:hover,a:focus &#123; outline:none; &#125;table &#123; border-collapse:collapse;border-spacing:0; &#125;img &#123; border:none; &#125;strong,b &#123; font-weight:normal; &#125;em,i,var &#123; font-style:normal; &#125;p &#123; text-indent:0; &#125;.clear &#123; clear:both;height:0;line-height:0;overflow:hidden;width:0; &#125;.clearfix:after &#123; clear:both;content:\".\";display:block;font-size:0;height:0;visibility:hidden; &#125; // 尺寸转换 @function px2rem($px, $base-font-size: 75px) &#123; /*设计稿宽度为750，因此此处为75*/ @if (unitless($px)) &#123; @return px2rem($px + 0px); &#125; @else if (unit($px) == rem) &#123; @return $px; &#125; @return ($px / $base-font-size) * 1rem; &#125; // 字体转换 @mixin font-dpr($font-size) &#123; font-size: $font-size; [data-dpr=\"2\"] &amp; &#123; font-size: $font-size * 2; &#125; [data-dpr=\"3\"] &amp; &#123; font-size: $font-size * 3; &#125; &#125; css内使用scss123456&lt;style scoped lang='scss'&gt; @import '../styles/common.scss'; .content&#123; width:px2rem(750); /*750为设计稿实际尺寸*/ font-size:px2rem(20) /*20为设计稿实际尺寸*/&lt;/style&gt; js内使用javascript12345678910111213141516171819export default &#123; name:'test', data() &#123; return &#123; w:0; &#125; &#125;, watch:&#123; getWidth() &#123; this.w=this.$getPX(500); &#125; &#125; &#125;, computed: &#123; fun() &#123; return (this.w/this.$getPX(500)*100).toFixed(2) + ''; &#125; &#125; &#125;","categories":[{"name":"vue","slug":"vue","permalink":"http://www.htmler.cn/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://www.htmler.cn/tags/vue/"},{"name":"移动端","slug":"移动端","permalink":"http://www.htmler.cn/tags/移动端/"}],"keywords":[{"name":"vue","slug":"vue","permalink":"http://www.htmler.cn/categories/vue/"}]},{"title":"MAC升级Python3.x","slug":"MAC升级Python3.x","date":"2018-02-05T07:02:29.000Z","updated":"2020-04-28T05:03:32.983Z","comments":true,"path":"posts/61ca8f11.html","link":"","permalink":"http://www.htmler.cn/posts/61ca8f11.html","excerpt":"","text":"简介mac自带Python为2.7，如何升级自带版本，其实这个问题网上争议比较大，有大神删除自带python重新安装的，但是个人建议保留自带Python，通过brew安装，开发测试两不误，操作如下： 查看Python版本首先python -V得到当前系统版本是2.7.10，然后通过brew安装，不知道brew的自行度娘 brew命令bash1brew install python3 之后的话呢可能报错subunit1234Error: An unexpected error occurred during the `brew link` stepThe formula built, but is not symlinked into /usr/localPermission denied - /usr/local/FrameworksError: Permission denied - /usr/local/Frameworks 解决办法查看了日志发现/usr/local/下没有路径/usr/local/Frameworks ，所以先创建一个目录，执行maxima1sudo mkdir /usr/local/Frameworks 然后修改一下权限elixir1sudo chown $(whoami):admin /usr/local/Frameworks 接下来再link一下armasm1brew link python3 提示angelscript1Linking /usr/local/Cellar/python3/3.6.3... 1 symlinks created 代表成功了，此时我们python -V发现结果还是2.7.10,啥原因呢？系统默认选择了自带的python，解决很简单，把常规python命令换成python3，比如：python3 -V","categories":[{"name":"mac","slug":"mac","permalink":"http://www.htmler.cn/categories/mac/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://www.htmler.cn/tags/mac/"},{"name":"Python","slug":"Python","permalink":"http://www.htmler.cn/tags/Python/"}],"keywords":[{"name":"mac","slug":"mac","permalink":"http://www.htmler.cn/categories/mac/"}]},{"title":"使用mac自带阿帕奇","slug":"使用mac自带阿帕奇","date":"2017-02-24T07:02:29.000Z","updated":"2020-04-28T05:03:32.991Z","comments":true,"path":"posts/4d260f8.html","link":"","permalink":"http://www.htmler.cn/posts/4d260f8.html","excerpt":"","text":"简介Apache对于前端程序员来说是必不可少的一款web服务器，Mac系统自身带了apache，可以直接用来搭建本地web服务器，配置过程相对比较简单，本文将做简要描述，开始吧 启动Apachemac是默认自动启动Apache的，判断mac是否启动了Apache很简单，浏览器地址栏输入http://127.0.0.1 回车即可，如果页面显示It works！证明ok，介绍几个常用命令： bash12345sudo apachectl start //开启apachesudo apachectl restart //重启apachesudo apachectl stop //关闭apache: php版本检查在新的Mac High Sierra中对php版本进行了升级，所以先确定你mac的php版本ebnf1php -v 如果提示PHP 7.1.7 (cli) (built: Jul 15 2017 18:08:09) ( NTS )，则代表php是7.x版本的 基本配置ps：在进行一下操作时候，先在终端执行sudo apachectl stop停止apache服务 更改work spaceApache在Windows下默认work space为htdocs，在mac下有所区别，路径为：/Library/WebServer/Documents因此我们需要把前端代码拷贝到该目录进行测试，但是该目录藏这么深在实际使用过程中显然是比较麻烦的，因此接下来我们通过修改阿帕奇主配置文件httpd.conf来指定work space，步骤如下：mac配置文件目录为：/etc ，默认是隐藏的，因此咱们在终端里面执行：open /etc/apache2/ 就可以打开Apache主目录，找到httpd.conf文件，使用文本编辑器打开该文件， 如果不想那么麻烦的话可以使用vi编辑，命令如下： bash1sudo vi /etc/apache2/httpd.conf 接下来按一下键盘上的i键，底部提示insert……便可以移动光标进行编辑了编辑以下内容，原本为：bash12DocumentRoot \"/Library/WebServer/Documents\"&lt;Directory \"/Library/WebServer/Documents\"&gt; 修改为自定义目录，比如我改成根目录的sites文件夹，那就是：bash12DocumentRoot \"/Users/用户名/Sites\"&lt;Directory \"/Users/用户名/Sites\"&gt; ps:用户名即你mac的用户名，比如我的用户名是nicolas，那改制后应该是：bash12DocumentRoot \"/Users/nicolas/Sites\"&lt;Directory \"/Users/nicolas/Sites\"&gt; 这样子的话我们就可以把Apache的work space更改到根路径下的sites了 更改默认端口跟更改默认工作空间一样的方式打开httpd.conf，找到Listen 80这一行，将80改为你需要的端口就好 显示文件目录Apache在没有index的情况下默认不会显示文件目录，可以通过修改httpd.conf实现文件列表的展示，方便调试操作如下：将httpd.conf里面Options FollowSymLinks Multiviews之后加上Indexes，修改之后为bash1Options FollowSymLinks Multiviews Indexes 添加php7的支持在里面找到apache1#LoadModule php7_module libexec/apache2/libphp7.so 删除前面的#，修改之后是smali1LoadModule php7_module libexec/apache2/libphp7.so 接下来修改修改servername（必要操作，否则会报错）apache12#ServerAdmin you@example.comServerName localhost 以上操作都完成以后，按下 esc ，输入 :wq 然后回车紧接着在终端sudo apachectl start即可","categories":[{"name":"mac","slug":"mac","permalink":"http://www.htmler.cn/categories/mac/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://www.htmler.cn/tags/mac/"},{"name":"Apache","slug":"Apache","permalink":"http://www.htmler.cn/tags/Apache/"}],"keywords":[{"name":"mac","slug":"mac","permalink":"http://www.htmler.cn/categories/mac/"}]}]}